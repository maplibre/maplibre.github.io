(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // node_modules/maplibre-gl/dist/maplibre-gl.js
  var require_maplibre_gl = __commonJS({
    "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, maplibregl;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
            var sharedChunk = {};
            shared(sharedChunk);
            maplibregl = chunk(sharedChunk);
            if (typeof window !== "undefined") {
              maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          "use strict";
          var e = r;
          function r(t2, e2, r2, n2) {
            this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
          }
          function n(t2, r2, n2, i2) {
            const s2 = new e(t2, r2, n2, i2);
            return function(t3) {
              return s2.solve(t3);
            };
          }
          r.prototype = { sampleCurveX: function(t2) {
            return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
          }, sampleCurveY: function(t2) {
            return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
          }, sampleCurveDerivativeX: function(t2) {
            return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
          }, solveCurveX: function(t2, e2) {
            if (e2 === void 0 && (e2 = 1e-6), t2 < 0)
              return 0;
            if (t2 > 1)
              return 1;
            for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
              var i2 = this.sampleCurveX(r2) - t2;
              if (Math.abs(i2) < e2)
                return r2;
              var s2 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(s2) < 1e-6)
                break;
              r2 -= i2 / s2;
            }
            var a2 = 0, o2 = 1;
            for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
              t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
            return r2;
          }, solve: function(t2, e2) {
            return this.sampleCurveY(this.solveCurveX(t2, e2));
          } };
          const i = n(0.25, 0.1, 0.25, 1);
          function s(t2, e2, r2) {
            return Math.min(r2, Math.max(e2, t2));
          }
          function a(t2, e2, r2) {
            const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r2 : i2;
          }
          function o(t2, ...e2) {
            for (const r2 of e2)
              for (const e3 in r2)
                t2[e3] = r2[e3];
            return t2;
          }
          let l = 1;
          function u(t2, e2) {
            t2.forEach((t3) => {
              e2[t3] && (e2[t3] = e2[t3].bind(e2));
            });
          }
          function c(t2, e2, r2) {
            const n2 = {};
            for (const i2 in t2)
              n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
            return n2;
          }
          function h(t2, e2, r2) {
            const n2 = {};
            for (const i2 in t2)
              e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
            return n2;
          }
          function p(t2) {
            return Array.isArray(t2) ? t2.map(p) : typeof t2 == "object" && t2 ? c(t2, p) : t2;
          }
          const f = {};
          function d(t2) {
            f[t2] || (typeof console != "undefined" && console.warn(t2), f[t2] = true);
          }
          function y(t2, e2, r2) {
            return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
          }
          function m(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          function g() {
            return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope;
          }
          function x(t2) {
            const e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
              const s2 = n2 || i2;
              return e2[r2] = !s2 || s2.toLowerCase(), "";
            }), e2["max-age"]) {
              const t3 = parseInt(e2["max-age"], 10);
              isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
            }
            return e2;
          }
          let v, b, w = null;
          function _(t2) {
            if (w == null) {
              const e2 = t2.navigator ? t2.navigator.userAgent : null;
              w = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
            }
            return w;
          }
          function A(t2) {
            return typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap;
          }
          const k = { now: typeof performance != "undefined" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t2) {
            const e2 = requestAnimationFrame(t2);
            return { cancel: () => cancelAnimationFrame(e2) };
          }, getImageData(t2, e2 = 0) {
            const r2 = window.document.createElement("canvas"), n2 = r2.getContext("2d");
            if (!n2)
              throw new Error("failed to create canvas 2d context");
            return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
          }, resolveURL: (t2) => (v || (v = document.createElement("a")), v.href = t2, v.href), hardwareConcurrency: typeof navigator != "undefined" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
            return !!matchMedia && (b == null && (b = matchMedia("(prefers-reduced-motion: reduce)")), b.matches);
          } };
          var S = z;
          function z(t2, e2) {
            this.x = t2, this.y = e2;
          }
          z.prototype = { clone: function() {
            return new z(this.x, this.y);
          }, add: function(t2) {
            return this.clone()._add(t2);
          }, sub: function(t2) {
            return this.clone()._sub(t2);
          }, multByPoint: function(t2) {
            return this.clone()._multByPoint(t2);
          }, divByPoint: function(t2) {
            return this.clone()._divByPoint(t2);
          }, mult: function(t2) {
            return this.clone()._mult(t2);
          }, div: function(t2) {
            return this.clone()._div(t2);
          }, rotate: function(t2) {
            return this.clone()._rotate(t2);
          }, rotateAround: function(t2, e2) {
            return this.clone()._rotateAround(t2, e2);
          }, matMult: function(t2) {
            return this.clone()._matMult(t2);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t2) {
            return this.x === t2.x && this.y === t2.y;
          }, dist: function(t2) {
            return Math.sqrt(this.distSqr(t2));
          }, distSqr: function(t2) {
            var e2 = t2.x - this.x, r2 = t2.y - this.y;
            return e2 * e2 + r2 * r2;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t2) {
            return Math.atan2(this.y - t2.y, this.x - t2.x);
          }, angleWith: function(t2) {
            return this.angleWithSep(t2.x, t2.y);
          }, angleWithSep: function(t2, e2) {
            return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
          }, _matMult: function(t2) {
            var e2 = t2[2] * this.x + t2[3] * this.y;
            return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
          }, _add: function(t2) {
            return this.x += t2.x, this.y += t2.y, this;
          }, _sub: function(t2) {
            return this.x -= t2.x, this.y -= t2.y, this;
          }, _mult: function(t2) {
            return this.x *= t2, this.y *= t2, this;
          }, _div: function(t2) {
            return this.x /= t2, this.y /= t2, this;
          }, _multByPoint: function(t2) {
            return this.x *= t2.x, this.y *= t2.y, this;
          }, _divByPoint: function(t2) {
            return this.x /= t2.x, this.y /= t2.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t2 = this.y;
            return this.y = this.x, this.x = -t2, this;
          }, _rotate: function(t2) {
            var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
            return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
          }, _rotateAround: function(t2, e2) {
            var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
            return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, z.convert = function(t2) {
            return t2 instanceof z ? t2 : Array.isArray(t2) ? new z(t2[0], t2[1]) : t2;
          };
          const I = { MAX_PARALLEL_IMAGE_REQUESTS: 16, REGISTERED_PROTOCOLS: {} }, M = "mapbox-tiles";
          let B, C, P = 500, V = 50;
          function E() {
            typeof caches == "undefined" || B || (B = caches.open(M));
          }
          let F = 1 / 0;
          const T = { supported: false, testSupport: function(t2) {
            !$ && D && (R ? U(t2) : L = t2);
          } };
          let L, D, $ = false, R = false;
          function U(t2) {
            const e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, D), t2.isContextLost())
                return;
              T.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e2), $ = true;
          }
          typeof document != "undefined" && (D = document.createElement("img"), D.onload = function() {
            L && U(L), L = null, R = true;
          }, D.onerror = function() {
            $ = true, L = null;
          }, D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          const O = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
          typeof Object.freeze == "function" && Object.freeze(O);
          class q extends Error {
            constructor(t2, e2, r2, n2) {
              super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
            }
          }
          const j = g() ? () => self.worker && self.worker.referrer : () => (window.location.protocol === "blob:" ? window.parent : window).location.href;
          function N(t2, e2) {
            const r2 = new AbortController(), n2 = new Request(t2.url, { method: t2.method || "GET", body: t2.body, credentials: t2.credentials, headers: t2.headers, referrer: j(), signal: r2.signal });
            let i2 = false, s2 = false;
            t2.type === "json" && n2.headers.set("Accept", "application/json");
            return ((r3, a2, o2) => {
              if (s2)
                return;
              const l2 = Date.now();
              fetch(n2).then((r4) => r4.ok ? ((r5, a3, o3) => {
                (t2.type === "arrayBuffer" ? r5.arrayBuffer() : t2.type === "json" ? r5.json() : r5.text()).then((t3) => {
                  s2 || (a3 && o3 && function(t4, e3, r6) {
                    if (E(), !B)
                      return;
                    const n3 = { status: e3.status, statusText: e3.statusText, headers: new Headers() };
                    e3.headers.forEach((t5, e4) => n3.headers.set(e4, t5));
                    const i3 = x(e3.headers.get("Cache-Control") || "");
                    i3["no-store"] || (i3["max-age"] && n3.headers.set("Expires", new Date(r6 + 1e3 * i3["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r6 < 42e4 || function(t5, e4) {
                      if (C === void 0)
                        try {
                          new Response(new ReadableStream()), C = true;
                        } catch (t6) {
                          C = false;
                        }
                      C ? e4(t5.body) : t5.blob().then(e4);
                    }(e3, (e4) => {
                      const r7 = new Response(e4, n3);
                      E(), B && B.then((e5) => e5.put(function(t5) {
                        const e6 = t5.indexOf("?");
                        return e6 < 0 ? t5 : t5.slice(0, e6);
                      }(t4.url), r7)).catch((t5) => d(t5.message));
                    }));
                  }(n2, a3, o3), i2 = true, e2(null, t3, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
                }).catch((t3) => {
                  s2 || e2(new Error(t3.message));
                });
              })(r4, null, l2) : r4.blob().then((n3) => e2(new q(r4.status, r4.statusText, t2.url, n3)))).catch((t3) => {
                t3.code !== 20 && e2(new Error(t3.message));
              });
            })(), { cancel: () => {
              s2 = true, i2 || r2.abort();
            } };
          }
          const K = function(t2, e2) {
            if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
              if (g() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e2);
              if (!g()) {
                const r3 = t2.url.substring(0, t2.url.indexOf("://"));
                return (I.REGISTERED_PROTOCOLS[r3] || N)(t2, e2);
              }
            }
            if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(j()) && !/^\w+:/.test(r2))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                return N(t2, e2);
              if (g() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e2, void 0, true);
            }
            var r2;
            return function(t3, e3) {
              const r3 = new XMLHttpRequest();
              r3.open(t3.method || "GET", t3.url, true), t3.type === "arrayBuffer" && (r3.responseType = "arraybuffer");
              for (const e4 in t3.headers)
                r3.setRequestHeader(e4, t3.headers[e4]);
              return t3.type === "json" && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = t3.credentials === "include", r3.onerror = () => {
                e3(new Error(r3.statusText));
              }, r3.onload = () => {
                if ((r3.status >= 200 && r3.status < 300 || r3.status === 0) && r3.response !== null) {
                  let n2 = r3.response;
                  if (t3.type === "json")
                    try {
                      n2 = JSON.parse(r3.response);
                    } catch (t4) {
                      return e3(t4);
                    }
                  e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
                } else {
                  const n2 = new Blob([r3.response], { type: r3.getResponseHeader("Content-Type") });
                  e3(new q(r3.status, r3.statusText, t3.url, n2));
                }
              }, r3.send(t3.body), { cancel: () => r3.abort() };
            }(t2, e2);
          }, Z = function(t2, e2) {
            return K(o(t2, { type: "arrayBuffer" }), e2);
          };
          function G(t2) {
            const e2 = window.document.createElement("a");
            return e2.href = t2, e2.protocol === window.document.location.protocol && e2.host === window.document.location.host;
          }
          const J = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let X, Y;
          X = [], Y = 0;
          const H = function(t2, e2) {
            if (T.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Y >= I.MAX_PARALLEL_IMAGE_REQUESTS) {
              const r3 = { requestParameters: t2, callback: e2, cancelled: false, cancel() {
                this.cancelled = true;
              } };
              return X.push(r3), r3;
            }
            Y++;
            let r2 = false;
            const n2 = () => {
              if (!r2)
                for (r2 = true, Y--; X.length && Y < I.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  const t3 = X.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
                  n3 || (t3.cancel = H(e3, r3).cancel);
                }
            }, i2 = Z(t2, (t3, r3, i3, s2) => {
              n2(), t3 ? e2(t3) : r3 && function(t4, e3) {
                typeof createImageBitmap == "function" ? function(t5, e4) {
                  const r4 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                  createImageBitmap(r4).then((t6) => {
                    e4(null, t6);
                  }).catch((t6) => {
                    e4(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                  });
                }(t4, e3) : function(t5, e4) {
                  const r4 = new Image();
                  r4.onload = () => {
                    e4(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, window.requestAnimationFrame(() => {
                      r4.src = J;
                    });
                  }, r4.onerror = () => e4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                  const n3 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                  r4.src = t5.byteLength ? URL.createObjectURL(n3) : J;
                }(t4, e3);
              }(r3, (t4, r4) => {
                t4 != null ? e2(t4) : r4 != null && e2(null, r4, { cacheControl: i3, expires: s2 });
              });
            });
            return { cancel: () => {
              i2.cancel(), n2();
            } };
          };
          function W(t2, e2, r2) {
            r2[t2] && r2[t2].indexOf(e2) !== -1 || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
          }
          function Q(t2, e2, r2) {
            if (r2 && r2[t2]) {
              const n2 = r2[t2].indexOf(e2);
              n2 !== -1 && r2[t2].splice(n2, 1);
            }
          }
          class tt {
            constructor(t2, e2 = {}) {
              o(this, e2), this.type = t2;
            }
          }
          class et extends tt {
            constructor(t2, e2 = {}) {
              super("error", o({ error: t2 }, e2));
            }
          }
          class rt {
            on(t2, e2) {
              return this._listeners = this._listeners || {}, W(t2, e2, this._listeners), this;
            }
            off(t2, e2) {
              return Q(t2, e2, this._listeners), Q(t2, e2, this._oneTimeListeners), this;
            }
            once(t2, e2) {
              return this._oneTimeListeners = this._oneTimeListeners || {}, W(t2, e2, this._oneTimeListeners), this;
            }
            fire(t2, e2) {
              typeof t2 == "string" && (t2 = new tt(t2, e2 || {}));
              const r2 = t2.type;
              if (this.listens(r2)) {
                t2.target = this;
                const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
                for (const r3 of e3)
                  r3.call(this, t2);
                const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
                for (const e4 of n2)
                  Q(r2, e4, this._oneTimeListeners), e4.call(this, t2);
                const i2 = this._eventedParent;
                i2 && (o(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
              } else
                t2 instanceof et && console.error(t2.error);
              return this;
            }
            listens(t2) {
              return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
            }
            setEventedParent(t2, e2) {
              return this._eventedParent = t2, this._eventedParentData = e2, this;
            }
          }
          var nt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 }, elevationOffset: { type: "number", default: 450 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          class it {
            constructor(t2, e2, r2, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
            }
          }
          function st(t2) {
            const e2 = t2.value;
            return e2 ? [new it(t2.key, e2, "constants have been deprecated as of v8")] : [];
          }
          function at(t2, ...e2) {
            for (const r2 of e2)
              for (const e3 in r2)
                t2[e3] = r2[e3];
            return t2;
          }
          function ot(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function lt(t2) {
            if (Array.isArray(t2))
              return t2.map(lt);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e2 = {};
              for (const r2 in t2)
                e2[r2] = lt(t2[r2]);
              return e2;
            }
            return ot(t2);
          }
          class ut extends Error {
            constructor(t2, e2) {
              super(e2), this.message = e2, this.key = t2;
            }
          }
          class ct {
            constructor(t2, e2 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r2] of e2)
                this.bindings[t3] = r2;
            }
            concat(t2) {
              return new ct(this, t2);
            }
            get(t2) {
              if (this.bindings[t2])
                return this.bindings[t2];
              if (this.parent)
                return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "resolvedImage" };
          function wt(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function _t(t2) {
            if (t2.kind === "array") {
              const e2 = _t(t2.itemType);
              return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
            }
            return t2.kind;
          }
          const At = [ht, pt, ft, dt, yt, vt, mt, wt(gt), bt];
          function kt(t2, e2) {
            if (e2.kind === "error")
              return null;
            if (t2.kind === "array") {
              if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !kt(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
                return null;
            } else {
              if (t2.kind === e2.kind)
                return null;
              if (t2.kind === "value") {
                for (const t3 of At)
                  if (!kt(t3, e2))
                    return null;
              }
            }
            return `Expected ${_t(t2)} but found ${_t(e2)} instead.`;
          }
          function St(t2, e2) {
            return e2.some((e3) => e3.kind === t2.kind);
          }
          function zt(t2, e2) {
            return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
          }
          var It, Mt = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function Bt(t2) {
            return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
          }
          function Ct(t2) {
            return Bt(t2[t2.length - 1] === "%" ? parseFloat(t2) / 100 * 255 : parseInt(t2));
          }
          function Pt(t2) {
            return (e2 = t2[t2.length - 1] === "%" ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e2 > 1 ? 1 : e2;
            var e2;
          }
          function Vt(t2, e2, r2) {
            return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e2 - t2) * r2 * 6 : 2 * r2 < 1 ? e2 : 3 * r2 < 2 ? t2 + (e2 - t2) * (2 / 3 - r2) * 6 : t2;
          }
          try {
            It = {}.parseCSSColor = function(t2) {
              var e2, r2 = t2.replace(/ /g, "").toLowerCase();
              if (r2 in Mt)
                return Mt[r2].slice();
              if (r2[0] === "#")
                return r2.length === 4 ? (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 4095 ? [(3840 & e2) >> 4 | (3840 & e2) >> 8, 240 & e2 | (240 & e2) >> 4, 15 & e2 | (15 & e2) << 4, 1] : null : r2.length === 7 && (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 16777215 ? [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2, 1] : null;
              var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
              if (n2 !== -1 && i2 + 1 === r2.length) {
                var s2 = r2.substr(0, n2), a2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
                switch (s2) {
                  case "rgba":
                    if (a2.length !== 4)
                      return null;
                    o2 = Pt(a2.pop());
                  case "rgb":
                    return a2.length !== 3 ? null : [Ct(a2[0]), Ct(a2[1]), Ct(a2[2]), o2];
                  case "hsla":
                    if (a2.length !== 4)
                      return null;
                    o2 = Pt(a2.pop());
                  case "hsl":
                    if (a2.length !== 3)
                      return null;
                    var l2 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u2 = Pt(a2[1]), c2 = Pt(a2[2]), h2 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h2;
                    return [Bt(255 * Vt(p2, h2, l2 + 1 / 3)), Bt(255 * Vt(p2, h2, l2)), Bt(255 * Vt(p2, h2, l2 - 1 / 3)), o2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t2) {
          }
          class Et {
            constructor(t2, e2, r2, n2 = 1) {
              this.r = t2, this.g = e2, this.b = r2, this.a = n2;
            }
            static parse(t2) {
              if (!t2)
                return;
              if (t2 instanceof Et)
                return t2;
              if (typeof t2 != "string")
                return;
              const e2 = It(t2);
              return e2 ? new Et(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
            }
            toString() {
              const [t2, e2, r2, n2] = this.toArray();
              return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
            }
            toArray() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return n2 === 0 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
            }
          }
          Et.black = new Et(0, 0, 0, 1), Et.white = new Et(1, 1, 1, 1), Et.transparent = new Et(0, 0, 0, 0), Et.red = new Et(1, 0, 0, 1);
          class Ft {
            constructor(t2, e2, r2) {
              this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e2) {
              return this.collator.compare(t2, e2);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class Tt {
            constructor(t2, e2, r2, n2, i2) {
              this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
            }
          }
          class Lt {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new Lt([new Tt(t2, null, null, null, null)]);
            }
            isEmpty() {
              return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
            }
            static factory(t2) {
              return t2 instanceof Lt ? t2 : Lt.fromString(t2);
            }
            toString() {
              return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                if (e2.image) {
                  t2.push(["image", e2.image.name]);
                  continue;
                }
                t2.push(e2.text);
                const r2 = {};
                e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r2);
              }
              return t2;
            }
          }
          class Dt {
            constructor(t2) {
              this.name = t2.name, this.available = t2.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t2) {
              return t2 ? new Dt({ name: t2, available: false }) : null;
            }
            serialize() {
              return ["image", this.name];
            }
          }
          function $t(t2, e2, r2, n2) {
            return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r2 == "number" && r2 >= 0 && r2 <= 255 ? n2 === void 0 || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function Rt(t2) {
            if (t2 === null)
              return true;
            if (typeof t2 == "string")
              return true;
            if (typeof t2 == "boolean")
              return true;
            if (typeof t2 == "number")
              return true;
            if (t2 instanceof Et)
              return true;
            if (t2 instanceof Ft)
              return true;
            if (t2 instanceof Lt)
              return true;
            if (t2 instanceof Dt)
              return true;
            if (Array.isArray(t2)) {
              for (const e2 of t2)
                if (!Rt(e2))
                  return false;
              return true;
            }
            if (typeof t2 == "object") {
              for (const e2 in t2)
                if (!Rt(t2[e2]))
                  return false;
              return true;
            }
            return false;
          }
          function Ut(t2) {
            if (t2 === null)
              return ht;
            if (typeof t2 == "string")
              return ft;
            if (typeof t2 == "boolean")
              return dt;
            if (typeof t2 == "number")
              return pt;
            if (t2 instanceof Et)
              return yt;
            if (t2 instanceof Ft)
              return xt;
            if (t2 instanceof Lt)
              return vt;
            if (t2 instanceof Dt)
              return bt;
            if (Array.isArray(t2)) {
              const e2 = t2.length;
              let r2;
              for (const e3 of t2) {
                const t3 = Ut(e3);
                if (r2) {
                  if (r2 === t3)
                    continue;
                  r2 = gt;
                  break;
                }
                r2 = t3;
              }
              return wt(r2 || gt, e2);
            }
            return mt;
          }
          function Ot(t2) {
            const e2 = typeof t2;
            return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof Et || t2 instanceof Lt || t2 instanceof Dt ? t2.toString() : JSON.stringify(t2);
          }
          class qt {
            constructor(t2, e2) {
              this.type = t2, this.value = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!Rt(t2[1]))
                return e2.error("invalid value");
              const r2 = t2[1];
              let n2 = Ut(r2);
              const i2 = e2.expectedType;
              return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new qt(n2, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Et ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Lt ? this.value.serialize() : this.value;
            }
          }
          class jt {
            constructor(t2) {
              this.name = "ExpressionEvaluationError", this.message = t2;
            }
            toJSON() {
              return this.message;
            }
          }
          const Nt = { string: ft, number: pt, boolean: dt, object: mt };
          class Kt {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              let r2, n2 = 1;
              const i2 = t2[0];
              if (i2 === "array") {
                let i3, s3;
                if (t2.length > 2) {
                  const r3 = t2[1];
                  if (typeof r3 != "string" || !(r3 in Nt) || r3 === "object")
                    return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = Nt[r3], n2++;
                } else
                  i3 = gt;
                if (t2.length > 3) {
                  if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                    return e2.error('The length argument to "array" must be a positive integer literal', 2);
                  s3 = t2[2], n2++;
                }
                r2 = wt(i3, s3);
              } else
                r2 = Nt[i2];
              const s2 = [];
              for (; n2 < t2.length; n2++) {
                const r3 = e2.parse(t2[n2], n2, gt);
                if (!r3)
                  return null;
                s2.push(r3);
              }
              return new Kt(r2, s2);
            }
            evaluate(t2) {
              for (let e2 = 0; e2 < this.args.length; e2++) {
                const r2 = this.args[e2].evaluate(t2);
                if (!kt(this.type, Ut(r2)))
                  return r2;
                if (e2 === this.args.length - 1)
                  throw new jt(`Expected value to be of type ${_t(this.type)}, but found ${_t(Ut(r2))} instead.`);
              }
              return null;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = this.type, e2 = [t2.kind];
              if (t2.kind === "array") {
                const r2 = t2.itemType;
                if (r2.kind === "string" || r2.kind === "number" || r2.kind === "boolean") {
                  e2.push(r2.kind);
                  const n2 = t2.N;
                  (typeof n2 == "number" || this.args.length > 1) && e2.push(n2);
                }
              }
              return e2.concat(this.args.map((t3) => t3.serialize()));
            }
          }
          class Zt {
            constructor(t2) {
              this.type = vt, this.sections = t2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r2 = t2[1];
              if (!Array.isArray(r2) && typeof r2 == "object")
                return e2.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
                const s2 = t2[r3];
                if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
                  i2 = false;
                  let t3 = null;
                  if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, pt), !t3))
                    return null;
                  let r4 = null;
                  if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, wt(ft)), !r4))
                    return null;
                  let a2 = null;
                  if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, yt), !a2))
                    return null;
                  const o2 = n2[n2.length - 1];
                  o2.scale = t3, o2.font = r4, o2.textColor = a2;
                } else {
                  const s3 = e2.parse(t2[r3], 1, gt);
                  if (!s3)
                    return null;
                  const a2 = s3.type.kind;
                  if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                    return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
                }
              }
              return new Zt(n2);
            }
            evaluate(t2) {
              return new Lt(this.sections.map((e2) => {
                const r2 = e2.content.evaluate(t2);
                return Ut(r2) === bt ? new Tt("", r2, null, null, null) : new Tt(Ot(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e2 of this.sections)
                t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                t2.push(e2.content.serialize());
                const r2 = {};
                e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
              }
              return t2;
            }
          }
          class Gt {
            constructor(t2) {
              this.type = bt, this.input = t2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, ft);
              return r2 ? new Gt(r2) : e2.error("No image name provided.");
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = Dt.fromString(e2);
              return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["image", this.input.serialize()];
            }
          }
          const Jt = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
          class Xt {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r2 = t2[0];
              if ((r2 === "to-boolean" || r2 === "to-string") && t2.length !== 2)
                return e2.error("Expected one argument.");
              const n2 = Jt[r2], i2 = [];
              for (let r3 = 1; r3 < t2.length; r3++) {
                const n3 = e2.parse(t2[r3], r3, gt);
                if (!n3)
                  return null;
                i2.push(n3);
              }
              return new Xt(n2, i2);
            }
            evaluate(t2) {
              if (this.type.kind === "boolean")
                return Boolean(this.args[0].evaluate(t2));
              if (this.type.kind === "color") {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Et)
                    return e2;
                  if (typeof e2 == "string") {
                    const r3 = t2.parseColor(e2);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : $t(e2[0], e2[1], e2[2], e2[3]), !r2))
                    return new Et(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new jt(r2 || `Could not parse color from value '${typeof e2 == "string" ? e2 : String(JSON.stringify(e2))}'`);
              }
              if (this.type.kind === "number") {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), e2 === null)
                    return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new jt(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              return this.type.kind === "formatted" ? Lt.fromString(Ot(this.args[0].evaluate(t2))) : this.type.kind === "resolvedImage" ? Dt.fromString(Ot(this.args[0].evaluate(t2))) : Ot(this.args[0].evaluate(t2));
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              if (this.type.kind === "formatted")
                return new Zt([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
              if (this.type.kind === "resolvedImage")
                return new Gt(this.args[0]).serialize();
              const t2 = [`to-${this.type.kind}`];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const Yt = ["Unknown", "Point", "LineString", "Polygon"];
          class Ht {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? typeof this.feature.type == "number" ? Yt[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t2) {
              let e2 = this._parseColorCache[t2];
              return e2 || (e2 = this._parseColorCache[t2] = Et.parse(t2)), e2;
            }
          }
          class Wt {
            constructor(t2, e2, r2, n2) {
              this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
            }
            evaluate(t2) {
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return [this.name].concat(this.args.map((t2) => t2.serialize()));
            }
            static parse(t2, e2) {
              const r2 = t2[0], n2 = Wt.definitions[r2];
              if (!n2)
                return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
              let o2 = null;
              for (const [n3, s3] of a2) {
                o2 = new we(e2.registry, e2.path, null, e2.scope);
                const a3 = [];
                let l2 = false;
                for (let e3 = 1; e3 < t2.length; e3++) {
                  const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                  if (!s4) {
                    l2 = true;
                    break;
                  }
                  a3.push(s4);
                }
                if (!l2)
                  if (Array.isArray(n3) && n3.length !== a3.length)
                    o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                  else {
                    for (let t3 = 0; t3 < a3.length; t3++) {
                      const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                      o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                    }
                    if (o2.errors.length === 0)
                      return new Wt(r2, i2, s3, a3);
                  }
              }
              if (a2.length === 1)
                e2.errors.push(...o2.errors);
              else {
                const r3 = (a2.length ? a2 : s2).map(([t3]) => {
                  return e3 = t3, Array.isArray(e3) ? `(${e3.map(_t).join(", ")})` : `(${_t(e3.type)}...)`;
                  var e3;
                }).join(" | "), n3 = [];
                for (let r4 = 1; r4 < t2.length; r4++) {
                  const i3 = e2.parse(t2[r4], 1 + n3.length);
                  if (!i3)
                    return null;
                  n3.push(_t(i3.type));
                }
                e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e2) {
              Wt.definitions = e2;
              for (const r2 in e2)
                t2[r2] = Wt;
            }
          }
          class Qt {
            constructor(t2, e2, r2) {
              this.type = xt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error("Expected one argument.");
              const r2 = t2[1];
              if (typeof r2 != "object" || Array.isArray(r2))
                return e2.error("Collator options argument must be an object.");
              const n2 = e2.parse(r2["case-sensitive"] !== void 0 && r2["case-sensitive"], 1, dt);
              if (!n2)
                return null;
              const i2 = e2.parse(r2["diacritic-sensitive"] !== void 0 && r2["diacritic-sensitive"], 1, dt);
              if (!i2)
                return null;
              let s2 = null;
              return r2.locale && (s2 = e2.parse(r2.locale, 1, ft), !s2) ? null : new Qt(n2, i2, s2);
            }
            evaluate(t2) {
              return new Ft(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
            }
          }
          const te = 8192;
          function ee(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function re(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function ne(t2, e2) {
            const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r2 * i2 * te), Math.round(n2 * i2 * te)];
          }
          function ie(t2, e2, r2) {
            const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
            return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
          }
          function se(t2, e2) {
            let r2 = false;
            for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
              const o3 = e2[a2];
              for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
                if (ie(t2, o3[e3], o3[e3 + 1]))
                  return false;
                (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r2 = !r2);
              }
            }
            var n2, i2, s2;
            return r2;
          }
          function ae(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++)
              if (se(t2, e2[r2]))
                return true;
            return false;
          }
          function oe(t2, e2, r2, n2) {
            const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
            return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
          }
          function le(t2, e2, r2) {
            for (const u2 of r2)
              for (let r3 = 0; r3 < u2.length - 1; ++r3)
                if ((o2 = [(a2 = u2[r3 + 1])[0] - (s2 = u2[r3])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] != 0 && oe(n2, i2, s2, a2) && oe(s2, a2, n2, i2))
                  return true;
            var n2, i2, s2, a2, o2, l2;
            return false;
          }
          function ue(t2, e2) {
            for (let r2 = 0; r2 < t2.length; ++r2)
              if (!se(t2[r2], e2))
                return false;
            for (let r2 = 0; r2 < t2.length - 1; ++r2)
              if (le(t2[r2], t2[r2 + 1], e2))
                return false;
            return true;
          }
          function ce(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++)
              if (ue(t2, e2[r2]))
                return true;
            return false;
          }
          function he(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const a2 = ne(t2[i2][n3], r2);
                ee(e2, a2), s2.push(a2);
              }
              n2.push(s2);
            }
            return n2;
          }
          function pe(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = he(t2[i2], e2, r2);
              n2.push(s2);
            }
            return n2;
          }
          function fe(t2, e2, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              const e3 = 0.5 * n2;
              let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
              i2 === 0 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
            }
            ee(e2, t2);
          }
          function de(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * te, s2 = [n2.x * te, n2.y * te], a2 = [];
            for (const n3 of t2)
              for (const t3 of n3) {
                const n4 = [t3.x + s2[0], t3.y + s2[1]];
                fe(n4, e2, r2, i2), a2.push(n4);
              }
            return a2;
          }
          function ye(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * te, s2 = [n2.x * te, n2.y * te], a2 = [];
            for (const r3 of t2) {
              const t3 = [];
              for (const n3 of r3) {
                const r4 = [n3.x + s2[0], n3.y + s2[1]];
                ee(e2, r4), t3.push(r4);
              }
              a2.push(t3);
            }
            if (e2[2] - e2[0] <= i2 / 2) {
              (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t3 of a2)
                for (const n3 of t3)
                  fe(n3, e2, r2, i2);
            }
            var o2;
            return a2;
          }
          class me {
            constructor(t2, e2) {
              this.type = dt, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (Rt(t2[1])) {
                const e3 = t2[1];
                if (e3.type === "FeatureCollection")
                  for (let t3 = 0; t3 < e3.features.length; ++t3) {
                    const r2 = e3.features[t3].geometry.type;
                    if (r2 === "Polygon" || r2 === "MultiPolygon")
                      return new me(e3, e3.features[t3].geometry);
                  }
                else if (e3.type === "Feature") {
                  const t3 = e3.geometry.type;
                  if (t3 === "Polygon" || t3 === "MultiPolygon")
                    return new me(e3, e3.geometry);
                } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
                  return new me(e3, e3);
              }
              return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (t2.geometry() != null && t2.canonicalID() != null) {
                if (t2.geometryType() === "Point")
                  return function(t3, e2) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (e2.type === "Polygon") {
                      const s2 = he(e2.coordinates, n2, i2), a2 = de(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!se(t4, s2))
                          return false;
                    }
                    if (e2.type === "MultiPolygon") {
                      const s2 = pe(e2.coordinates, n2, i2), a2 = de(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!ae(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
                if (t2.geometryType() === "LineString")
                  return function(t3, e2) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (e2.type === "Polygon") {
                      const s2 = he(e2.coordinates, n2, i2), a2 = ye(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!ue(t4, s2))
                          return false;
                    }
                    if (e2.type === "MultiPolygon") {
                      const s2 = pe(e2.coordinates, n2, i2), a2 = ye(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!ce(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["within", this.geojson];
            }
          }
          function ge(t2) {
            if (t2 instanceof Wt) {
              if (t2.name === "get" && t2.args.length === 1)
                return false;
              if (t2.name === "feature-state")
                return false;
              if (t2.name === "has" && t2.args.length === 1)
                return false;
              if (t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id")
                return false;
              if (/^filter-/.test(t2.name))
                return false;
            }
            if (t2 instanceof me)
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !ge(t3) && (e2 = false);
            }), e2;
          }
          function xe(t2) {
            if (t2 instanceof Wt && t2.name === "feature-state")
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !xe(t3) && (e2 = false);
            }), e2;
          }
          function ve(t2, e2) {
            if (t2 instanceof Wt && e2.indexOf(t2.name) >= 0)
              return false;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 && !ve(t3, e2) && (r2 = false);
            }), r2;
          }
          class be {
            constructor(t2, e2) {
              this.type = e2.type, this.name = t2, this.boundExpression = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2 || typeof t2[1] != "string")
                return e2.error("'var' expression requires exactly one string literal argument.");
              const r2 = t2[1];
              return e2.scope.has(r2) ? new be(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["var", this.name];
            }
          }
          class we {
            constructor(t2, e2 = [], r2, n2 = new ct(), i2 = []) {
              this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
            }
            parse(t2, e2, r2, n2, i2 = {}) {
              return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            _parse(t2, e2) {
              function r2(t3, e3, r3) {
                return r3 === "assert" ? new Kt(e3, [t3]) : r3 === "coerce" ? new Xt(e3, [t3]) : t3;
              }
              if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (t2.length === 0)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = t2[0];
                if (typeof n2 != "string")
                  return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i2 = this.registry[n2];
                if (i2) {
                  let n3 = i2.parse(t2, this);
                  if (!n3)
                    return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, i3 = n3.type;
                    if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value")
                      if (t3.kind !== "color" && t3.kind !== "formatted" && t3.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string") {
                        if (this.checkSubtype(t3, i3))
                          return null;
                      } else
                        n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                  }
                  if (!(n3 instanceof qt) && n3.type.kind !== "resolvedImage" && _e(n3)) {
                    const t3 = new Ht();
                    try {
                      n3 = new qt(n3.type, n3.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return n3;
                }
                return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(t2 === void 0 ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e2, r2) {
              const n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
              return new we(this.registry, n2, e2 || null, i2, this.errors);
            }
            error(t2, ...e2) {
              const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new ut(r2, t2));
            }
            checkSubtype(t2, e2) {
              const r2 = kt(t2, e2);
              return r2 && this.error(r2), r2;
            }
          }
          function _e(t2) {
            if (t2 instanceof be)
              return _e(t2.boundExpression);
            if (t2 instanceof Wt && t2.name === "error")
              return false;
            if (t2 instanceof Qt)
              return false;
            if (t2 instanceof me)
              return false;
            const e2 = t2 instanceof Xt || t2 instanceof Kt;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 = e2 ? r2 && _e(t3) : r2 && t3 instanceof qt;
            }), !!r2 && ge(t2) && ve(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
          }
          function Ae(t2, e2) {
            const r2 = t2.length - 1;
            let n2, i2, s2 = 0, a2 = r2, o2 = 0;
            for (; s2 <= a2; )
              if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
                if (o2 === r2 || e2 < i2)
                  return o2;
                s2 = o2 + 1;
              } else {
                if (!(n2 > e2))
                  throw new jt("Input is not a number.");
                a2 = o2 - 1;
              }
            return 0;
          }
          class ke {
            constructor(t2, e2, r2) {
              this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of r2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static parse(t2, e2) {
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              const r2 = e2.parse(t2[1], 1, pt);
              if (!r2)
                return null;
              const n2 = [];
              let i2 = null;
              e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
              for (let r3 = 1; r3 < t2.length; r3 += 2) {
                const s2 = r3 === 1 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
                if (typeof s2 != "number")
                  return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n2.length && n2[n2.length - 1][0] >= s2)
                  return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e2.parse(a2, l2, i2);
                if (!u2)
                  return null;
                i2 = i2 || u2.type, n2.push([s2, u2]);
              }
              return new ke(i2, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (e2.length === 1)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r2[0].evaluate(t2);
              const i2 = e2.length;
              return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Ae(e2, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["step", this.input.serialize()];
              for (let e2 = 0; e2 < this.labels.length; e2++)
                e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
              return t2;
            }
          }
          function Se(t2, e2, r2) {
            return t2 * (1 - r2) + e2 * r2;
          }
          var ze = Object.freeze({ __proto__: null, number: Se, color: function(t2, e2, r2) {
            return new Et(Se(t2.r, e2.r, r2), Se(t2.g, e2.g, r2), Se(t2.b, e2.b, r2), Se(t2.a, e2.a, r2));
          }, array: function(t2, e2, r2) {
            return t2.map((t3, n2) => Se(t3, e2[n2], r2));
          } });
          const Ie = 0.95047, Me = 1.08883, Be = 4 / 29, Ce = 6 / 29, Pe = 3 * Ce * Ce, Ve = Math.PI / 180, Ee = 180 / Math.PI;
          function Fe(t2) {
            return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pe + Be;
          }
          function Te(t2) {
            return t2 > Ce ? t2 * t2 * t2 : Pe * (t2 - Be);
          }
          function Le(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function De(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function $e(t2) {
            const e2 = De(t2.r), r2 = De(t2.g), n2 = De(t2.b), i2 = Fe((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / Ie), s2 = Fe((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
            return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Fe((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / Me)), alpha: t2.a };
          }
          function Re(t2) {
            let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
            return e2 = 1 * Te(e2), r2 = Ie * Te(r2), n2 = Me * Te(n2), new Et(Le(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Le(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Le(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
          }
          function Ue(t2, e2, r2) {
            const n2 = e2 - t2;
            return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          const Oe = { forward: $e, reverse: Re, interpolate: function(t2, e2, r2) {
            return { l: Se(t2.l, e2.l, r2), a: Se(t2.a, e2.a, r2), b: Se(t2.b, e2.b, r2), alpha: Se(t2.alpha, e2.alpha, r2) };
          } }, qe = { forward: function(t2) {
            const { l: e2, a: r2, b: n2 } = $e(t2), i2 = Math.atan2(n2, r2) * Ee;
            return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
          }, reverse: function(t2) {
            const e2 = t2.h * Ve, r2 = t2.c;
            return Re({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
          }, interpolate: function(t2, e2, r2) {
            return { h: Ue(t2.h, e2.h, r2), c: Se(t2.c, e2.c, r2), l: Se(t2.l, e2.l, r2), alpha: Se(t2.alpha, e2.alpha, r2) };
          } };
          var je = Object.freeze({ __proto__: null, lab: Oe, hcl: qe });
          class Ne {
            constructor(t2, e2, r2, n2, i2) {
              this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of i2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static interpolationFactor(t2, r2, n2, i2) {
              let s2 = 0;
              if (t2.name === "exponential")
                s2 = Ke(r2, t2.base, n2, i2);
              else if (t2.name === "linear")
                s2 = Ke(r2, 1, n2, i2);
              else if (t2.name === "cubic-bezier") {
                const a2 = t2.controlPoints;
                s2 = new e(a2[0], a2[1], a2[2], a2[3]).solve(Ke(r2, 1, n2, i2));
              }
              return s2;
            }
            static parse(t2, e2) {
              let [r2, n2, i2, ...s2] = t2;
              if (!Array.isArray(n2) || n2.length === 0)
                return e2.error("Expected an interpolation type expression.", 1);
              if (n2[0] === "linear")
                n2 = { name: "linear" };
              else if (n2[0] === "exponential") {
                const t3 = n2[1];
                if (typeof t3 != "number")
                  return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if (n2[0] !== "cubic-bezier")
                  return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                    return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              if (i2 = e2.parse(i2, 2, pt), !i2)
                return null;
              const a2 = [];
              let o2 = null;
              r2 === "interpolate-hcl" || r2 === "interpolate-lab" ? o2 = yt : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
              for (let t3 = 0; t3 < s2.length; t3 += 2) {
                const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if (typeof r3 != "number")
                  return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (a2.length && a2[a2.length - 1][0] >= r3)
                  return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u2 = e2.parse(n3, l2, o2);
                if (!u2)
                  return null;
                o2 = o2 || u2.type, a2.push([r3, u2]);
              }
              return o2.kind === "number" || o2.kind === "color" || o2.kind === "array" && o2.itemType.kind === "number" && typeof o2.N == "number" ? new Ne(o2, r2, n2, i2, a2) : e2.error(`Type ${_t(o2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (e2.length === 1)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r2[0].evaluate(t2);
              const i2 = e2.length;
              if (n2 >= e2[i2 - 1])
                return r2[i2 - 1].evaluate(t2);
              const s2 = Ae(e2, n2), a2 = Ne.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
              return this.operator === "interpolate" ? ze[this.type.kind.toLowerCase()](o2, l2, a2) : this.operator === "interpolate-hcl" ? qe.reverse(qe.interpolate(qe.forward(o2), qe.forward(l2), a2)) : Oe.reverse(Oe.interpolate(Oe.forward(o2), Oe.forward(l2), a2));
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              let t2;
              t2 = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
              const e2 = [this.operator, t2, this.input.serialize()];
              for (let t3 = 0; t3 < this.labels.length; t3++)
                e2.push(this.labels[t3], this.outputs[t3].serialize());
              return e2;
            }
          }
          function Ke(t2, e2, r2, n2) {
            const i2 = n2 - r2, s2 = t2 - r2;
            return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
          }
          class Ze {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expectected at least one argument.");
              let r2 = null;
              const n2 = e2.expectedType;
              n2 && n2.kind !== "value" && (r2 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t3)
                  return null;
                r2 = r2 || t3.type, i2.push(t3);
              }
              const s2 = n2 && i2.some((t3) => kt(n2, t3.type));
              return new Ze(s2 ? gt : r2, i2);
            }
            evaluate(t2) {
              let e2, r2 = null, n2 = 0;
              for (const i2 of this.args)
                if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Dt && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), r2 !== null)
                  break;
              return r2;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["coalesce"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class Ge {
            constructor(t2, e2) {
              this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e2 of this.bindings)
                t2(e2[1]);
              t2(this.result);
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r2 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if (typeof i2 != "string")
                  return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2))
                  return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const s2 = e2.parse(t2[n3 + 1], n3 + 1);
                if (!s2)
                  return null;
                r2.push([i2, s2]);
              }
              const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
              return n2 ? new Ge(r2, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
            serialize() {
              const t2 = ["let"];
              for (const [e2, r2] of this.bindings)
                t2.push(e2, r2.serialize());
              return t2.push(this.result.serialize()), t2;
            }
          }
          class Je {
            constructor(t2, e2, r2) {
              this.type = t2, this.index = e2, this.input = r2;
            }
            static parse(t2, e2) {
              if (t2.length !== 3)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, pt), n2 = e2.parse(t2[2], 2, wt(e2.expectedType || gt));
              return r2 && n2 ? new Je(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e2 < 0)
                throw new jt(`Array index out of bounds: ${e2} < 0.`);
              if (e2 >= r2.length)
                throw new jt(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
              if (e2 !== Math.floor(e2))
                throw new jt(`Array index must be an integer, but found ${e2} instead.`);
              return r2[e2];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["at", this.index.serialize(), this.input.serialize()];
            }
          }
          class Xe {
            constructor(t2, e2) {
              this.type = dt, this.needle = t2, this.haystack = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 3)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, gt), n2 = e2.parse(t2[2], 2, gt);
              return r2 && n2 ? St(r2.type, [dt, ft, pt, ht, gt]) ? new Xe(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r2.type)} instead`) : null;
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!r2)
                return false;
              if (!zt(e2, ["boolean", "string", "number", "null"]))
                throw new jt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Ut(e2))} instead.`);
              if (!zt(r2, ["string", "array"]))
                throw new jt(`Expected second argument to be of type array or string, but found ${_t(Ut(r2))} instead.`);
              return r2.indexOf(e2) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["in", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class Ye {
            constructor(t2, e2, r2) {
              this.type = pt, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, gt), n2 = e2.parse(t2[2], 2, gt);
              if (!r2 || !n2)
                return null;
              if (!St(r2.type, [dt, ft, pt, ht, gt]))
                return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r2.type)} instead`);
              if (t2.length === 4) {
                const i2 = e2.parse(t2[3], 3, pt);
                return i2 ? new Ye(r2, n2, i2) : null;
              }
              return new Ye(r2, n2);
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!zt(e2, ["boolean", "string", "number", "null"]))
                throw new jt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Ut(e2))} instead.`);
              if (!zt(r2, ["string", "array"]))
                throw new jt(`Expected second argument to be of type array or string, but found ${_t(Ut(r2))} instead.`);
              if (this.fromIndex) {
                const n2 = this.fromIndex.evaluate(t2);
                return r2.indexOf(e2, n2);
              }
              return r2.indexOf(e2);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (this.fromIndex != null && this.fromIndex !== void 0) {
                const t2 = this.fromIndex.serialize();
                return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
              }
              return ["index-of", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class He {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
            }
            static parse(t2, e2) {
              if (t2.length < 5)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1)
                return e2.error("Expected an even number of arguments.");
              let r2, n2;
              e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
              const i2 = {}, s2 = [];
              for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
                let o3 = t2[a3];
                const l2 = t2[a3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e2.concat(a3);
                if (o3.length === 0)
                  return u2.error("Expected at least one branch label.");
                for (const t3 of o3) {
                  if (typeof t3 != "number" && typeof t3 != "string")
                    return u2.error("Branch labels must be numbers or strings.");
                  if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                    return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if (typeof t3 == "number" && Math.floor(t3) !== t3)
                    return u2.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u2.checkSubtype(r2, Ut(t3)))
                      return null;
                  } else
                    r2 = Ut(t3);
                  if (i2[String(t3)] !== void 0)
                    return u2.error("Branch labels must be unique.");
                  i2[String(t3)] = s2.length;
                }
                const c2 = e2.parse(l2, a3, n2);
                if (!c2)
                  return null;
                n2 = n2 || c2.type, s2.push(c2);
              }
              const a2 = e2.parse(t2[1], 1, gt);
              if (!a2)
                return null;
              const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
              return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r2, a2.type) ? null : new He(r2, n2, a2, i2, s2, o2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              return (Ut(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
              for (const t3 of e2) {
                const e3 = n2[this.cases[t3]];
                e3 === void 0 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
              }
              const i2 = (t3) => this.inputType.kind === "number" ? Number(t3) : t3;
              for (const [e3, n3] of r2)
                t2.push(n3.length === 1 ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
              return t2.push(this.otherwise.serialize()), t2;
            }
          }
          class We {
            constructor(t2, e2, r2) {
              this.type = t2, this.branches = e2, this.otherwise = r2;
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0)
                return e2.error("Expected an odd number of arguments.");
              let r2;
              e2.expectedType && e2.expectedType.kind !== "value" && (r2 = e2.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const s2 = e2.parse(t2[i3], i3, dt);
                if (!s2)
                  return null;
                const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
                if (!a2)
                  return null;
                n2.push([s2, a2]), r2 = r2 || a2.type;
              }
              const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
              return i2 ? new We(r2, n2, i2) : null;
            }
            evaluate(t2) {
              for (const [e2, r2] of this.branches)
                if (e2.evaluate(t2))
                  return r2.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e2, r2] of this.branches)
                t2(e2), t2(r2);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["case"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class Qe {
            constructor(t2, e2, r2, n2) {
              this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, gt), n2 = e2.parse(t2[2], 2, pt);
              if (!r2 || !n2)
                return null;
              if (!St(r2.type, [wt(gt), ft, gt]))
                return e2.error(`Expected first argument to be of type array or string, but found ${_t(r2.type)} instead`);
              if (t2.length === 4) {
                const i2 = e2.parse(t2[3], 3, pt);
                return i2 ? new Qe(r2.type, r2, n2, i2) : null;
              }
              return new Qe(r2.type, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
              if (!zt(e2, ["string", "array"]))
                throw new jt(`Expected first argument to be of type array or string, but found ${_t(Ut(e2))} instead.`);
              if (this.endIndex) {
                const n2 = this.endIndex.evaluate(t2);
                return e2.slice(r2, n2);
              }
              return e2.slice(r2);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (this.endIndex != null && this.endIndex !== void 0) {
                const t2 = this.endIndex.serialize();
                return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
              }
              return ["slice", this.input.serialize(), this.beginIndex.serialize()];
            }
          }
          function tr(t2, e2) {
            return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
          }
          function er(t2, e2, r2, n2) {
            return n2.compare(e2, r2) === 0;
          }
          function rr(t2, e2, r2) {
            const n2 = t2 !== "==" && t2 !== "!=";
            return class i2 {
              constructor(t3, e3, r3) {
                this.type = dt, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
              }
              static parse(t3, e3) {
                if (t3.length !== 3 && t3.length !== 4)
                  return e3.error("Expected two or three arguments.");
                const r3 = t3[0];
                let s2 = e3.parse(t3[1], 1, gt);
                if (!s2)
                  return null;
                if (!tr(r3, s2.type))
                  return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${_t(s2.type)}'.`);
                let a2 = e3.parse(t3[2], 2, gt);
                if (!a2)
                  return null;
                if (!tr(r3, a2.type))
                  return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${_t(a2.type)}'.`);
                if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
                  return e3.error(`Cannot compare types '${_t(s2.type)}' and '${_t(a2.type)}'.`);
                n2 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new Kt(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new Kt(s2.type, [a2])));
                let o2 = null;
                if (t3.length === 4) {
                  if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                    return e3.error("Cannot use collator to compare non-string types.");
                  if (o2 = e3.parse(t3[3], 3, xt), !o2)
                    return null;
                }
                return new i2(s2, a2, o2);
              }
              evaluate(i3) {
                const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e3 = Ut(s2), r3 = Ut(a2);
                  if (e3.kind !== r3.kind || e3.kind !== "string" && e3.kind !== "number")
                    throw new jt(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = Ut(s2), r3 = Ut(a2);
                  if (t3.kind !== "string" || r3.kind !== "string")
                    return e2(i3, s2, a2);
                }
                return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
              serialize() {
                const e3 = [t2];
                return this.eachChild((t3) => {
                  e3.push(t3.serialize());
                }), e3;
              }
            };
          }
          const nr = rr("==", function(t2, e2, r2) {
            return e2 === r2;
          }, er), ir = rr("!=", function(t2, e2, r2) {
            return e2 !== r2;
          }, function(t2, e2, r2, n2) {
            return !er(0, e2, r2, n2);
          }), sr = rr("<", function(t2, e2, r2) {
            return e2 < r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) < 0;
          }), ar = rr(">", function(t2, e2, r2) {
            return e2 > r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) > 0;
          }), or = rr("<=", function(t2, e2, r2) {
            return e2 <= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) <= 0;
          }), lr = rr(">=", function(t2, e2, r2) {
            return e2 >= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) >= 0;
          });
          class ur {
            constructor(t2, e2, r2, n2, i2) {
              this.type = ft, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
            }
            static parse(t2, e2) {
              if (t2.length !== 3)
                return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, pt);
              if (!r2)
                return null;
              const n2 = t2[2];
              if (typeof n2 != "object" || Array.isArray(n2))
                return e2.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e2.parse(n2.locale, 1, ft), !i2))
                return null;
              let s2 = null;
              if (n2.currency && (s2 = e2.parse(n2.currency, 1, ft), !s2))
                return null;
              let a2 = null;
              if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, pt), !a2))
                return null;
              let o2 = null;
              return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, pt), !o2) ? null : new ur(r2, i2, s2, a2, o2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
            }
          }
          class cr {
            constructor(t2) {
              this.type = pt, this.input = t2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1);
              return r2 ? r2.type.kind !== "array" && r2.type.kind !== "string" && r2.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${_t(r2.type)} instead.`) : new cr(r2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              if (typeof e2 == "string")
                return e2.length;
              if (Array.isArray(e2))
                return e2.length;
              throw new jt(`Expected value to be of type string or array, but found ${_t(Ut(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["length"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const hr = { "==": nr, "!=": ir, ">": ar, "<": sr, ">=": lr, "<=": or, array: Kt, at: Je, boolean: Kt, case: We, coalesce: Ze, collator: Qt, format: Zt, image: Gt, in: Xe, "index-of": Ye, interpolate: Ne, "interpolate-hcl": Ne, "interpolate-lab": Ne, length: cr, let: Ge, literal: qt, match: He, number: Kt, "number-format": ur, object: Kt, slice: Qe, step: ke, string: Kt, "to-boolean": Xt, "to-color": Xt, "to-number": Xt, "to-string": Xt, var: be, within: me };
          function pr(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, a2 = $t(e2, r2, n2, s2);
            if (a2)
              throw new jt(a2);
            return new Et(e2 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
          }
          function fr(t2, e2) {
            return t2 in e2;
          }
          function dr(t2, e2) {
            const r2 = e2[t2];
            return r2 === void 0 ? null : r2;
          }
          function yr(t2) {
            return { type: t2 };
          }
          function mr(t2) {
            return { result: "success", value: t2 };
          }
          function gr(t2) {
            return { result: "error", value: t2 };
          }
          function xr(t2) {
            return t2["property-type"] === "data-driven" || t2["property-type"] === "cross-faded-data-driven";
          }
          function vr(t2) {
            return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
          }
          function br(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function wr(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
          }
          function _r(t2) {
            return typeof t2 == "object" && t2 !== null && !Array.isArray(t2);
          }
          function Ar(t2) {
            return t2;
          }
          function kr(t2, e2) {
            const r2 = e2.type === "color", n2 = t2.stops && typeof t2.stops[0][0] == "object", i2 = n2 || !(n2 || t2.property !== void 0), s2 = t2.type || (br(e2) ? "exponential" : "interval");
            if (r2 && ((t2 = at({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Et.parse(t3[1])])), t2.default = Et.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && t2.colorSpace !== "rgb" && !je[t2.colorSpace])
              throw new Error(`Unknown color space: ${t2.colorSpace}`);
            let a2, o2, l2;
            if (s2 === "exponential")
              a2 = Mr;
            else if (s2 === "interval")
              a2 = Ir;
            else if (s2 === "categorical") {
              a2 = zr, o2 = /* @__PURE__ */ Object.create(null);
              for (const e3 of t2.stops)
                o2[e3[0]] = e3[1];
              l2 = typeof t2.stops[0][0];
            } else {
              if (s2 !== "identity")
                throw new Error(`Unknown function type "${s2}"`);
              a2 = Br;
            }
            if (n2) {
              const r3 = {}, n3 = [];
              for (let e3 = 0; e3 < t2.stops.length; e3++) {
                const i4 = t2.stops[e3], s4 = i4[0].zoom;
                r3[s4] === void 0 && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3)
                i3.push([r3[t3].zoom, kr(r3[t3], e2)]);
              const s3 = { name: "linear" };
              return { kind: "composite", interpolationType: s3, interpolationFactor: Ne.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Mr({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
            }
            if (i2) {
              const r3 = s2 === "exponential" ? { name: "exponential", base: t2.base !== void 0 ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: Ne.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l2) };
            }
            return { kind: "source", evaluate(r3, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return i3 === void 0 ? Sr(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
            } };
          }
          function Sr(t2, e2, r2) {
            return t2 !== void 0 ? t2 : e2 !== void 0 ? e2 : r2 !== void 0 ? r2 : void 0;
          }
          function zr(t2, e2, r2, n2, i2) {
            return Sr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
          }
          function Ir(t2, e2, r2) {
            if (wr(r2) !== "number")
              return Sr(t2.default, e2.default);
            const n2 = t2.stops.length;
            if (n2 === 1)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0])
              return t2.stops[n2 - 1][1];
            const i2 = Ae(t2.stops.map((t3) => t3[0]), r2);
            return t2.stops[i2][1];
          }
          function Mr(t2, e2, r2) {
            const n2 = t2.base !== void 0 ? t2.base : 1;
            if (wr(r2) !== "number")
              return Sr(t2.default, e2.default);
            const i2 = t2.stops.length;
            if (i2 === 1)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0])
              return t2.stops[i2 - 1][1];
            const s2 = Ae(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
              const i3 = n3 - r3, s3 = t3 - r3;
              return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
            }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
            let u2 = ze[e2.type] || Ar;
            if (t2.colorSpace && t2.colorSpace !== "rgb") {
              const e3 = je[t2.colorSpace];
              u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
            }
            return typeof o2.evaluate == "function" ? { evaluate(...t3) {
              const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
              if (e3 !== void 0 && r3 !== void 0)
                return u2(e3, r3, a2);
            } } : u2(o2, l2, a2);
          }
          function Br(t2, e2, r2) {
            return e2.type === "color" ? r2 = Et.parse(r2) : e2.type === "formatted" ? r2 = Lt.fromString(r2.toString()) : e2.type === "resolvedImage" ? r2 = Dt.fromString(r2.toString()) : wr(r2) === e2.type || e2.type === "enum" && e2.values[r2] || (r2 = void 0), Sr(r2, t2.default, e2.default);
          }
          Wt.register(hr, { error: [{ kind: "error" }, [ft], (t2, [e2]) => {
            throw new jt(e2.evaluate(t2));
          }], typeof: [ft, [gt], (t2, [e2]) => _t(Ut(e2.evaluate(t2)))], "to-rgba": [wt(pt, 4), [yt], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [yt, [pt, pt, pt], pr], rgba: [yt, [pt, pt, pt, pt], pr], has: { type: dt, overloads: [[[ft], (t2, [e2]) => fr(e2.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e2, r2]) => fr(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: gt, overloads: [[[ft], (t2, [e2]) => dr(e2.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e2, r2]) => dr(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [gt, [ft], (t2, [e2]) => dr(e2.evaluate(t2), t2.featureState || {})], properties: [mt, [], (t2) => t2.properties()], "geometry-type": [ft, [], (t2) => t2.geometryType()], id: [gt, [], (t2) => t2.id()], zoom: [pt, [], (t2) => t2.globals.zoom], "heatmap-density": [pt, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [pt, [], (t2) => t2.globals.lineProgress || 0], accumulated: [gt, [], (t2) => t2.globals.accumulated === void 0 ? null : t2.globals.accumulated], "+": [pt, yr(pt), (t2, e2) => {
            let r2 = 0;
            for (const n2 of e2)
              r2 += n2.evaluate(t2);
            return r2;
          }], "*": [pt, yr(pt), (t2, e2) => {
            let r2 = 1;
            for (const n2 of e2)
              r2 *= n2.evaluate(t2);
            return r2;
          }], "-": { type: pt, overloads: [[[pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[pt], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [pt, [pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [pt, [pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [pt, [pt], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [pt, [pt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [pt, [pt], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [pt, [pt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [pt, [pt], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [pt, [pt], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [pt, [pt], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [pt, [pt], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [pt, [pt], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [pt, [pt], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [pt, yr(pt), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [pt, yr(pt), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [pt, [pt], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [pt, [pt], (t2, [e2]) => {
            const r2 = e2.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [pt, [pt], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [pt, [pt], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [dt, [ft, gt], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [dt, [gt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [dt, [ft], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [dt, [ft, gt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [dt, [gt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }], "filter->": [dt, [ft, gt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [dt, [gt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }], "filter-<=": [dt, [ft, gt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [dt, [gt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }], "filter->=": [dt, [ft, gt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [dt, [gt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }], "filter-has": [dt, [gt], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [dt, [], (t2) => t2.id() !== null && t2.id() !== void 0], "filter-type-in": [dt, [wt(ft)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [dt, [wt(gt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [dt, [ft, wt(gt)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [dt, [ft, wt(gt)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
            for (; r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e3[i2] === t3)
                return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [yr(dt), (t2, e2) => {
            for (const r2 of e2)
              if (!r2.evaluate(t2))
                return false;
            return true;
          }]] }, any: { type: dt, overloads: [[[dt, dt], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [yr(dt), (t2, e2) => {
            for (const r2 of e2)
              if (r2.evaluate(t2))
                return true;
            return false;
          }]] }, "!": [dt, [dt], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [dt, [ft], (t2, [e2]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2.evaluate(t2));
          }], upcase: [ft, [ft], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ft, [ft], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ft, yr(gt), (t2, e2) => e2.map((e3) => Ot(e3.evaluate(t2))).join("")], "resolved-locale": [ft, [xt], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
          class Cr {
            constructor(t2, e2) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new Ht(), this._defaultValue = e2 ? function(t3) {
                return t3.type === "color" && _r(t3.default) ? new Et(0, 0, 0, 0) : t3.type === "color" ? Et.parse(t3.default) || null : t3.default === void 0 ? null : t3.default;
              }(e2) : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (t3 == null || typeof t3 == "number" && t3 != t3)
                  return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues))
                  throw new jt(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, typeof console != "undefined" && console.warn(t3.message)), this._defaultValue;
              }
            }
          }
          function Pr(t2) {
            return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in hr;
          }
          function Vr(t2, e2) {
            const r2 = new we(hr, [], e2 ? function(t3) {
              const e3 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, resolvedImage: bt };
              return t3.type === "array" ? wt(e3[t3.value] || gt, t3.length) : e3[t3.type];
            }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : void 0);
            return n2 ? mr(new Cr(n2, e2)) : gr(r2.errors);
          }
          class Er {
            constructor(t2, e2) {
              this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !xe(e2.expression);
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
          }
          class Fr {
            constructor(t2, e2, r2, n2) {
              this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !xe(e2.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
            interpolationFactor(t2, e2, r2) {
              return this.interpolationType ? Ne.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
            }
          }
          function Tr(t2, e2) {
            const r2 = Vr(t2, e2);
            if (r2.result === "error")
              return r2;
            const n2 = r2.value.expression, i2 = ge(n2);
            if (!i2 && !xr(e2))
              return gr([new ut("", "data expressions not supported")]);
            const s2 = ve(n2, ["zoom"]);
            if (!s2 && !vr(e2))
              return gr([new ut("", "zoom expressions not supported")]);
            const a2 = Dr(n2);
            return a2 || s2 ? a2 instanceof ut ? gr([a2]) : a2 instanceof Ne && !br(e2) ? gr([new ut("", '"interpolate" expressions cannot be used with this property')]) : mr(a2 ? new Fr(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof Ne ? a2.interpolation : void 0) : new Er(i2 ? "constant" : "source", r2.value)) : gr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class Lr {
            constructor(t2, e2) {
              this._parameters = t2, this._specification = e2, at(this, kr(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new Lr(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function Dr(t2) {
            let e2 = null;
            if (t2 instanceof Ge)
              e2 = Dr(t2.result);
            else if (t2 instanceof Ze) {
              for (const r2 of t2.args)
                if (e2 = Dr(r2), e2)
                  break;
            } else
              (t2 instanceof ke || t2 instanceof Ne) && t2.input instanceof Wt && t2.input.name === "zoom" && (e2 = t2);
            return e2 instanceof ut || t2.eachChild((t3) => {
              const r2 = Dr(t3);
              r2 instanceof ut ? e2 = r2 : !e2 && r2 ? e2 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e2;
          }
          function $r(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
            let o2 = [];
            const l2 = wr(r2);
            if (l2 !== "object")
              return [new it(e2, r2, `object expected, ${l2} found`)];
            for (const t3 in r2) {
              const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
              let c2;
              if (i2[l3])
                c2 = i2[l3];
              else if (n2[l3])
                c2 = fn2;
              else if (i2["*"])
                c2 = i2["*"];
              else {
                if (!n2["*"]) {
                  o2.push(new it(e2, r2[t3], `unknown property "${t3}"`));
                  continue;
                }
                c2 = fn2;
              }
              o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r2, objectKey: t3 }, r2));
            }
            for (const t3 in n2)
              i2[t3] || n2[t3].required && n2[t3].default === void 0 && r2[t3] === void 0 && o2.push(new it(e2, r2, `missing required property "${t3}"`));
            return o2;
          }
          function Rr(t2) {
            const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || fn2;
            if (wr(e2) !== "array")
              return [new it(s2, e2, `array expected, ${wr(e2)} found`)];
            if (r2.length && e2.length !== r2.length)
              return [new it(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
            if (r2["min-length"] && e2.length < r2["min-length"])
              return [new it(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
            let o2 = { type: r2.value, values: r2.values };
            i2.$version < 7 && (o2.function = r2.function), wr(r2.value) === "object" && (o2 = r2.value);
            let l2 = [];
            for (let t3 = 0; t3 < e2.length; t3++)
              l2 = l2.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
            return l2;
          }
          function Ur(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
            let i2 = wr(r2);
            return i2 === "number" && r2 != r2 && (i2 = "NaN"), i2 !== "number" ? [new it(e2, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new it(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new it(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
          }
          function Or(t2) {
            const e2 = t2.valueSpec, r2 = ot(t2.value.type);
            let n2, i2, s2, a2 = {};
            const o2 = r2 !== "categorical" && t2.value.property === void 0, l2 = !o2, u2 = wr(t2.value.stops) === "array" && wr(t2.value.stops[0]) === "array" && wr(t2.value.stops[0][0]) === "object", c2 = $r({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if (r2 === "identity")
                return [new it(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let e3 = [];
              const n3 = t3.value;
              return e3 = e3.concat(Rr({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), wr(n3) === "array" && n3.length === 0 && e3.push(new it(t3.key, n3, "array must have at least one stop")), e3;
            }, default: function(t3) {
              return fn2({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
            } } });
            return r2 === "identity" && o2 && c2.push(new it(t2.key, t2.value, 'missing required property "property"')), r2 === "identity" || t2.value.stops || c2.push(new it(t2.key, t2.value, 'missing required property "stops"')), r2 === "exponential" && t2.valueSpec.expression && !br(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !xr(t2.valueSpec) ? c2.push(new it(t2.key, t2.value, "property functions not supported")) : o2 && !vr(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "zoom functions not supported"))), r2 !== "categorical" && !u2 || t2.value.property !== void 0 || c2.push(new it(t2.key, t2.value, '"property" property is required')), c2;
            function h2(t3) {
              let r3 = [];
              const n3 = t3.value, o3 = t3.key;
              if (wr(n3) !== "array")
                return [new it(o3, n3, `array expected, ${wr(n3)} found`)];
              if (n3.length !== 2)
                return [new it(o3, n3, `array length 2 expected, length ${n3.length} found`)];
              if (u2) {
                if (wr(n3[0]) !== "object")
                  return [new it(o3, n3, `object expected, ${wr(n3[0])} found`)];
                if (n3[0].zoom === void 0)
                  return [new it(o3, n3, "object stop key must have zoom")];
                if (n3[0].value === void 0)
                  return [new it(o3, n3, "object stop key must have value")];
                if (s2 && s2 > ot(n3[0].zoom))
                  return [new it(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
                ot(n3[0].zoom) !== s2 && (s2 = ot(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat($r({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Ur, value: p2 } }));
              } else
                r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
              return Pr(lt(n3[1])) ? r3.concat([new it(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(fn2({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function p2(t3, s3) {
              const o3 = wr(t3.value), l3 = ot(t3.value), u3 = t3.value !== null ? t3.value : s3;
              if (n2) {
                if (o3 !== n2)
                  return [new it(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
              } else
                n2 = o3;
              if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
                return [new it(t3.key, u3, "stop domain value must be a number, string, or boolean")];
              if (o3 !== "number" && r2 !== "categorical") {
                let n3 = `number expected, ${o3} found`;
                return xr(e2) && r2 === void 0 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it(t3.key, u3, n3)];
              }
              return r2 !== "categorical" || o3 !== "number" || isFinite(l3) && Math.floor(l3) === l3 ? r2 !== "categorical" && o3 === "number" && i2 !== void 0 && l3 < i2 ? [new it(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, r2 === "categorical" && l3 in a2 ? [new it(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new it(t3.key, u3, `integer expected, found ${l3}`)];
            }
          }
          function qr(t2) {
            const e2 = (t2.expressionContext === "property" ? Tr : Vr)(lt(t2.value), t2.valueSpec);
            if (e2.result === "error")
              return e2.value.map((e3) => new it(`${t2.key}${e3.key}`, t2.value, e3.message));
            const r2 = e2.value.expression || e2.value._styleExpression.expression;
            if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r2.outputDefined())
              return [new it(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if (t2.expressionContext === "property" && t2.propertyType === "layout" && !xe(r2))
              return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if (t2.expressionContext === "filter" && !xe(r2))
              return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
            if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
              if (!ve(r2, ["zoom", "feature-state"]))
                return [new it(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if (t2.expressionContext === "cluster-initial" && !ge(r2))
                return [new it(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function jr(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
            return Array.isArray(n2.values) ? n2.values.indexOf(ot(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : Object.keys(n2.values).indexOf(ot(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
          }
          function Nr(t2) {
            if (t2 === true || t2 === false)
              return true;
            if (!Array.isArray(t2) || t2.length === 0)
              return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
              case "in":
                return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e2 of t2.slice(1))
                  if (!Nr(e2) && typeof e2 != "boolean")
                    return false;
                return true;
              default:
                return true;
            }
          }
          const Kr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function Zr(t2) {
            if (t2 == null)
              return { filter: () => true, needGeometry: false };
            Nr(t2) || (t2 = Xr(t2));
            const e2 = Vr(t2, Kr);
            if (e2.result === "error")
              throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
            return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: Jr(t2) };
          }
          function Gr(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function Jr(t2) {
            if (!Array.isArray(t2))
              return false;
            if (t2[0] === "within")
              return true;
            for (let e2 = 1; e2 < t2.length; e2++)
              if (Jr(t2[e2]))
                return true;
            return false;
          }
          function Xr(t2) {
            if (!t2)
              return true;
            const e2 = t2[0];
            return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? Yr(t2[1], t2[2], "==") : e2 === "!=" ? Qr(Yr(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? Yr(t2[1], t2[2], e2) : e2 === "any" ? (r2 = t2.slice(1), ["any"].concat(r2.map(Xr))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(Xr)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(Xr).map(Qr)) : e2 === "in" ? Hr(t2[1], t2.slice(2)) : e2 === "!in" ? Qr(Hr(t2[1], t2.slice(2))) : e2 === "has" ? Wr(t2[1]) : e2 === "!has" ? Qr(Wr(t2[1])) : e2 !== "within" || t2;
            var r2;
          }
          function Yr(t2, e2, r2) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r2}`, e2];
              case "$id":
                return [`filter-id-${r2}`, e2];
              default:
                return [`filter-${r2}`, t2, e2];
            }
          }
          function Hr(t2, e2) {
            if (e2.length === 0)
              return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Gr)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function Wr(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function Qr(t2) {
            return ["!", t2];
          }
          function tn(t2) {
            return Nr(lt(t2.value)) ? qr(at({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : en(t2);
          }
          function en(t2) {
            const e2 = t2.value, r2 = t2.key;
            if (wr(e2) !== "array")
              return [new it(r2, e2, `array expected, ${wr(e2)} found`)];
            const n2 = t2.styleSpec;
            let i2, s2 = [];
            if (e2.length < 1)
              return [new it(r2, e2, "filter array must have at least 1 element")];
            switch (s2 = s2.concat(jr({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), ot(e2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e2.length >= 2 && ot(e2[1]) === "$type" && s2.push(new it(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
              case "==":
              case "!=":
                e2.length !== 3 && s2.push(new it(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e2.length >= 2 && (i2 = wr(e2[1]), i2 !== "string" && s2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
                for (let a2 = 2; a2 < e2.length; a2++)
                  i2 = wr(e2[a2]), ot(e2[1]) === "$type" ? s2 = s2.concat(jr({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new it(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n3 = 1; n3 < e2.length; n3++)
                  s2 = s2.concat(en({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                i2 = wr(e2[1]), e2.length !== 2 ? s2.push(new it(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
                break;
              case "within":
                i2 = wr(e2[1]), e2.length !== 2 ? s2.push(new it(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "object" && s2.push(new it(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
            }
            return s2;
          }
          function rn(t2, e2) {
            const r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
            if (!o2)
              return [];
            const l2 = a2.match(/^(.*)-transition$/);
            if (e2 === "paint" && l2 && o2[l2[1]] && o2[l2[1]].transition)
              return fn2({ key: r2, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
            const u2 = t2.valueSpec || o2[a2];
            if (!u2)
              return [new it(r2, s2, `unknown property "${a2}"`)];
            let c2;
            if (wr(s2) === "string" && xr(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2)))
              return [new it(r2, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
            const h2 = [];
            return t2.layerType === "symbol" && (a2 === "text-field" && n2 && !n2.glyphs && h2.push(new it(r2, s2, 'use of "text-field" requires a style "glyphs" property')), a2 === "text-font" && _r(lt(s2)) && ot(s2.type) === "identity" && h2.push(new it(r2, s2, '"text-font" does not support identity functions'))), h2.concat(fn2({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
          }
          function nn(t2) {
            return rn(t2, "paint");
          }
          function sn(t2) {
            return rn(t2, "layout");
          }
          function an(t2) {
            let e2 = [];
            const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
            r2.type || r2.ref || e2.push(new it(n2, r2, 'either "type" or "ref" is required'));
            let a2 = ot(r2.type);
            const o2 = ot(r2.ref);
            if (r2.id) {
              const s3 = ot(r2.id);
              for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
                const t3 = i2.layers[a3];
                ot(t3.id) === s3 && e2.push(new it(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in r2) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in r2 && e2.push(new it(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
              }), i2.layers.forEach((e3) => {
                ot(e3.id) === o2 && (t3 = e3);
              }), t3 ? t3.ref ? e2.push(new it(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = ot(t3.type) : e2.push(new it(n2, r2.ref, `ref layer "${o2}" not found`));
            } else if (a2 !== "background")
              if (r2.source) {
                const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && ot(t3.type);
                t3 ? s3 === "vector" && a2 === "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : s3 !== "vector" || r2["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new it(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r2.paint || !r2.paint["line-gradient"] || s3 === "geojson" && t3.lineMetrics || e2.push(new it(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new it(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new it(n2, r2.source, `source "${r2.source}" not found`));
              } else
                e2.push(new it(n2, r2, 'missing required property "source"'));
            return e2 = e2.concat($r({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => fn2({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: tn, layout: (t3) => $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => sn(at({ layerType: a2 }, t4)) } }), paint: (t3) => $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => nn(at({ layerType: a2 }, t4)) } }) } })), e2;
          }
          function on(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = wr(e2);
            return n2 !== "string" ? [new it(r2, e2, `string expected, ${n2} found`)] : [];
          }
          const ln = { promoteId: function({ key: t2, value: e2 }) {
            if (wr(e2) === "string")
              return on({ key: t2, value: e2 });
            {
              const r2 = [];
              for (const n2 in e2)
                r2.push(...on({ key: `${t2}.${n2}`, value: e2[n2] }));
              return r2;
            }
          } };
          function un(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
            if (!e2.type)
              return [new it(r2, e2, '"type" is required')];
            const s2 = ot(e2.type);
            let a2;
            switch (s2) {
              case "vector":
              case "raster":
              case "raster-dem":
                return a2 = $r({ key: r2, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ln }), a2;
              case "geojson":
                if (a2 = $r({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: ln }), e2.cluster)
                  for (const t3 in e2.clusterProperties) {
                    const [n3, i3] = e2.clusterProperties[t3], s3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                    a2.push(...qr({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...qr({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
                  }
                return a2;
              case "video":
                return $r({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
              case "image":
                return $r({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
              case "canvas":
                return [new it(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return jr({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
            }
          }
          function cn(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
            let s2 = [];
            const a2 = wr(e2);
            if (e2 === void 0)
              return s2;
            if (a2 !== "object")
              return s2 = s2.concat([new it("light", e2, `object expected, ${a2} found`)]), s2;
            for (const t3 in e2) {
              const a3 = t3.match(/^(.*)-transition$/);
              s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? fn2({ key: t3, value: e2[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? fn2({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            return s2;
          }
          function hn(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style;
            let s2 = [];
            const a2 = wr(e2);
            if (e2 === void 0)
              return s2;
            if (a2 !== "object")
              return s2 = s2.concat([new it("terrain", e2, `object expected, ${a2} found`)]), s2;
            for (const t3 in e2)
              s2 = s2.concat(n2[t3] ? fn2({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e2[t3], `unknown property "${t3}"`)]);
            return s2;
          }
          const pn = { "*": () => [], array: Rr, boolean: function(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = wr(e2);
            return n2 !== "boolean" ? [new it(r2, e2, `boolean expected, ${n2} found`)] : [];
          }, number: Ur, color: function(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = wr(r2);
            return n2 !== "string" ? [new it(e2, r2, `color expected, ${n2} found`)] : It(r2) === null ? [new it(e2, r2, `color expected, "${r2}" found`)] : [];
          }, constants: st, enum: jr, filter: tn, function: Or, layer: an, object: $r, source: un, light: cn, terrain: hn, string: on, formatted: function(t2) {
            return on(t2).length === 0 ? [] : qr(t2);
          }, resolvedImage: function(t2) {
            return on(t2).length === 0 ? [] : qr(t2);
          } };
          function fn2(t2) {
            const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
            return r2.expression && _r(ot(e2)) ? Or(t2) : r2.expression && Pr(lt(e2)) ? qr(t2) : r2.type && pn[r2.type] ? pn[r2.type](t2) : $r(at({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
          }
          function dn(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = on(t2);
            return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
          }
          function yn(t2, e2 = nt) {
            let r2 = [];
            return r2 = r2.concat(fn2({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: dn, "*": () => [] } })), t2.constants && (r2 = r2.concat(st({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), mn(r2);
          }
          function mn(t2) {
            return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
          }
          function gn(t2) {
            return function(...e2) {
              return mn(t2.apply(this, e2));
            };
          }
          yn.source = gn(un), yn.light = gn(cn), yn.terrain = gn(hn), yn.layer = gn(an), yn.filter = gn(tn), yn.paintProperty = gn(nn), yn.layoutProperty = gn(sn);
          const xn = yn, vn = xn.light, bn = xn.paintProperty, wn = xn.layoutProperty;
          function _n(t2, e2) {
            let r2 = false;
            if (e2 && e2.length)
              for (const n2 of e2)
                t2.fire(new et(new Error(n2.message))), r2 = true;
            return r2;
          }
          class An {
            constructor(t2, e2, r2) {
              const n2 = this.cells = [];
              if (t2 instanceof ArrayBuffer) {
                this.arrayBuffer = t2;
                const i3 = new Int32Array(this.arrayBuffer);
                t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
                for (let t3 = 0; t3 < this.d * this.d; t3++) {
                  const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                  n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
                }
                const s2 = i3[3 + n2.length + 1];
                this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
              } else {
                this.d = e2 + 2 * r2;
                for (let t3 = 0; t3 < this.d * this.d; t3++)
                  n2.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
              const i2 = r2 / e2 * t2;
              this.min = -i2, this.max = t2 + i2;
            }
            insert(t2, e2, r2, n2, i2) {
              this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
            }
            _insertReadonly() {
              throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t2, e2, r2, n2, i2, s2) {
              this.cells[i2].push(s2);
            }
            query(t2, e2, r2, n2, i2) {
              const s2 = this.min, a2 = this.max;
              if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
                return Array.prototype.slice.call(this.keys);
              {
                const s3 = [];
                return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
              }
            }
            _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this.cells[i2];
              if (l2 !== null) {
                const i3 = this.keys, u2 = this.bboxes;
                for (let c2 = 0; c2 < l2.length; c2++) {
                  const h2 = l2[c2];
                  if (a2[h2] === void 0) {
                    const l3 = 4 * h2;
                    (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
                  }
                }
              }
            }
            _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
              for (let p2 = l2; p2 <= c2; p2++)
                for (let l3 = u2; l3 <= h2; l3++) {
                  const u3 = this.d * l3 + p2;
                  if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2))
                    return;
                }
            }
            _convertFromCellCoord(t2) {
              return (t2 - this.padding) / this.scale;
            }
            _convertToCellCoord(t2) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
            }
            toArrayBuffer() {
              if (this.arrayBuffer)
                return this.arrayBuffer;
              const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
              let r2 = 0;
              for (let t3 = 0; t3 < this.cells.length; t3++)
                r2 += this.cells[t3].length;
              const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
              n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
              let i2 = e2;
              for (let e3 = 0; e3 < t2.length; e3++) {
                const r3 = t2[e3];
                n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
              }
              return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
            }
            static serialize(t2, e2) {
              const r2 = t2.toArrayBuffer();
              return e2 && e2.push(r2), { buffer: r2 };
            }
            static deserialize(t2) {
              return new An(t2.buffer);
            }
          }
          const kn = {};
          function Sn(t2, e2, r2 = {}) {
            Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), kn[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
          }
          Sn("Object", Object), Sn("TransferableGridIndex", An), Sn("Color", Et), Sn("Error", Error), Sn("AJAXError", q), Sn("ResolvedImage", Dt), Sn("StylePropertyFunction", Lr), Sn("StyleExpression", Cr, { omit: ["_evaluator"] }), Sn("ZoomDependentExpression", Fr), Sn("ZoomConstantExpression", Er), Sn("CompoundExpression", Wt, { omit: ["_evaluate"] });
          for (const t2 in hr)
            hr[t2]._classRegistryKey || Sn(`Expression_${t2}`, hr[t2]);
          function zn(t2) {
            return t2 && typeof ArrayBuffer != "undefined" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
          }
          function In(t2, e2) {
            if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob)
              return t2;
            if (zn(t2))
              return e2 && e2.push(t2), t2;
            if (A(t2))
              return e2 && e2.push(t2), t2;
            if (ArrayBuffer.isView(t2)) {
              const r2 = t2;
              return e2 && e2.push(r2.buffer), r2;
            }
            if (t2 instanceof ImageData)
              return e2 && e2.push(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const r2 = [];
              for (const n2 of t2)
                r2.push(In(n2, e2));
              return r2;
            }
            if (typeof t2 == "object") {
              const r2 = t2.constructor, n2 = r2._classRegistryKey;
              if (!n2)
                throw new Error("can't serialize object of unregistered class");
              const i2 = r2.serialize ? r2.serialize(t2, e2) : {};
              if (!r2.serialize) {
                for (const r3 in t2) {
                  if (!t2.hasOwnProperty(r3))
                    continue;
                  if (kn[n2].omit.indexOf(r3) >= 0)
                    continue;
                  const s2 = t2[r3];
                  i2[r3] = kn[n2].shallow.indexOf(r3) >= 0 ? s2 : In(s2, e2);
                }
                t2 instanceof Error && (i2.message = t2.message);
              }
              if (i2.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return n2 !== "Object" && (i2.$name = n2), i2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function Mn(t2) {
            if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || zn(t2) || A(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
              return t2;
            if (Array.isArray(t2))
              return t2.map(Mn);
            if (typeof t2 == "object") {
              const e2 = t2.$name || "Object";
              if (!kn[e2])
                throw new Error(`can't deserialize unregistered class ${e2}`);
              const { klass: r2 } = kn[e2];
              if (!r2)
                throw new Error(`can't deserialize unregistered class ${e2}`);
              if (r2.deserialize)
                return r2.deserialize(t2);
              const n2 = Object.create(r2.prototype);
              for (const r3 of Object.keys(t2)) {
                if (r3 === "$name")
                  continue;
                const i2 = t2[r3];
                n2[r3] = kn[e2].shallow.indexOf(r3) >= 0 ? i2 : Mn(i2);
              }
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          class Bn {
            constructor() {
              this.first = true;
            }
            update(t2, e2) {
              const r2 = Math.floor(t2);
              return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
            }
          }
          const Cn = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
          function Pn(t2) {
            for (const e2 of t2)
              if (Fn(e2.charCodeAt(0)))
                return true;
            return false;
          }
          function Vn(t2) {
            for (const e2 of t2)
              if (!En(e2.charCodeAt(0)))
                return false;
            return true;
          }
          function En(t2) {
            return !(Cn.Arabic(t2) || Cn["Arabic Supplement"](t2) || Cn["Arabic Extended-A"](t2) || Cn["Arabic Presentation Forms-A"](t2) || Cn["Arabic Presentation Forms-B"](t2));
          }
          function Fn(t2) {
            return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(Cn["Bopomofo Extended"](t2) || Cn.Bopomofo(t2) || Cn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Cn["CJK Compatibility Ideographs"](t2) || Cn["CJK Compatibility"](t2) || Cn["CJK Radicals Supplement"](t2) || Cn["CJK Strokes"](t2) || !(!Cn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || Cn["CJK Unified Ideographs Extension A"](t2) || Cn["CJK Unified Ideographs"](t2) || Cn["Enclosed CJK Letters and Months"](t2) || Cn["Hangul Compatibility Jamo"](t2) || Cn["Hangul Jamo Extended-A"](t2) || Cn["Hangul Jamo Extended-B"](t2) || Cn["Hangul Jamo"](t2) || Cn["Hangul Syllables"](t2) || Cn.Hiragana(t2) || Cn["Ideographic Description Characters"](t2) || Cn.Kanbun(t2) || Cn["Kangxi Radicals"](t2) || Cn["Katakana Phonetic Extensions"](t2) || Cn.Katakana(t2) && t2 !== 12540 || !(!Cn["Halfwidth and Fullwidth Forms"](t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!Cn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Cn["Unified Canadian Aboriginal Syllabics"](t2) || Cn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Cn["Vertical Forms"](t2) || Cn["Yijing Hexagram Symbols"](t2) || Cn["Yi Syllables"](t2) || Cn["Yi Radicals"](t2))));
          }
          function Tn(t2) {
            return !(Fn(t2) || function(t3) {
              return !!(Cn["Latin-1 Supplement"](t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || Cn["General Punctuation"](t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || Cn["Letterlike Symbols"](t3) || Cn["Number Forms"](t3) || Cn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Cn["Control Pictures"](t3) && t3 !== 9251 || Cn["Optical Character Recognition"](t3) || Cn["Enclosed Alphanumerics"](t3) || Cn["Geometric Shapes"](t3) || Cn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Cn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Cn["CJK Symbols and Punctuation"](t3) || Cn.Katakana(t3) || Cn["Private Use Area"](t3) || Cn["CJK Compatibility Forms"](t3) || Cn["Small Form Variants"](t3) || Cn["Halfwidth and Fullwidth Forms"](t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
            }(t2));
          }
          function Ln(t2) {
            return t2 >= 1424 && t2 <= 2303 || Cn["Arabic Presentation Forms-A"](t2) || Cn["Arabic Presentation Forms-B"](t2);
          }
          function Dn(t2, e2) {
            return !(!e2 && Ln(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Cn.Khmer(t2));
          }
          function $n(t2) {
            for (const e2 of t2)
              if (Ln(e2.charCodeAt(0)))
                return true;
            return false;
          }
          const Rn = "deferred", Un = "loading", On = "loaded";
          let qn = null, jn = "unavailable", Nn = null;
          const Kn = function(t2) {
            t2 && typeof t2 == "string" && t2.indexOf("NetworkError") > -1 && (jn = "error"), qn && qn(t2);
          };
          function Zn() {
            Gn.fire(new tt("pluginStateChange", { pluginStatus: jn, pluginURL: Nn }));
          }
          const Gn = new rt(), Jn = function() {
            return jn;
          }, Xn = function() {
            if (jn !== Rn || !Nn)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            jn = Un, Zn(), Nn && Z({ url: Nn }, (t2) => {
              t2 ? Kn(t2) : (jn = On, Zn());
            });
          }, Yn = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => jn === On || Yn.applyArabicShaping != null, isLoading: () => jn === Un, setState(t2) {
            jn = t2.pluginStatus, Nn = t2.pluginURL;
          }, isParsed: () => Yn.applyArabicShaping != null && Yn.processBidirectionalText != null && Yn.processStyledBidirectionalText != null, getPluginURL: () => Nn };
          class Hn {
            constructor(t2, e2) {
              this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Bn(), this.transition = {});
            }
            isSupportedScript(t2) {
              return function(t3, e2) {
                for (const r2 of t3)
                  if (!Dn(r2.charCodeAt(0), e2))
                    return false;
                return true;
              }(t2, Yn.isLoaded());
            }
            crossFadingFactor() {
              return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
              return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
            }
          }
          class Wn {
            constructor(t2, e2) {
              this.property = t2, this.value = e2, this.expression = function(t3, e3) {
                if (_r(t3))
                  return new Lr(t3, e3);
                if (Pr(t3)) {
                  const r2 = Tr(t3, e3);
                  if (r2.result === "error")
                    throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return r2.value;
                }
                {
                  let r2 = t3;
                  return typeof t3 == "string" && e3.type === "color" && (r2 = Et.parse(t3)), { kind: "constant", evaluate: () => r2 };
                }
              }(e2 === void 0 ? t2.specification.default : e2, t2.specification);
            }
            isDataDriven() {
              return this.expression.kind === "source" || this.expression.kind === "composite";
            }
            possiblyEvaluate(t2, e2, r2) {
              return this.property.possiblyEvaluate(this, t2, e2, r2);
            }
          }
          class Qn {
            constructor(t2) {
              this.property = t2, this.value = new Wn(t2, void 0);
            }
            transitioned(t2, e2) {
              return new ei(this.property, this.value, e2, o({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new ei(this.property, this.value, null, {}, 0);
            }
          }
          class ti {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
            }
            getValue(t2) {
              return p(this._values[t2].value.value);
            }
            setValue(t2, e2) {
              Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Qn(this._values[t2].property)), this._values[t2].value = new Wn(this._values[t2].property, e2 === null ? void 0 : p(e2));
            }
            getTransition(t2) {
              return p(this._values[t2].transition);
            }
            setTransition(t2, e2) {
              Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Qn(this._values[t2].property)), this._values[t2].transition = p(e2) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                r2 !== void 0 && (t2[e2] = r2);
                const n2 = this.getTransition(e2);
                n2 !== void 0 && (t2[`${e2}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e2) {
              const r2 = new ri(this._properties);
              for (const n2 of Object.keys(this._values))
                r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
              return r2;
            }
            untransitioned() {
              const t2 = new ri(this._properties);
              for (const e2 of Object.keys(this._values))
                t2._values[e2] = this._values[e2].untransitioned();
              return t2;
            }
          }
          class ei {
            constructor(t2, e2, r2, n2, i2) {
              this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
              if (s2) {
                if (n2 > this.end)
                  return this.prior = null, i2;
                if (this.value.isDataDriven())
                  return this.prior = null, i2;
                if (n2 < this.begin)
                  return s2.possiblyEvaluate(t2, e2, r2);
                {
                  const a2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                    if (t3 <= 0)
                      return 0;
                    if (t3 >= 1)
                      return 1;
                    const e3 = t3 * t3, r3 = e3 * t3;
                    return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
                  }(a2));
                }
              }
              return i2;
            }
          }
          class ri {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new si(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values))
                if (this._values[t2].prior)
                  return true;
              return false;
            }
          }
          class ni {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
            }
            getValue(t2) {
              return p(this._values[t2].value);
            }
            setValue(t2, e2) {
              this._values[t2] = new Wn(this._values[t2].property, e2 === null ? void 0 : p(e2));
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                r2 !== void 0 && (t2[e2] = r2);
              }
              return t2;
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new si(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
          }
          class ii {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = e2, this.parameters = r2;
            }
            isConstant() {
              return this.value.kind === "constant";
            }
            constantOr(t2) {
              return this.value.kind === "constant" ? this.value.value : t2;
            }
            evaluate(t2, e2, r2, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
            }
          }
          class si {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class ai {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return t2.expression.evaluate(e2);
            }
            interpolate(t2, e2, r2) {
              const n2 = ze[this.specification.type];
              return n2 ? n2(t2, e2, r2) : t2;
            }
          }
          class oi {
            constructor(t2, e2) {
              this.specification = t2, this.overrides = e2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return new ii(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
            }
            interpolate(t2, e2, r2) {
              if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
                return t2;
              if (t2.value.value === void 0 || e2.value.value === void 0)
                return new ii(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = ze[this.specification.type];
              return n2 ? new ii(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
            }
          }
          class li extends oi {
            possiblyEvaluate(t2, e2, r2, n2) {
              if (t2.value === void 0)
                return new ii(this, { kind: "constant", value: void 0 }, e2);
              if (t2.expression.kind === "constant") {
                const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = t2.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
                return new ii(this, { kind: "constant", value: a2 }, e2);
              }
              if (t2.expression.kind === "camera") {
                const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
                return new ii(this, { kind: "constant", value: r3 }, e2);
              }
              return new ii(this, t2.expression, e2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              if (t2.kind === "source") {
                const a2 = t2.evaluate(e2, r2, n2, i2, s2);
                return this._calculate(a2, a2, a2, e2);
              }
              return t2.kind === "composite" ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
            }
            _calculate(t2, e2, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class ui {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              if (t2.value !== void 0) {
                if (t2.expression.kind === "constant") {
                  const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                  return this._calculate(i2, i2, i2, e2);
                }
                return this._calculate(t2.expression.evaluate(new Hn(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Hn(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Hn(Math.floor(e2.zoom + 1), e2)), e2);
              }
            }
            _calculate(t2, e2, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class ci {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return !!t2.expression.evaluate(e2, null, {}, r2, n2);
            }
            interpolate() {
              return false;
            }
          }
          class hi {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e2 in t2) {
                const r2 = t2[e2];
                r2.specification.overridable && this.overridableProperties.push(e2);
                const n2 = this.defaultPropertyValues[e2] = new Wn(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new Qn(r2);
                this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
              }
            }
          }
          Sn("DataDrivenProperty", oi), Sn("DataConstantProperty", ai), Sn("CrossFadedDataDrivenProperty", li), Sn("CrossFadedProperty", ui), Sn("ColorRampProperty", ci);
          const pi = "-transition";
          class fi extends rt {
            constructor(t2, e2) {
              if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, t2.type !== "custom" && (this.metadata = (t2 = t2).metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new ni(e2.layout)), e2.paint)) {
                this._transitionablePaint = new ti(e2.paint);
                for (const e3 in t2.paint)
                  this.setPaintProperty(e3, t2.paint[e3], { validate: false });
                for (const e3 in t2.layout)
                  this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new si(e2.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t2) {
              return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e2, r2 = {}) {
              e2 != null && this._validate(wn, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
            }
            getPaintProperty(t2) {
              return t2.endsWith(pi) ? this._transitionablePaint.getTransition(t2.slice(0, -pi.length)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e2, r2 = {}) {
              if (e2 != null && this._validate(bn, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
                return false;
              if (t2.endsWith(pi))
                return this._transitionablePaint.setTransition(t2.slice(0, -pi.length), e2 || void 0), false;
              {
                const r3 = this._transitionablePaint._values[t2], n2 = r3.property.specification["property-type"] === "cross-faded-data-driven", i2 = r3.value.isDataDriven(), s2 = r3.value;
                this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
                const a2 = this._transitionablePaint._values[t2].value;
                return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
              }
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e2) {
              t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
            }
            serialize() {
              const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), h(t2, (t3, e2) => !(t3 === void 0 || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
            }
            _validate(t2, e2, r2, n2, i2 = {}) {
              return (!i2 || i2.validate !== false) && _n(this, t2.call(xn, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: nt, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e2 = this.paint.get(t2);
                if (e2 instanceof ii && xr(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
                  return true;
              }
              return false;
            }
          }
          const di = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class yi {
            constructor(t2, e2) {
              this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class mi {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e2) {
              return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e2 = Object.create(this.prototype);
              return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e2 = this.uint8;
                this._refreshViews(), e2 && this.uint8.set(e2);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function gi(t2, e2 = 1) {
            let r2 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = di[t3.type].BYTES_PER_ELEMENT, s2 = r2 = xi(r2, Math.max(e2, i2)), a2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
            }), size: xi(r2, Math.max(n2, e2)), alignment: e2 };
          }
          function xi(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          class vi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
            }
          }
          vi.prototype.bytesPerElement = 4, Sn("StructArrayLayout2i4", vi);
          class bi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
            }
          }
          bi.prototype.bytesPerElement = 8, Sn("StructArrayLayout4i8", bi);
          class wi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          wi.prototype.bytesPerElement = 12, Sn("StructArrayLayout2i4i12", wi);
          class _i extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 4 * t2, l2 = 8 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
            }
          }
          _i.prototype.bytesPerElement = 8, Sn("StructArrayLayout2i4ub8", _i);
          class Ai extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
            }
          }
          Ai.prototype.bytesPerElement = 8, Sn("StructArrayLayout2f8", Ai);
          class ki extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = this.length;
              return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
              const h2 = 10 * t2;
              return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
            }
          }
          ki.prototype.bytesPerElement = 20, Sn("StructArrayLayout10ui20", ki);
          class Si extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const f2 = 12 * t2;
              return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
            }
          }
          Si.prototype.bytesPerElement = 24, Sn("StructArrayLayout4i4ui4i24", Si);
          class zi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          zi.prototype.bytesPerElement = 12, Sn("StructArrayLayout3f12", zi);
          class Ii extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint32[1 * t2 + 0] = e2, t2;
            }
          }
          Ii.prototype.bytesPerElement = 4, Sn("StructArrayLayout1ul4", Ii);
          class Mi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = this.length;
              return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = 10 * t2, h2 = 5 * t2;
              return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
            }
          }
          Mi.prototype.bytesPerElement = 20, Sn("StructArrayLayout6i1ul2ui20", Mi);
          class Bi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          Bi.prototype.bytesPerElement = 12, Sn("StructArrayLayout2i2i2i12", Bi);
          class Ci extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 4 * t2, o2 = 8 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
            }
          }
          Ci.prototype.bytesPerElement = 16, Sn("StructArrayLayout2f1f2i16", Ci);
          class Pi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 12 * t2, a2 = 3 * t2;
              return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
            }
          }
          Pi.prototype.bytesPerElement = 12, Sn("StructArrayLayout2ub2f12", Pi);
          class Vi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
            }
          }
          Vi.prototype.bytesPerElement = 6, Sn("StructArrayLayout3ui6", Vi);
          class Ei extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
              const g2 = this.length;
              return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
              const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
              return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
            }
          }
          Ei.prototype.bytesPerElement = 48, Sn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ei);
          class Fi extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, z2, I2) {
              const M2 = this.length;
              return this.resize(M2 + 1), this.emplace(M2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, z2, I2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, z2, I2, M2) {
              const B2 = 34 * t2, C2 = 17 * t2;
              return this.int16[B2 + 0] = e2, this.int16[B2 + 1] = r2, this.int16[B2 + 2] = n2, this.int16[B2 + 3] = i2, this.int16[B2 + 4] = s2, this.int16[B2 + 5] = a2, this.int16[B2 + 6] = o2, this.int16[B2 + 7] = l2, this.uint16[B2 + 8] = u2, this.uint16[B2 + 9] = c2, this.uint16[B2 + 10] = h2, this.uint16[B2 + 11] = p2, this.uint16[B2 + 12] = f2, this.uint16[B2 + 13] = d2, this.uint16[B2 + 14] = y2, this.uint16[B2 + 15] = m2, this.uint16[B2 + 16] = g2, this.uint16[B2 + 17] = x2, this.uint16[B2 + 18] = v2, this.uint16[B2 + 19] = b2, this.uint16[B2 + 20] = w2, this.uint16[B2 + 21] = _2, this.uint16[B2 + 22] = A2, this.uint32[C2 + 12] = k2, this.float32[C2 + 13] = S2, this.float32[C2 + 14] = z2, this.float32[C2 + 15] = I2, this.float32[C2 + 16] = M2, t2;
            }
          }
          Fi.prototype.bytesPerElement = 68, Sn("StructArrayLayout8i15ui1ul4f68", Fi);
          class Ti extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.float32[1 * t2 + 0] = e2, t2;
            }
          }
          Ti.prototype.bytesPerElement = 4, Sn("StructArrayLayout1f4", Ti);
          class Li extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          Li.prototype.bytesPerElement = 6, Sn("StructArrayLayout3i6", Li);
          class Di extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 4 * t2;
              return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
            }
          }
          Di.prototype.bytesPerElement = 8, Sn("StructArrayLayout1ul2ui8", Di);
          class $i extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
            }
          }
          $i.prototype.bytesPerElement = 4, Sn("StructArrayLayout2ui4", $i);
          class Ri extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint16[1 * t2 + 0] = e2, t2;
            }
          }
          Ri.prototype.bytesPerElement = 2, Sn("StructArrayLayout1ui2", Ri);
          class Ui extends mi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
            }
          }
          Ui.prototype.bytesPerElement = 16, Sn("StructArrayLayout4f16", Ui);
          class Oi extends yi {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
              return new S(this.anchorPointX, this.anchorPointY);
            }
          }
          Oi.prototype.size = 20;
          class qi extends Mi {
            get(t2) {
              return new Oi(this, t2);
            }
          }
          Sn("CollisionBoxArray", qi);
          class ji extends yi {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 37] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 38] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 10] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 22];
            }
          }
          ji.prototype.size = 48;
          class Ni extends Ei {
            get(t2) {
              return new ji(this, t2);
            }
          }
          Sn("PlacedSymbolArray", Ni);
          class Ki extends yi {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 12] = t2;
            }
            get textBoxScale() {
              return this._structArray.float32[this._pos4 + 13];
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 15];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 16];
            }
          }
          Ki.prototype.size = 68;
          class Zi extends Fi {
            get(t2) {
              return new Ki(this, t2);
            }
          }
          Sn("SymbolInstanceArray", Zi);
          class Gi extends Ti {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          Sn("GlyphOffsetArray", Gi);
          class Ji extends Li {
            getx(t2) {
              return this.int16[3 * t2 + 0];
            }
            gety(t2) {
              return this.int16[3 * t2 + 1];
            }
            gettileUnitDistanceFromAnchor(t2) {
              return this.int16[3 * t2 + 2];
            }
          }
          Sn("SymbolLineVertexArray", Ji);
          class Xi extends yi {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
          }
          Xi.prototype.size = 8;
          class Yi extends Di {
            get(t2) {
              return new Xi(this, t2);
            }
          }
          Sn("FeatureIndexArray", Yi);
          class Hi extends vi {
          }
          class Wi extends vi {
          }
          class Qi extends vi {
          }
          class ts extends wi {
          }
          class es extends _i {
          }
          class rs extends Ai {
          }
          class ns extends ki {
          }
          class is extends Si {
          }
          class ss extends zi {
          }
          class as extends Ii {
          }
          class os extends Bi {
          }
          class ls extends Pi {
          }
          class us extends Vi {
          }
          class cs extends $i {
          }
          const hs = gi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ps } = hs;
          class fs {
            constructor(t2 = []) {
              this.segments = t2;
            }
            prepareSegment(t2, e2, r2, n2) {
              let i2 = this.segments[this.segments.length - 1];
              return t2 > fs.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${fs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > fs.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, n2 !== void 0 && (i2.sortKey = n2), this.segments.push(i2)), i2;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments)
                for (const e2 in t2.vaos)
                  t2.vaos[e2].destroy();
            }
            static simpleSegment(t2, e2, r2, n2) {
              return new fs([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          function ds(t2, e2) {
            return 256 * (t2 = s(Math.floor(t2), 0, 255)) + s(Math.floor(e2), 0, 255);
          }
          fs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Sn("SegmentVector", fs);
          const ys = gi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
          var ms = { exports: {} }, gs = { exports: {} };
          gs.exports = function(t2, e2) {
            var r2, n2, i2, s2, a2, o2, l2, u2;
            for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
              l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
            switch (l2 = 0, r2) {
              case 3:
                l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
              case 1:
                i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
          };
          var xs = { exports: {} };
          xs.exports = function(t2, e2) {
            for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; )
              r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
            switch (n2) {
              case 3:
                i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
              case 2:
                i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
              case 1:
                i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
            }
            return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
          };
          var vs = gs.exports, bs = xs.exports;
          ms.exports = vs, ms.exports.murmur3 = vs, ms.exports.murmur2 = bs;
          var ws = ms.exports;
          class _s {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t2, e2, r2, n2) {
              this.ids.push(As(t2)), this.positions.push(e2, r2, n2);
            }
            getPositions(t2) {
              const e2 = As(t2);
              let r2 = 0, n2 = this.ids.length - 1;
              for (; r2 < n2; ) {
                const t3 = r2 + n2 >> 1;
                this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
              }
              const i2 = [];
              for (; this.ids[r2] === e2; )
                i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
              return i2;
            }
            static serialize(t2, e2) {
              const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return ks(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
            }
            static deserialize(t2) {
              const e2 = new _s();
              return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
            }
          }
          function As(t2) {
            const e2 = +t2;
            return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : ws(String(t2));
          }
          function ks(t2, e2, r2, n2) {
            for (; r2 < n2; ) {
              const i2 = t2[r2 + n2 >> 1];
              let s2 = r2 - 1, a2 = n2 + 1;
              for (; ; ) {
                do {
                  s2++;
                } while (t2[s2] < i2);
                do {
                  a2--;
                } while (t2[a2] > i2);
                if (s2 >= a2)
                  break;
                Ss(t2, s2, a2), Ss(e2, 3 * s2, 3 * a2), Ss(e2, 3 * s2 + 1, 3 * a2 + 1), Ss(e2, 3 * s2 + 2, 3 * a2 + 2);
              }
              a2 - r2 < n2 - a2 ? (ks(t2, e2, r2, a2), r2 = a2 + 1) : (ks(t2, e2, a2 + 1, n2), n2 = a2);
            }
          }
          function Ss(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          Sn("FeaturePositionMap", _s);
          class zs {
            constructor(t2, e2) {
              this.gl = t2.gl, this.location = e2;
            }
          }
          class Is extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
            }
          }
          class Ms extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
            }
          }
          class Bs extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = Et.transparent;
            }
            set(t2) {
              t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
            }
          }
          const Cs = new Float32Array(16);
          function Ps(t2) {
            return [ds(255 * t2.r, 255 * t2.g), ds(255 * t2.b, 255 * t2.a)];
          }
          class Vs {
            constructor(t2, e2, r2) {
              this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
            }
            setUniform(t2, e2, r2) {
              t2.set(r2.constantOr(this.value));
            }
            getBinding(t2, e2, r2) {
              return this.type === "color" ? new Bs(t2, e2) : new Is(t2, e2);
            }
          }
          class Es {
            constructor(t2, e2) {
              this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t2, e2) {
              this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
            }
            setUniform(t2, e2, r2, n2) {
              const i2 = n2 === "u_pattern_to" ? this.patternTo : n2 === "u_pattern_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
              i2 && t2.set(i2);
            }
            getBinding(t2, e2, r2) {
              return r2.substr(0, 9) === "u_pattern" ? new Ms(t2, e2) : new Is(t2, e2);
            }
          }
          class Fs {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2, n2, i2) {
              const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new Hn(0), e2, {}, n2, [], i2);
              this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
            }
            updatePaintArray(t2, e2, r2, n2) {
              const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
              this._setPaintValue(t2, e2, i2);
            }
            _setPaintValue(t2, e2, r2) {
              if (this.type === "color") {
                const n2 = Ps(r2);
                for (let r3 = t2; r3 < e2; r3++)
                  this.paintVertexArray.emplace(r3, n2[0], n2[1]);
              } else {
                for (let n2 = t2; n2 < e2; n2++)
                  this.paintVertexArray.emplace(n2, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class Ts {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r2, n2, i2) {
              const s2 = this.expression.evaluate(new Hn(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new Hn(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
            }
            updatePaintArray(t2, e2, r2, n2) {
              const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
              this._setPaintValue(t2, e2, i2, s2);
            }
            _setPaintValue(t2, e2, r2, n2) {
              if (this.type === "color") {
                const i2 = Ps(r2), s2 = Ps(n2);
                for (let r3 = t2; r3 < e2; r3++)
                  this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
              } else {
                for (let i2 = t2; i2 < e2; i2++)
                  this.paintVertexArray.emplace(i2, r2, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e2) {
              const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = s(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
              t2.set(n2);
            }
            getBinding(t2, e2, r2) {
              return new Is(t2, e2);
            }
          }
          class Ls {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
            }
            populatePaintArray(t2, e2, r2) {
              const n2 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
            }
            updatePaintArray(t2, e2, r2, n2, i2) {
              this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
            }
            _setPaintValues(t2, e2, r2, n2) {
              if (!n2 || !r2)
                return;
              const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
              if (o2 && l2 && u2)
                for (let r3 = t2; r3 < e2; r3++)
                  this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
            }
            upload(t2) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ys.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ys.members, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class Ds {
            constructor(t2, e2, r2) {
              this.binders = {}, this._buffers = [];
              const n2 = [];
              for (const i2 in t2.paint._values) {
                if (!r2(i2))
                  continue;
                const s2 = t2.paint.get(i2);
                if (!(s2 instanceof ii && xr(s2.property.specification)))
                  continue;
                const a2 = Rs(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = c2 === "cross-faded" || c2 === "cross-faded-data-driven";
                if (o2.kind === "constant")
                  this.binders[i2] = h2 ? new Es(o2.value, a2) : new Vs(o2.value, a2, l2), n2.push(`/u_${i2}`);
                else if (o2.kind === "source" || h2) {
                  const r3 = Us(i2, l2, "source");
                  this.binders[i2] = h2 ? new Ls(o2, l2, u2, e2, r3, t2.id) : new Fs(o2, a2, l2, r3), n2.push(`/a_${i2}`);
                } else {
                  const t3 = Us(i2, l2, "composite");
                  this.binders[i2] = new Ts(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
                }
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof Fs || e2 instanceof Ts ? e2.maxValue : 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2) {
              for (const s2 in this.binders) {
                const a2 = this.binders[s2];
                (a2 instanceof Fs || a2 instanceof Ts || a2 instanceof Ls) && a2.populatePaintArray(t2, e2, r2, n2, i2);
              }
            }
            setConstantPatternPositions(t2, e2) {
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                n2 instanceof Es && n2.setConstantPatternPositions(t2, e2);
              }
            }
            updatePaintArrays(t2, e2, r2, n2, i2) {
              let s2 = false;
              for (const a2 in t2) {
                const o2 = e2.getPositions(a2);
                for (const e3 of o2) {
                  const o3 = r2.feature(e3.index);
                  for (const r3 in this.binders) {
                    const l2 = this.binders[r3];
                    if ((l2 instanceof Fs || l2 instanceof Ts || l2 instanceof Ls) && l2.expression.isStateDependent === true) {
                      const u2 = n2.paint.get(r3);
                      l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                    }
                  }
                }
              }
              return s2;
            }
            defines() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof Vs || r2 instanceof Es) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof Fs || r2 instanceof Ts)
                  for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                    t2.push(r2.paintVertexAttributes[e3].name);
                else if (r2 instanceof Ls)
                  for (let e3 = 0; e3 < ys.members.length; e3++)
                    t2.push(ys.members[e3].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof Vs || r2 instanceof Es || r2 instanceof Ts)
                  for (const e3 of r2.uniformNames)
                    t2.push(e3);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2, e2) {
              const r2 = [];
              for (const n2 in this.binders) {
                const i2 = this.binders[n2];
                if (i2 instanceof Vs || i2 instanceof Es || i2 instanceof Ts) {
                  for (const s2 of i2.uniformNames)
                    if (e2[s2]) {
                      const a2 = i2.getBinding(t2, e2[s2], s2);
                      r2.push({ name: s2, property: n2, binding: a2 });
                    }
                }
              }
              return r2;
            }
            setUniforms(t2, e2, r2, n2) {
              for (const { name: t3, property: i2, binding: s2 } of e2)
                this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
            }
            updatePaintBuffers(t2) {
              this._buffers = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (t2 && r2 instanceof Ls) {
                  const e3 = t2.fromScale === 2 ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                  e3 && this._buffers.push(e3);
                } else
                  (r2 instanceof Fs || r2 instanceof Ts) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
              }
            }
            upload(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof Fs || r2 instanceof Ts || r2 instanceof Ls) && r2.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof Fs || e2 instanceof Ts || e2 instanceof Ls) && e2.destroy();
              }
            }
          }
          class $s {
            constructor(t2, e2, r2 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2)
                this.programConfigurations[n2.id] = new Ds(n2, e2, r2);
              this.needsUpload = false, this._featureMap = new _s(), this._bufferOffset = 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2) {
              for (const r3 in this.programConfigurations)
                this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
              e2.id !== void 0 && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e2, r2, n2) {
              for (const i2 of r2)
                this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e2 in this.programConfigurations)
                  this.programConfigurations[e2].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations)
                this.programConfigurations[t2].destroy();
            }
          }
          function Rs(t2, e2) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
          }
          function Us(t2, e2, r2) {
            const n2 = { color: { source: Ai, composite: Ui }, number: { source: Ti, composite: Ai } }, i2 = function(t3) {
              return { "line-pattern": { source: ns, composite: ns }, "fill-pattern": { source: ns, composite: ns }, "fill-extrusion-pattern": { source: ns, composite: ns } }[t3];
            }(t2);
            return i2 && i2[r2] || n2[e2][r2];
          }
          Sn("ConstantBinder", Vs), Sn("CrossFadedConstantBinder", Es), Sn("SourceExpressionBinder", Fs), Sn("CrossFadedCompositeBinder", Ls), Sn("CompositeExpressionBinder", Ts), Sn("ProgramConfiguration", Ds, { omit: ["_buffers"] }), Sn("ProgramConfigurationSet", $s);
          var Os = 8192;
          const qs = Math.pow(2, 14) - 1, js = -qs - 1;
          function Ns(t2) {
            const e2 = Os / t2.extent, r2 = t2.loadGeometry();
            for (let t3 = 0; t3 < r2.length; t3++) {
              const n2 = r2[t3];
              for (let t4 = 0; t4 < n2.length; t4++) {
                const r3 = n2[t4], i2 = Math.round(r3.x * e2), a2 = Math.round(r3.y * e2);
                r3.x = s(i2, js, qs), r3.y = s(a2, js, qs), (i2 < r3.x || i2 > r3.x + 1 || a2 < r3.y || a2 > r3.y + 1) && d("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r2;
          }
          function Ks(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ns(t2) : [] };
          }
          function Zs(t2, e2, r2, n2, i2) {
            t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
          }
          class Gs {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Wi(), this.indexArray = new us(), this.segments = new fs(), this.programConfigurations = new $s(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              const n2 = this.layers[0], i2 = [];
              let s2 = null, a2 = false;
              n2.type === "circle" && (s2 = n2.layout.get("circle-sort-key"), a2 = !s2.isConstant());
              for (const { feature: e3, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ks(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new Hn(this.zoom), u2, r2))
                  continue;
                const c2 = a2 ? s2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Ns(e3), patterns: {}, sortKey: c2 };
                i2.push(h2);
              }
              a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of i2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o2 = t2[s3].feature;
                this.addFeature(n3, i3, s3, r2), e2.featureIndex.insert(o2, i3, s3, a3, this.index);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ps), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r2, n2) {
              for (const r3 of e2)
                for (const e3 of r3) {
                  const r4 = e3.x, n3 = e3.y;
                  if (r4 < 0 || r4 >= Os || n3 < 0 || n3 >= Os)
                    continue;
                  const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
                  Zs(this.layoutVertexArray, r4, n3, -1, -1), Zs(this.layoutVertexArray, r4, n3, 1, -1), Zs(this.layoutVertexArray, r4, n3, 1, 1), Zs(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
            }
          }
          function Js(t2, e2) {
            for (let r2 = 0; r2 < t2.length; r2++)
              if (na(e2, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (na(t2, e2[r2]))
                return true;
            return !!Ws(t2, e2);
          }
          function Xs(t2, e2, r2) {
            return !!na(t2, e2) || !!ta(e2, t2, r2);
          }
          function Ys(t2, e2) {
            if (t2.length === 1)
              return ra(e2, t2[0]);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const n2 = e2[r2];
              for (let e3 = 0; e3 < n2.length; e3++)
                if (na(t2, n2[e3]))
                  return true;
            }
            for (let r2 = 0; r2 < t2.length; r2++)
              if (ra(e2, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (Ws(t2, e2[r2]))
                return true;
            return false;
          }
          function Hs(t2, e2, r2) {
            if (t2.length > 1) {
              if (Ws(t2, e2))
                return true;
              for (let n2 = 0; n2 < e2.length; n2++)
                if (ta(e2[n2], t2, r2))
                  return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++)
              if (ta(t2[n2], e2, r2))
                return true;
            return false;
          }
          function Ws(t2, e2) {
            if (t2.length === 0 || e2.length === 0)
              return false;
            for (let r2 = 0; r2 < t2.length - 1; r2++) {
              const n2 = t2[r2], i2 = t2[r2 + 1];
              for (let t3 = 0; t3 < e2.length - 1; t3++)
                if (Qs(n2, i2, e2[t3], e2[t3 + 1]))
                  return true;
            }
            return false;
          }
          function Qs(t2, e2, r2, n2) {
            return y(t2, r2, n2) !== y(e2, r2, n2) && y(t2, e2, r2) !== y(t2, e2, n2);
          }
          function ta(t2, e2, r2) {
            const n2 = r2 * r2;
            if (e2.length === 1)
              return t2.distSqr(e2[0]) < n2;
            for (let r3 = 1; r3 < e2.length; r3++)
              if (ea(t2, e2[r3 - 1], e2[r3]) < n2)
                return true;
            return false;
          }
          function ea(t2, e2, r2) {
            const n2 = e2.distSqr(r2);
            if (n2 === 0)
              return t2.distSqr(e2);
            const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
          }
          function ra(t2, e2) {
            let r2, n2, i2, s2 = false;
            for (let a2 = 0; a2 < t2.length; a2++) {
              r2 = t2[a2];
              for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
                n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
            }
            return s2;
          }
          function na(t2, e2) {
            let r2 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const s2 = t2[n2], a2 = t2[i2];
              s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
            }
            return r2;
          }
          function ia(t2, e2, r2) {
            const n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
              return false;
            const s2 = y(t2, e2, r2[0]);
            return s2 !== y(t2, e2, r2[1]) || s2 !== y(t2, e2, r2[2]) || s2 !== y(t2, e2, r2[3]);
          }
          function sa(t2, e2, r2) {
            const n2 = e2.paint.get(t2).value;
            return n2.kind === "constant" ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function aa(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function oa(t2, e2, r2, n2, i2) {
            if (!e2[0] && !e2[1])
              return t2;
            const s2 = S.convert(e2)._mult(i2);
            r2 === "viewport" && s2._rotate(-n2);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3++)
              a2.push(t2[e3].sub(s2));
            return a2;
          }
          Sn("CircleBucket", Gs, { omit: ["layers"] });
          const la = new hi({ "circle-sort-key": new oi(nt.layout_circle["circle-sort-key"]) });
          var ua = { paint: new hi({ "circle-radius": new oi(nt.paint_circle["circle-radius"]), "circle-color": new oi(nt.paint_circle["circle-color"]), "circle-blur": new oi(nt.paint_circle["circle-blur"]), "circle-opacity": new oi(nt.paint_circle["circle-opacity"]), "circle-translate": new ai(nt.paint_circle["circle-translate"]), "circle-translate-anchor": new ai(nt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ai(nt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ai(nt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new oi(nt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new oi(nt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new oi(nt.paint_circle["circle-stroke-opacity"]) }), layout: la }, ca = 1e-6, ha = typeof Float32Array != "undefined" ? Float32Array : Array;
          function pa(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function fa(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
            return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = 0, e2 = arguments.length; e2--; )
              t2 += arguments[e2] * arguments[e2];
            return Math.sqrt(t2);
          });
          var da, ya = fa;
          function ma(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
          }
          function ga(t2, e2) {
            const r2 = ma([], [t2.x, t2.y, 0, 1], e2);
            return new S(r2[0] / r2[3], r2[1] / r2[3]);
          }
          da = new ha(4), ha != Float32Array && (da[0] = 0, da[1] = 0, da[2] = 0, da[3] = 0);
          class xa extends Gs {
          }
          Sn("HeatmapBucket", xa, { omit: ["layers"] });
          var va = { paint: new hi({ "heatmap-radius": new oi(nt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new oi(nt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ai(nt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ci(nt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ai(nt.paint_heatmap["heatmap-opacity"]) }) };
          function ba(t2, { width: e2, height: r2 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray)
                i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e2 * r2 * n2)
                throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
            } else
              i2 = new Uint8Array(e2 * r2 * n2);
            return t2.width = e2, t2.height = r2, t2.data = i2, t2;
          }
          function wa(t2, { width: e2, height: r2 }, n2) {
            if (e2 === t2.width && r2 === t2.height)
              return;
            const i2 = ba({}, { width: e2, height: r2 }, n2);
            _a(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
          }
          function _a(t2, e2, r2, n2, i2, s2) {
            if (i2.width === 0 || i2.height === 0)
              return e2;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const a2 = t2.data, o2 = e2.data;
            for (let l2 = 0; l2 < i2.height; l2++) {
              const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
              for (let t3 = 0; t3 < i2.width * s2; t3++)
                o2[c2 + t3] = a2[u2 + t3];
            }
            return e2;
          }
          class Aa {
            constructor(t2, e2) {
              ba(this, t2, 1, e2);
            }
            resize(t2) {
              wa(this, t2, 1);
            }
            clone() {
              return new Aa({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              _a(t2, e2, r2, n2, i2, 1);
            }
          }
          class ka {
            constructor(t2, e2) {
              ba(this, t2, 4, e2);
            }
            resize(t2) {
              wa(this, t2, 4);
            }
            replace(t2, e2) {
              e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new ka({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              _a(t2, e2, r2, n2, i2, 4);
            }
          }
          function Sa(t2) {
            const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new ka({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
              e2[t2.evaluationKey] = s3;
              const a2 = t2.expression.evaluate(e2);
              i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
            };
            if (t2.clips)
              for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
                for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
                  const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
                  s2(i3, a2, l2 * (1 - o2) + u2 * o2);
                }
            else
              for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
                s2(0, e3, t3 / (r2 - 1));
            return i2;
          }
          Sn("AlphaImage", Aa), Sn("RGBAImage", ka);
          var za = { paint: new hi({ "hillshade-illumination-direction": new ai(nt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ai(nt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ai(nt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ai(nt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ai(nt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ai(nt.paint_hillshade["hillshade-accent-color"]) }) };
          const Ia = gi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ma } = Ia;
          var Ba = { exports: {} };
          function Ca(t2, e2, r2) {
            r2 = r2 || 2;
            var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r2 : t2.length, p2 = Pa(t2, 0, h2, r2, true), f2 = [];
            if (!p2 || p2.next === p2.prev)
              return f2;
            if (c2 && (p2 = function(t3, e3, r3, n3) {
              var i3, s3, a3, o3 = [];
              for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
                (a3 = Pa(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(qa(a3));
              for (o3.sort($a), i3 = 0; i3 < o3.length; i3++)
                r3 = Va(r3 = Ra(o3[i3], r3), r3.next);
              return r3;
            }(t2, e2, p2, r2)), t2.length > 80 * r2) {
              n2 = s2 = t2[0], i2 = a2 = t2[1];
              for (var d2 = r2; d2 < h2; d2 += r2)
                (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
              u2 = (u2 = Math.max(s2 - n2, a2 - i2)) !== 0 ? 1 / u2 : 0;
            }
            return Ea(p2, f2, r2, n2, i2, u2), f2;
          }
          function Pa(t2, e2, r2, n2, i2) {
            var s2, a2;
            if (i2 === eo(t2, e2, r2, n2) > 0)
              for (s2 = e2; s2 < r2; s2 += n2)
                a2 = Wa(s2, t2[s2], t2[s2 + 1], a2);
            else
              for (s2 = r2 - n2; s2 >= e2; s2 -= n2)
                a2 = Wa(s2, t2[s2], t2[s2 + 1], a2);
            return a2 && Za(a2, a2.next) && (Qa(a2), a2 = a2.next), a2;
          }
          function Va(t2, e2) {
            if (!t2)
              return t2;
            e2 || (e2 = t2);
            var r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !Za(n2, n2.next) && Ka(n2.prev, n2, n2.next) !== 0)
                n2 = n2.next;
              else {
                if (Qa(n2), (n2 = e2 = n2.prev) === n2.next)
                  break;
                r2 = true;
              }
            } while (r2 || n2 !== e2);
            return e2;
          }
          function Ea(t2, e2, r2, n2, i2, s2, a2) {
            if (t2) {
              !a2 && s2 && function(t3, e3, r3, n3) {
                var i3 = t3;
                do {
                  i3.z === null && (i3.z = Oa(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
                } while (i3 !== t3);
                i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                  var e4, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
                  do {
                    for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                      for (a3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                        ;
                      for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                        o3 !== 0 && (l3 === 0 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                      r4 = n4;
                    }
                    s3.nextZ = null, u3 *= 2;
                  } while (a3 > 1);
                }(i3);
              }(t2, n2, i2, s2);
              for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
                if (o2 = t2.prev, l2 = t2.next, s2 ? Ta(t2, n2, i2, s2) : Fa(t2))
                  e2.push(o2.i / r2), e2.push(t2.i / r2), e2.push(l2.i / r2), Qa(t2), t2 = l2.next, u2 = l2.next;
                else if ((t2 = l2) === u2) {
                  a2 ? a2 === 1 ? Ea(t2 = La(Va(t2), e2, r2), e2, r2, n2, i2, s2, 2) : a2 === 2 && Da(t2, e2, r2, n2, i2, s2) : Ea(Va(t2), e2, r2, n2, i2, s2, 1);
                  break;
                }
            }
          }
          function Fa(t2) {
            var e2 = t2.prev, r2 = t2, n2 = t2.next;
            if (Ka(e2, r2, n2) >= 0)
              return false;
            for (var i2 = t2.next.next; i2 !== t2.prev; ) {
              if (ja(e2.x, e2.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && Ka(i2.prev, i2, i2.next) >= 0)
                return false;
              i2 = i2.next;
            }
            return true;
          }
          function Ta(t2, e2, r2, n2) {
            var i2 = t2.prev, s2 = t2, a2 = t2.next;
            if (Ka(i2, s2, a2) >= 0)
              return false;
            for (var o2 = i2.x > s2.x ? i2.x > a2.x ? i2.x : a2.x : s2.x > a2.x ? s2.x : a2.x, l2 = i2.y > s2.y ? i2.y > a2.y ? i2.y : a2.y : s2.y > a2.y ? s2.y : a2.y, u2 = Oa(i2.x < s2.x ? i2.x < a2.x ? i2.x : a2.x : s2.x < a2.x ? s2.x : a2.x, i2.y < s2.y ? i2.y < a2.y ? i2.y : a2.y : s2.y < a2.y ? s2.y : a2.y, e2, r2, n2), c2 = Oa(o2, l2, e2, r2, n2), h2 = t2.prevZ, p2 = t2.nextZ; h2 && h2.z >= u2 && p2 && p2.z <= c2; ) {
              if (h2 !== t2.prev && h2 !== t2.next && ja(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && Ka(h2.prev, h2, h2.next) >= 0)
                return false;
              if (h2 = h2.prevZ, p2 !== t2.prev && p2 !== t2.next && ja(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && Ka(p2.prev, p2, p2.next) >= 0)
                return false;
              p2 = p2.nextZ;
            }
            for (; h2 && h2.z >= u2; ) {
              if (h2 !== t2.prev && h2 !== t2.next && ja(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && Ka(h2.prev, h2, h2.next) >= 0)
                return false;
              h2 = h2.prevZ;
            }
            for (; p2 && p2.z <= c2; ) {
              if (p2 !== t2.prev && p2 !== t2.next && ja(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && Ka(p2.prev, p2, p2.next) >= 0)
                return false;
              p2 = p2.nextZ;
            }
            return true;
          }
          function La(t2, e2, r2) {
            var n2 = t2;
            do {
              var i2 = n2.prev, s2 = n2.next.next;
              !Za(i2, s2) && Ga(i2, n2, n2.next, s2) && Ya(i2, s2) && Ya(s2, i2) && (e2.push(i2.i / r2), e2.push(n2.i / r2), e2.push(s2.i / r2), Qa(n2), Qa(n2.next), n2 = t2 = s2), n2 = n2.next;
            } while (n2 !== t2);
            return Va(n2);
          }
          function Da(t2, e2, r2, n2, i2, s2) {
            var a2 = t2;
            do {
              for (var o2 = a2.next.next; o2 !== a2.prev; ) {
                if (a2.i !== o2.i && Na(a2, o2)) {
                  var l2 = Ha(a2, o2);
                  return a2 = Va(a2, a2.next), l2 = Va(l2, l2.next), Ea(a2, e2, r2, n2, i2, s2), void Ea(l2, e2, r2, n2, i2, s2);
                }
                o2 = o2.next;
              }
              a2 = a2.next;
            } while (a2 !== t2);
          }
          function $a(t2, e2) {
            return t2.x - e2.x;
          }
          function Ra(t2, e2) {
            var r2 = function(t3, e3) {
              var r3, n3 = e3, i3 = t3.x, s2 = t3.y, a2 = -1 / 0;
              do {
                if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
                  var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                  if (o2 <= i3 && o2 > a2) {
                    if (a2 = o2, o2 === i3) {
                      if (s2 === n3.y)
                        return n3;
                      if (s2 === n3.next.y)
                        return n3.next;
                    }
                    r3 = n3.x < n3.next.x ? n3 : n3.next;
                  }
                }
                n3 = n3.next;
              } while (n3 !== e3);
              if (!r3)
                return null;
              if (i3 === a2)
                return r3;
              var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
              n3 = r3;
              do {
                i3 >= n3.x && n3.x >= c2 && i3 !== n3.x && ja(s2 < h2 ? i3 : a2, s2, c2, h2, s2 < h2 ? a2 : i3, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i3 - n3.x), Ya(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && Ua(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
              } while (n3 !== u2);
              return r3;
            }(t2, e2);
            if (!r2)
              return e2;
            var n2 = Ha(r2, t2), i2 = Va(r2, r2.next);
            return Va(n2, n2.next), e2 === r2 ? i2 : e2;
          }
          function Ua(t2, e2) {
            return Ka(t2.prev, t2, e2.prev) < 0 && Ka(e2.next, t2, t2.next) < 0;
          }
          function Oa(t2, e2, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function qa(t2) {
            var e2 = t2, r2 = t2;
            do {
              (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r2;
          }
          function ja(t2, e2, r2, n2, i2, s2, a2, o2) {
            return (i2 - a2) * (e2 - o2) - (t2 - a2) * (s2 - o2) >= 0 && (t2 - a2) * (n2 - o2) - (r2 - a2) * (e2 - o2) >= 0 && (r2 - a2) * (s2 - o2) - (i2 - a2) * (n2 - o2) >= 0;
          }
          function Na(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              var r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ga(r2, r2.next, t3, e3))
                  return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e2) && (Ya(t2, e2) && Ya(e2, t2) && function(t3, e3) {
              var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
              do {
                r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e2) && (Ka(t2.prev, t2, e2.prev) || Ka(t2, e2.prev, e2)) || Za(t2, e2) && Ka(t2.prev, t2, t2.next) > 0 && Ka(e2.prev, e2, e2.next) > 0);
          }
          function Ka(t2, e2, r2) {
            return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
          }
          function Za(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function Ga(t2, e2, r2, n2) {
            var i2 = Xa(Ka(t2, e2, r2)), s2 = Xa(Ka(t2, e2, n2)), a2 = Xa(Ka(r2, n2, t2)), o2 = Xa(Ka(r2, n2, e2));
            return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !Ja(t2, r2, e2)) || !(s2 !== 0 || !Ja(t2, n2, e2)) || !(a2 !== 0 || !Ja(r2, t2, n2)) || !(o2 !== 0 || !Ja(r2, e2, n2));
          }
          function Ja(t2, e2, r2) {
            return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
          }
          function Xa(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function Ya(t2, e2) {
            return Ka(t2.prev, t2, t2.next) < 0 ? Ka(t2, e2, t2.next) >= 0 && Ka(t2, t2.prev, e2) >= 0 : Ka(t2, e2, t2.prev) < 0 || Ka(t2, t2.next, e2) < 0;
          }
          function Ha(t2, e2) {
            var r2 = new to(t2.i, t2.x, t2.y), n2 = new to(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
          }
          function Wa(t2, e2, r2, n2) {
            var i2 = new to(t2, e2, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function Qa(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function to(t2, e2, r2) {
            this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function eo(t2, e2, r2, n2) {
            for (var i2 = 0, s2 = e2, a2 = r2 - n2; s2 < r2; s2 += n2)
              i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
            return i2;
          }
          Ba.exports = Ca, Ba.exports.default = Ca, Ca.deviation = function(t2, e2, r2, n2) {
            var i2 = e2 && e2.length, s2 = Math.abs(eo(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
            if (i2)
              for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
                s2 -= Math.abs(eo(t2, e2[a2] * r2, a2 < o2 - 1 ? e2[a2 + 1] * r2 : t2.length, r2));
            var l2 = 0;
            for (a2 = 0; a2 < n2.length; a2 += 3) {
              var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h2 = n2[a2 + 2] * r2;
              l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
            }
            return s2 === 0 && l2 === 0 ? 0 : Math.abs((l2 - s2) / s2);
          }, Ca.flatten = function(t2) {
            for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
              for (var s2 = 0; s2 < t2[i2].length; s2++)
                for (var a2 = 0; a2 < e2; a2++)
                  r2.vertices.push(t2[i2][s2][a2]);
              i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
            }
            return r2;
          };
          var ro = Ba.exports;
          function no(t2, e2, r2, n2, i2) {
            io(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || ao);
          }
          function io(t2, e2, r2, n2, i2) {
            for (; n2 > r2; ) {
              if (n2 - r2 > 600) {
                var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
                io(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
              }
              var c2 = t2[e2], h2 = r2, p2 = n2;
              for (so(t2, r2, e2), i2(t2[n2], c2) > 0 && so(t2, r2, n2); h2 < p2; ) {
                for (so(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                  h2++;
                for (; i2(t2[p2], c2) > 0; )
                  p2--;
              }
              i2(t2[r2], c2) === 0 ? so(t2, r2, p2) : so(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
            }
          }
          function so(t2, e2, r2) {
            var n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function ao(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function oo(t2, e2) {
            const r2 = t2.length;
            if (r2 <= 1)
              return [t2];
            const n2 = [];
            let i2, s2;
            for (let e3 = 0; e3 < r2; e3++) {
              const r3 = m(t2[e3]);
              r3 !== 0 && (t2[e3].area = Math.abs(r3), s2 === void 0 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
            }
            if (i2 && n2.push(i2), e2 > 1)
              for (let t3 = 0; t3 < n2.length; t3++)
                n2[t3].length <= e2 || (no(n2[t3], e2, 1, n2[t3].length - 1, lo), n2[t3] = n2[t3].slice(0, e2));
            return n2;
          }
          function lo(t2, e2) {
            return e2.area - t2.area;
          }
          function uo(t2, e2, r2) {
            const n2 = r2.patternDependencies;
            let i2 = false;
            for (const r3 of e2) {
              const e3 = r3.paint.get(`${t2}-pattern`);
              e3.isConstant() || (i2 = true);
              const s2 = e3.constantOr(null);
              s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
            }
            return i2;
          }
          function co(t2, e2, r2, n2, i2) {
            const s2 = i2.patternDependencies;
            for (const a2 of e2) {
              const e3 = a2.paint.get(`${t2}-pattern`).value;
              if (e3.kind !== "constant") {
                let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
              }
            }
            return r2;
          }
          class ho {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Qi(), this.indexArray = new us(), this.indexArray2 = new cs(), this.programConfigurations = new $s(t2.layers, t2.zoom), this.segments = new fs(), this.segments2 = new fs(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              this.hasPattern = uo("fill", this.layers, e2);
              const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
              for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, c2 = Ks(a2, t3);
                if (!this.layers[0]._featureFilter.filter(new Hn(this.zoom), c2, r2))
                  continue;
                const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Ns(a2), patterns: {}, sortKey: h2 };
                s2.push(p2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = co("fill", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s3, r2, {});
                e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            addFeatures(t2, e2, r2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r2);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ma), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t2, e2, r2, n2, i2) {
              for (const t3 of oo(e2, 500)) {
                let e3 = 0;
                for (const r4 of t3)
                  e3 += r4.length;
                const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
                for (const e4 of t3) {
                  if (e4.length === 0)
                    continue;
                  e4 !== t3[0] && s2.push(i3.length / 2);
                  const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                  this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                  for (let t4 = 1; t4 < e4.length; t4++)
                    this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                  r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
                }
                const a2 = ro(i3, s2);
                for (let t4 = 0; t4 < a2.length; t4 += 3)
                  this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
                r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
          }
          Sn("FillBucket", ho, { omit: ["layers", "patternFeatures"] });
          const po = new hi({ "fill-sort-key": new oi(nt.layout_fill["fill-sort-key"]) });
          var fo = { paint: new hi({ "fill-antialias": new ai(nt.paint_fill["fill-antialias"]), "fill-opacity": new oi(nt.paint_fill["fill-opacity"]), "fill-color": new oi(nt.paint_fill["fill-color"]), "fill-outline-color": new oi(nt.paint_fill["fill-outline-color"]), "fill-translate": new ai(nt.paint_fill["fill-translate"]), "fill-translate-anchor": new ai(nt.paint_fill["fill-translate-anchor"]), "fill-pattern": new li(nt.paint_fill["fill-pattern"]) }), layout: po };
          const yo = gi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), mo = gi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: go } = yo;
          var xo = {}, vo = S, bo = wo;
          function wo(t2, e2, r2, n2, i2) {
            this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(_o, this, e2);
          }
          function _o(t2, e2, r2) {
            t2 == 1 ? e2.id = r2.readVarint() : t2 == 2 ? function(t3, e3) {
              for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
                e3.properties[n2] = i2;
              }
            }(r2, e2) : t2 == 3 ? e2.type = r2.readVarint() : t2 == 4 && (e2._geometry = r2.pos);
          }
          function Ao(t2) {
            for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
            return n2;
          }
          wo.types = ["Unknown", "Point", "LineString", "Polygon"], wo.prototype.loadGeometry = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
              if (i2 <= 0) {
                var l2 = t2.readVarint();
                n2 = 7 & l2, i2 = l2 >> 3;
              }
              if (i2--, n2 === 1 || n2 === 2)
                s2 += t2.readSVarint(), a2 += t2.readSVarint(), n2 === 1 && (e2 && o2.push(e2), e2 = []), e2.push(new vo(s2, a2));
              else {
                if (n2 !== 7)
                  throw new Error("unknown command " + n2);
                e2 && e2.push(e2[0].clone());
              }
            }
            return e2 && o2.push(e2), o2;
          }, wo.prototype.bbox = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
              if (n2 <= 0) {
                var c2 = t2.readVarint();
                r2 = 7 & c2, n2 = c2 >> 3;
              }
              if (n2--, r2 === 1 || r2 === 2)
                (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
              else if (r2 !== 7)
                throw new Error("unknown command " + r2);
            }
            return [a2, l2, o2, u2];
          }, wo.prototype.toGeoJSON = function(t2, e2, r2) {
            var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = wo.types[this.type];
            function c2(t3) {
              for (var e3 = 0; e3 < t3.length; e3++) {
                var r3 = t3[e3];
                t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var h2 = [];
                for (n2 = 0; n2 < l2.length; n2++)
                  h2[n2] = l2[n2][0];
                c2(l2 = h2);
                break;
              case 2:
                for (n2 = 0; n2 < l2.length; n2++)
                  c2(l2[n2]);
                break;
              case 3:
                for (l2 = function(t3) {
                  var e3 = t3.length;
                  if (e3 <= 1)
                    return [t3];
                  for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                    var a3 = Ao(t3[s3]);
                    a3 !== 0 && (n3 === void 0 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
                  }
                  return r3 && i3.push(r3), i3;
                }(l2), n2 = 0; n2 < l2.length; n2++)
                  for (i2 = 0; i2 < l2[n2].length; i2++)
                    c2(l2[n2][i2]);
            }
            l2.length === 1 ? l2 = l2[0] : u2 = "Multi" + u2;
            var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
            return "id" in this && (p2.id = this.id), p2;
          };
          var ko = bo, So = zo;
          function zo(t2, e2) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Io, this, e2), this.length = this._features.length;
          }
          function Io(t2, e2, r2) {
            t2 === 15 ? e2.version = r2.readVarint() : t2 === 1 ? e2.name = r2.readString() : t2 === 5 ? e2.extent = r2.readVarint() : t2 === 2 ? e2._features.push(r2.pos) : t2 === 3 ? e2._keys.push(r2.readString()) : t2 === 4 && e2._values.push(function(t3) {
              for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = t3.readVarint() >> 3;
                e3 = n2 === 1 ? t3.readString() : n2 === 2 ? t3.readFloat() : n2 === 3 ? t3.readDouble() : n2 === 4 ? t3.readVarint64() : n2 === 5 ? t3.readVarint() : n2 === 6 ? t3.readSVarint() : n2 === 7 ? t3.readBoolean() : null;
              }
              return e3;
            }(r2));
          }
          zo.prototype.feature = function(t2) {
            if (t2 < 0 || t2 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            var e2 = this._pbf.readVarint() + this._pbf.pos;
            return new ko(this._pbf, e2, this.extent, this._keys, this._values);
          };
          var Mo = So;
          function Bo(t2, e2, r2) {
            if (t2 === 3) {
              var n2 = new Mo(r2, r2.readVarint() + r2.pos);
              n2.length && (e2[n2.name] = n2);
            }
          }
          xo.VectorTile = function(t2, e2) {
            this.layers = t2.readFields(Bo, {}, e2);
          }, xo.VectorTileFeature = bo, xo.VectorTileLayer = So;
          const Co = xo.VectorTileFeature.types, Po = Math.pow(2, 13);
          function Vo(t2, e2, r2, n2, i2, s2, a2, o2) {
            t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * Po) + a2, i2 * Po * 2, s2 * Po * 2, Math.round(o2));
          }
          class Eo {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new ts(), this.centroidVertexArray = new Hi(), this.indexArray = new us(), this.programConfigurations = new $s(t2.layers, t2.zoom), this.segments = new fs(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              this.features = [], this.hasPattern = uo("fill-extrusion", this.layers, e2);
              for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, o2 = Ks(n2, t3);
                if (!this.layers[0]._featureFilter.filter(new Hn(this.zoom), o2, r2))
                  continue;
                const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Ns(n2), properties: n2.properties, type: n2.type, patterns: {} };
                this.hasPattern ? this.features.push(co("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
              }
            }
            addFeatures(t2, e2, r2) {
              for (const t3 of this.features) {
                const { geometry: n2 } = t3;
                this.addFeature(t3, n2, t3.index, e2, r2);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, go), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, mo.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t2, e2, r2, n2, i2) {
              const s2 = { x: 0, y: 0, vertexCount: 0 };
              for (const r3 of oo(e2, 500)) {
                let e3 = 0;
                for (const t3 of r3)
                  e3 += t3.length;
                let n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                for (const t3 of r3) {
                  if (t3.length === 0)
                    continue;
                  if (To(t3))
                    continue;
                  let e4 = 0;
                  for (let r4 = 0; r4 < t3.length; r4++) {
                    const i4 = t3[r4];
                    if (r4 >= 1) {
                      const a3 = t3[r4 - 1];
                      if (!Fo(i4, a3)) {
                        n3.vertexLength + 4 > fs.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                        const t4 = i4.sub(a3)._perp()._unit(), r5 = a3.dist(i4);
                        e4 + r5 > 32768 && (e4 = 0), Vo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 0, e4), Vo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 1, e4), s2.x += 2 * i4.x, s2.y += 2 * i4.y, s2.vertexCount += 2, e4 += r5, Vo(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 0, e4), Vo(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 1, e4), s2.x += 2 * a3.x, s2.y += 2 * a3.y, s2.vertexCount += 2;
                        const o3 = n3.vertexLength;
                        this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                      }
                    }
                  }
                }
                if (n3.vertexLength + e3 > fs.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), Co[t2.type] !== "Polygon")
                  continue;
                const i3 = [], a2 = [], o2 = n3.vertexLength;
                for (const t3 of r3)
                  if (t3.length !== 0) {
                    t3 !== r3[0] && a2.push(i3.length / 2);
                    for (let e4 = 0; e4 < t3.length; e4++) {
                      const r4 = t3[e4];
                      Vo(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), s2.x += r4.x, s2.y += r4.y, s2.vertexCount += 1, i3.push(r4.x), i3.push(r4.y);
                    }
                  }
                const l2 = ro(i3, a2);
                for (let t3 = 0; t3 < l2.length; t3 += 3)
                  this.indexArray.emplaceBack(o2 + l2[t3], o2 + l2[t3 + 2], o2 + l2[t3 + 1]);
                n3.primitiveLength += l2.length / 3, n3.vertexLength += e3;
              }
              for (let t3 = 0; t3 < s2.vertexCount; t3++)
                this.centroidVertexArray.emplaceBack(Math.floor(s2.x / s2.vertexCount), Math.floor(s2.y / s2.vertexCount));
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
          }
          function Fo(t2, e2) {
            return t2.x === e2.x && (t2.x < 0 || t2.x > Os) || t2.y === e2.y && (t2.y < 0 || t2.y > Os);
          }
          function To(t2) {
            return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > Os) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > Os);
          }
          Sn("FillExtrusionBucket", Eo, { omit: ["layers", "features"] });
          var Lo = { paint: new hi({ "fill-extrusion-opacity": new ai(nt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new oi(nt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ai(nt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ai(nt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new li(nt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new oi(nt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new oi(nt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ai(nt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
          function Do(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function $o(t2, e2) {
            if (t2.length === 1) {
              let r2 = 0;
              const n2 = e2[r2++];
              let i2;
              for (; !i2 || n2.equals(i2); )
                if (i2 = e2[r2++], !i2)
                  return 1 / 0;
              for (; r2 < e2.length; r2++) {
                const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Do(o2, o2), h2 = Do(o2, l2), p2 = Do(l2, l2), f2 = Do(u2, o2), d2 = Do(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
                if (isFinite(x2))
                  return x2;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r2 of e2)
                t3 = Math.min(t3, r2.z);
              return t3;
            }
          }
          const Ro = gi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Uo } = Ro, Oo = gi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: qo } = Oo, jo = xo.VectorTileFeature.types, No = Math.cos(Math.PI / 180 * 37.5), Ko = Math.pow(2, 14) / 0.5;
          class Zo {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new es(), this.layoutVertexArray2 = new rs(), this.indexArray = new us(), this.programConfigurations = new $s(t2.layers, t2.zoom), this.segments = new fs(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              this.hasPattern = uo("line", this.layers, e2);
              const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
              for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ks(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new Hn(this.zoom), u2, r2))
                  continue;
                const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Ns(e3), patterns: {}, sortKey: c2 };
                s2.push(h2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = co("line", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s3, r2, {});
                e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            addFeatures(t2, e2, r2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r2);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, qo)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Uo), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
                return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e2, r2, n2, i2) {
              const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap"), l2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2);
              for (const r3 of e2)
                this.addLine(r3, t2, a2, o2, l2, u2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
            addLine(t2, e2, r2, n2, i2, s2) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e3 = 0; e3 < t2.length - 1; e3++)
                  this.totalDistance += t2[e3].dist(t2[e3 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const a2 = jo[e2.type] === "Polygon";
              let o2 = t2.length;
              for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
                o2--;
              let l2 = 0;
              for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
                l2++;
              if (o2 < (a2 ? 3 : 2))
                return;
              r2 === "bevel" && (i2 = 1.05);
              const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
              let h2, p2, f2, d2, y2;
              this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
              for (let e3 = l2; e3 < o2; e3++) {
                if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2))
                  continue;
                y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
                let m2 = d2.add(y2);
                m2.x === 0 && m2.y === 0 || m2._unit();
                const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = x2 !== 0 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < No && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
                if (w2 && e3 > l2) {
                  const t3 = h2.dist(p2);
                  if (t3 > 2 * u2) {
                    const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                    this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                  }
                }
                const A2 = p2 && f2;
                let k2 = A2 ? r2 : a2 ? "butt" : n2;
                if (A2 && k2 === "round" && (v2 < s2 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), k2 === "miter" && v2 > i2 && (k2 = "bevel"), k2 === "bevel" && (v2 > 2 && (k2 = "flipbevel"), v2 < i2 && (k2 = "miter")), p2 && this.updateDistance(p2, h2), k2 === "miter")
                  m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if (k2 === "flipbevel") {
                  if (v2 > 100)
                    m2 = y2.mult(-1);
                  else {
                    const t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                    m2._perp()._mult(t3 * (_2 ? -1 : 1));
                  }
                  this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
                } else if (k2 === "bevel" || k2 === "fakeround") {
                  const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                  if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), k2 === "fakeround") {
                    const t4 = Math.round(180 * b2 / Math.PI / 20);
                    for (let e5 = 1; e5 < t4; e5++) {
                      let r4 = e5 / t4;
                      if (r4 !== 0.5) {
                        const t5 = r4 - 0.5;
                        r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                      }
                      const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                      this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                    }
                  }
                  f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
                } else if (k2 === "butt")
                  this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if (k2 === "square") {
                  const t3 = p2 ? 1 : -1;
                  this.addCurrentVertex(h2, m2, t3, t3, c2);
                } else
                  k2 === "round" && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
                if (w2 && e3 < o2 - 1) {
                  const t3 = h2.dist(f2);
                  if (t3 > 2 * u2) {
                    const e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                    this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                  }
                }
              }
            }
            addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
              const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
              this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Ko / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
            }
            addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
              const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Ko - 1) : this.scaledDistance);
              this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
              const u2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
            }
            updateScaledDistance() {
              this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t2, e2) {
              this.distance += t2.dist(e2), this.updateScaledDistance();
            }
          }
          Sn("LineBucket", Zo, { omit: ["layers", "patternFeatures"] });
          const Go = new hi({ "line-cap": new ai(nt.layout_line["line-cap"]), "line-join": new oi(nt.layout_line["line-join"]), "line-miter-limit": new ai(nt.layout_line["line-miter-limit"]), "line-round-limit": new ai(nt.layout_line["line-round-limit"]), "line-sort-key": new oi(nt.layout_line["line-sort-key"]) });
          var Jo = { paint: new hi({ "line-opacity": new oi(nt.paint_line["line-opacity"]), "line-color": new oi(nt.paint_line["line-color"]), "line-translate": new ai(nt.paint_line["line-translate"]), "line-translate-anchor": new ai(nt.paint_line["line-translate-anchor"]), "line-width": new oi(nt.paint_line["line-width"]), "line-gap-width": new oi(nt.paint_line["line-gap-width"]), "line-offset": new oi(nt.paint_line["line-offset"]), "line-blur": new oi(nt.paint_line["line-blur"]), "line-dasharray": new ui(nt.paint_line["line-dasharray"]), "line-pattern": new li(nt.paint_line["line-pattern"]), "line-gradient": new ci(nt.paint_line["line-gradient"]) }), layout: Go };
          const Xo = new class extends oi {
            possiblyEvaluate(t2, e2) {
              return e2 = new Hn(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
            }
            evaluate(t2, e2, r2, n2) {
              return e2 = o({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
            }
          }(Jo.paint.properties["line-width"].specification);
          function Yo(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          Xo.useIntegerZoom = true;
          const Ho = gi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Wo = gi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          gi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const Qo = gi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
          gi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const tl = gi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), el = gi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function rl(t2, e2, r2) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e3, r3) {
                const n2 = e3.layout.get("text-transform").evaluate(r3, {});
                return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), Yn.applyArabicShaping && (t4 = Yn.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r2);
            }), t2;
          }
          gi([{ name: "triangle", components: 3, type: "Uint16" }]), gi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), gi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), gi([{ type: "Float32", name: "offsetX" }]), gi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
          const nl = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          var il = 24, sl = ll, al = function(t2, e2, r2, n2, i2) {
            var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
            for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
              ;
            for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
              ;
            if (s2 === 0)
              s2 = 1 - u2;
            else {
              if (s2 === l2)
                return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
              a2 += Math.pow(2, n2), s2 -= u2;
            }
            return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
          }, ol = function(t2, e2, r2, n2, i2, s2) {
            var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
            for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
              ;
            for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
              ;
            t2[r2 + f2 - d2] |= 128 * y2;
          };
          function ll(t2) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          ll.Varint = 0, ll.Fixed64 = 1, ll.Bytes = 2, ll.Fixed32 = 5;
          var ul, cl = 4294967296, hl = 1 / cl, pl = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");
          function fl(t2) {
            return t2.type === ll.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
          }
          function dl(t2, e2, r2) {
            return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
          }
          function yl(t2, e2, r2) {
            var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
            r2.realloc(n2);
            for (var i2 = r2.pos - 1; i2 >= t2; i2--)
              r2.buf[i2 + n2] = r2.buf[i2];
          }
          function ml(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeVarint(t2[r2]);
          }
          function gl(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSVarint(t2[r2]);
          }
          function xl(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFloat(t2[r2]);
          }
          function vl(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeDouble(t2[r2]);
          }
          function bl(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeBoolean(t2[r2]);
          }
          function wl(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFixed32(t2[r2]);
          }
          function _l(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSFixed32(t2[r2]);
          }
          function Al(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFixed64(t2[r2]);
          }
          function kl(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSFixed64(t2[r2]);
          }
          function Sl(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
          }
          function zl(t2, e2, r2) {
            t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
          }
          function Il(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
          }
          function Ml(t2, e2, r2) {
            t2 === 1 && r2.readMessage(Bl, e2);
          }
          function Bl(t2, e2, r2) {
            if (t2 === 3) {
              const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(Cl, {});
              e2.push({ id: t3, bitmap: new Aa({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
            }
          }
          function Cl(t2, e2, r2) {
            t2 === 1 ? e2.id = r2.readVarint() : t2 === 2 ? e2.bitmap = r2.readBytes() : t2 === 3 ? e2.width = r2.readVarint() : t2 === 4 ? e2.height = r2.readVarint() : t2 === 5 ? e2.left = r2.readSVarint() : t2 === 6 ? e2.top = r2.readSVarint() : t2 === 7 && (e2.advance = r2.readVarint());
          }
          function Pl(t2) {
            let e2 = 0, r2 = 0;
            for (const n3 of t2)
              e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
            t2.sort((t3, e3) => e3.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
            let i2 = 0, s2 = 0;
            for (const e3 of t2)
              for (let t3 = n2.length - 1; t3 >= 0; t3--) {
                const r3 = n2[t3];
                if (!(e3.w > r3.w || e3.h > r3.h)) {
                  if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                    const e4 = n2.pop();
                    t3 < n2.length && (n2[t3] = e4);
                  } else
                    e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                  break;
                }
              }
            return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
          }
          ll.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t2, e2, r2) {
            for (r2 = r2 || this.length; this.pos < r2; ) {
              var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
              this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
            }
            return e2;
          }, readMessage: function(t2, e2) {
            return this.readFields(t2, e2, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t2 = Sl(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readSFixed32: function() {
            var t2 = Il(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readFixed64: function() {
            var t2 = Sl(this.buf, this.pos) + Sl(this.buf, this.pos + 4) * cl;
            return this.pos += 8, t2;
          }, readSFixed64: function() {
            var t2 = Sl(this.buf, this.pos) + Il(this.buf, this.pos + 4) * cl;
            return this.pos += 8, t2;
          }, readFloat: function() {
            var t2 = al(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t2;
          }, readDouble: function() {
            var t2 = al(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t2;
          }, readVarint: function(t2) {
            var e2, r2, n2 = this.buf;
            return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
              var n3, i2, s2 = r3.buf;
              if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
                return dl(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
                return dl(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
                return dl(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
                return dl(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
                return dl(t3, n3, e3);
              if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
                return dl(t3, n3, e3);
              throw new Error("Expected varint not more than 10 bytes");
            }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.pos;
            return this.pos = t2, t2 - e2 >= 12 && pl ? function(t3, e3, r2) {
              return pl.decode(t3.subarray(e3, r2));
            }(this.buf, e2, t2) : function(t3, e3, r2) {
              for (var n2 = "", i2 = e3; i2 < r2; ) {
                var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
                if (i2 + c2 > r2)
                  break;
                c2 === 1 ? l2 < 128 && (u2 = l2) : c2 === 2 ? (192 & (s2 = t3[i2 + 1])) == 128 && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : c2 === 3 ? (a2 = t3[i2 + 2], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : c2 === 4 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), u2 === null ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
              }
              return n2;
            }(this.buf, e2, t2);
          }, readBytes: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e2;
          }, readPackedVarint: function(t2, e2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readVarint(e2));
            var r2 = fl(this);
            for (t2 = t2 || []; this.pos < r2; )
              t2.push(this.readVarint(e2));
            return t2;
          }, readPackedSVarint: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readSVarint());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSVarint());
            return t2;
          }, readPackedBoolean: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readBoolean());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readBoolean());
            return t2;
          }, readPackedFloat: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readFloat());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFloat());
            return t2;
          }, readPackedDouble: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readDouble());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readDouble());
            return t2;
          }, readPackedFixed32: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readFixed32());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed32());
            return t2;
          }, readPackedSFixed32: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readSFixed32());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed32());
            return t2;
          }, readPackedFixed64: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readFixed64());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed64());
            return t2;
          }, readPackedSFixed64: function(t2) {
            if (this.type !== ll.Bytes)
              return t2.push(this.readSFixed64());
            var e2 = fl(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed64());
            return t2;
          }, skip: function(t2) {
            var e2 = 7 & t2;
            if (e2 === ll.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e2 === ll.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e2 === ll.Fixed32)
              this.pos += 4;
            else {
              if (e2 !== ll.Fixed64)
                throw new Error("Unimplemented type: " + e2);
              this.pos += 8;
            }
          }, writeTag: function(t2, e2) {
            this.writeVarint(t2 << 3 | e2);
          }, realloc: function(t2) {
            for (var e2 = this.length || 16; e2 < this.pos + t2; )
              e2 *= 2;
            if (e2 !== this.length) {
              var r2 = new Uint8Array(e2);
              r2.set(this.buf), this.buf = r2, this.length = e2;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t2) {
            this.realloc(4), zl(this.buf, t2, this.pos), this.pos += 4;
          }, writeSFixed32: function(t2) {
            this.realloc(4), zl(this.buf, t2, this.pos), this.pos += 4;
          }, writeFixed64: function(t2) {
            this.realloc(8), zl(this.buf, -1 & t2, this.pos), zl(this.buf, Math.floor(t2 * hl), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t2) {
            this.realloc(8), zl(this.buf, -1 & t2, this.pos), zl(this.buf, Math.floor(t2 * hl), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
              var r2, n2;
              if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e2.realloc(10), function(t4, e3, r3) {
                r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
              }(r2, 0, e2), function(t4, e3) {
                var r3 = (7 & t4) << 4;
                e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
              }(n2, e2);
            }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }, writeSVarint: function(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }, writeBoolean: function(t2) {
            this.writeVarint(Boolean(t2));
          }, writeString: function(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            var e2 = this.pos;
            this.pos = function(t3, e3, r3) {
              for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
                if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else
                  i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
                n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
              }
              return r3;
            }(this.buf, t2, this.pos);
            var r2 = this.pos - e2;
            r2 >= 128 && yl(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
          }, writeFloat: function(t2) {
            this.realloc(4), ol(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t2) {
            this.realloc(8), ol(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t2) {
            var e2 = t2.length;
            this.writeVarint(e2), this.realloc(e2);
            for (var r2 = 0; r2 < e2; r2++)
              this.buf[this.pos++] = t2[r2];
          }, writeRawMessage: function(t2, e2) {
            this.pos++;
            var r2 = this.pos;
            t2(e2, this);
            var n2 = this.pos - r2;
            n2 >= 128 && yl(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
          }, writeMessage: function(t2, e2, r2) {
            this.writeTag(t2, ll.Bytes), this.writeRawMessage(e2, r2);
          }, writePackedVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, ml, e2);
          }, writePackedSVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, gl, e2);
          }, writePackedBoolean: function(t2, e2) {
            e2.length && this.writeMessage(t2, bl, e2);
          }, writePackedFloat: function(t2, e2) {
            e2.length && this.writeMessage(t2, xl, e2);
          }, writePackedDouble: function(t2, e2) {
            e2.length && this.writeMessage(t2, vl, e2);
          }, writePackedFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, wl, e2);
          }, writePackedSFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, _l, e2);
          }, writePackedFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, Al, e2);
          }, writePackedSFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, kl, e2);
          }, writeBytesField: function(t2, e2) {
            this.writeTag(t2, ll.Bytes), this.writeBytes(e2);
          }, writeFixed32Field: function(t2, e2) {
            this.writeTag(t2, ll.Fixed32), this.writeFixed32(e2);
          }, writeSFixed32Field: function(t2, e2) {
            this.writeTag(t2, ll.Fixed32), this.writeSFixed32(e2);
          }, writeFixed64Field: function(t2, e2) {
            this.writeTag(t2, ll.Fixed64), this.writeFixed64(e2);
          }, writeSFixed64Field: function(t2, e2) {
            this.writeTag(t2, ll.Fixed64), this.writeSFixed64(e2);
          }, writeVarintField: function(t2, e2) {
            this.writeTag(t2, ll.Varint), this.writeVarint(e2);
          }, writeSVarintField: function(t2, e2) {
            this.writeTag(t2, ll.Varint), this.writeSVarint(e2);
          }, writeStringField: function(t2, e2) {
            this.writeTag(t2, ll.Bytes), this.writeString(e2);
          }, writeFloatField: function(t2, e2) {
            this.writeTag(t2, ll.Fixed32), this.writeFloat(e2);
          }, writeDoubleField: function(t2, e2) {
            this.writeTag(t2, ll.Fixed64), this.writeDouble(e2);
          }, writeBooleanField: function(t2, e2) {
            this.writeVarintField(t2, Boolean(e2));
          } };
          class Vl {
            constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
              this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
            }
            get tl() {
              return [this.paddedRect.x + 1, this.paddedRect.y + 1];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
            }
            get tlbr() {
              return this.tl.concat(this.br);
            }
            get displaySize() {
              return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
            }
          }
          class El {
            constructor(t2, e2) {
              const r2 = {}, n2 = {};
              this.haveRenderCallbacks = [];
              const i2 = [];
              this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
              const { w: s2, h: a2 } = Pl(i2), o2 = new ka({ width: s2 || 1, height: a2 || 1 });
              for (const e3 in t2) {
                const n3 = t2[e3], i3 = r2[e3].paddedRect;
                ka.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
              }
              for (const t3 in e2) {
                const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
                ka.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), ka.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), ka.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), ka.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), ka.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
              }
              this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
            }
            addImages(t2, e2, r2) {
              for (const n2 in t2) {
                const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
                r2.push(s2), e2[n2] = new Vl(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
              }
            }
            patchUpdatedImages(t2, e2) {
              t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r2 in t2.updatedImages)
                this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
            }
            patchUpdatedImage(t2, e2, r2) {
              if (!t2 || !e2)
                return;
              if (t2.version === e2.version)
                return;
              t2.version = e2.version;
              const [n2, i2] = t2.tl;
              r2.update(e2.data, void 0, { x: n2, y: i2 });
            }
          }
          Sn("ImagePosition", Vl), Sn("ImageAtlas", El), t.WritingMode = void 0, (ul = t.WritingMode || (t.WritingMode = {}))[ul.none = 0] = "none", ul[ul.horizontal = 1] = "horizontal", ul[ul.vertical = 2] = "vertical", ul[ul.horizontalOnly = 3] = "horizontalOnly";
          const Fl = -17;
          class Tl {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t2, e2) {
              const r2 = new Tl();
              return r2.scale = t2 || 1, r2.fontStack = e2, r2;
            }
            static forImage(t2) {
              const e2 = new Tl();
              return e2.imageName = t2, e2;
            }
          }
          class Ll {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e2) {
              const r2 = new Ll();
              for (let n2 = 0; n2 < t2.sections.length; n2++) {
                const i2 = t2.sections[n2];
                i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
              }
              return r2;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCharCode(t2) {
              return this.text.charCodeAt(t2);
            }
            verticalizePunctuation() {
              this.text = function(t2) {
                let e2 = "";
                for (let r2 = 0; r2 < t2.length; r2++) {
                  const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                  e2 += n2 && Tn(n2) && !nl[t2[r2 + 1]] || i2 && Tn(i2) && !nl[t2[r2 - 1]] || !nl[t2[r2]] ? t2[r2] : nl[t2[r2]];
                }
                return e2;
              }(this.text);
            }
            trim() {
              let t2 = 0;
              for (let e3 = 0; e3 < this.text.length && $l[this.text.charCodeAt(e3)]; e3++)
                t2++;
              let e2 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && $l[this.text.charCodeAt(r2)]; r2--)
                e2--;
              this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
            }
            substring(t2, e2) {
              const r2 = new Ll();
              return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
            }
            addTextSection(t2, e2) {
              this.text += t2.text, this.sections.push(Tl.forText(t2.scale, t2.fontStack || e2));
              const r2 = this.sections.length - 1;
              for (let e3 = 0; e3 < t2.text.length; ++e3)
                this.sectionIndex.push(r2);
            }
            addImageSection(t2) {
              const e2 = t2.image ? t2.image.name : "";
              if (e2.length === 0)
                return void d("Can't add FormattedSection with an empty image.");
              const r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Tl.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : d("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function Dl(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
            const g2 = Ll.fromFeature(e2, s2);
            let x2;
            p2 === t.WritingMode.vertical && g2.verticalizePunctuation();
            const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Yn;
            if (v2 && g2.sections.length === 1) {
              x2 = [];
              const t2 = v2(g2.toString(), Kl(g2, c2, a2, r2, i2, d2, y2));
              for (const e3 of t2) {
                const t3 = new Ll();
                t3.text = e3, t3.sections = g2.sections;
                for (let r3 = 0; r3 < e3.length; r3++)
                  t3.sectionIndex.push(0);
                x2.push(t3);
              }
            } else if (b2) {
              x2 = [];
              const t2 = b2(g2.text, g2.sectionIndex, Kl(g2, c2, a2, r2, i2, d2, y2));
              for (const e3 of t2) {
                const t3 = new Ll();
                t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = g2.sections, x2.push(t3);
              }
            } else
              x2 = function(t2, e3) {
                const r3 = [], n3 = t2.text;
                let i3 = 0;
                for (const n4 of e3)
                  r3.push(t2.substring(i3, n4)), i3 = n4;
                return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
              }(g2, Kl(g2, c2, a2, r2, i2, d2, y2));
            const w2 = [], _2 = { positionedLines: w2, text: g2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
            return function(e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3, p3) {
              let f3 = 0, d3 = Fl, y3 = 0, m3 = 0;
              const g3 = l3 === "right" ? 1 : l3 === "left" ? 0 : 0.5;
              let x3 = 0;
              for (const o4 of s3) {
                o4.trim();
                const s4 = o4.getMaxScale(), l4 = (s4 - 1) * il, b4 = { positionedGlyphs: [], lineOffset: 0 };
                e3.positionedLines[x3] = b4;
                const w4 = b4.positionedGlyphs;
                let _4 = 0;
                if (!o4.length()) {
                  d3 += a3, ++x3;
                  continue;
                }
                for (let a4 = 0; a4 < o4.length(); a4++) {
                  const y4 = o4.getSection(a4), m4 = o4.getSectionIndex(a4), g4 = o4.getCharCode(a4);
                  let x4 = 0, b5 = null, A3 = null, k2 = null, S2 = il;
                  const z2 = !(u3 === t.WritingMode.horizontal || !h3 && !Fn(g4) || h3 && ($l[g4] || (v3 = g4, Cn.Arabic(v3) || Cn["Arabic Supplement"](v3) || Cn["Arabic Extended-A"](v3) || Cn["Arabic Presentation Forms-A"](v3) || Cn["Arabic Presentation Forms-B"](v3))));
                  if (y4.imageName) {
                    const t2 = i3[y4.imageName];
                    if (!t2)
                      continue;
                    k2 = y4.imageName, e3.iconsInText = e3.iconsInText || true, A3 = t2.paddedRect;
                    const r4 = t2.displaySize;
                    y4.scale = y4.scale * il / p3, b5 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: z2 ? r4[1] : r4[0] }, x4 = l4 + (il - r4[1] * y4.scale), S2 = b5.advance;
                    const n4 = z2 ? r4[0] * y4.scale - il * s4 : r4[1] * y4.scale - il * s4;
                    n4 > 0 && n4 > _4 && (_4 = n4);
                  } else {
                    const t2 = n3[y4.fontStack], e4 = t2 && t2[g4];
                    if (e4 && e4.rect)
                      A3 = e4.rect, b5 = e4.metrics;
                    else {
                      const t3 = r3[y4.fontStack], e5 = t3 && t3[g4];
                      if (!e5)
                        continue;
                      b5 = e5.metrics;
                    }
                    x4 = (s4 - y4.scale) * il;
                  }
                  z2 ? (e3.verticalizable = true, w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x4, vertical: z2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += S2 * y4.scale + c3) : (w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x4, vertical: z2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += b5.advance * y4.scale + c3);
                }
                w4.length !== 0 && (y3 = Math.max(f3 - c3, y3), Gl(w4, 0, w4.length - 1, g3, _4)), f3 = 0;
                const A2 = a3 * s4 + _4;
                b4.lineOffset = Math.max(_4, l4), d3 += A2, m3 = Math.max(A2, m3), ++x3;
              }
              var v3;
              const b3 = d3 - Fl, { horizontalAlign: w3, verticalAlign: _3 } = Zl(o3);
              (function(t2, e4, r4, n4, i4, s4, a4, o4, l4) {
                const u4 = (e4 - r4) * i4;
                let c4 = 0;
                c4 = s4 !== a4 ? -o4 * n4 - Fl : (-n4 * l4 + 0.5) * a4;
                for (const e5 of t2)
                  for (const t3 of e5.positionedGlyphs)
                    t3.x += u4, t3.y += c4;
              })(e3.positionedLines, g3, w3, _3, y3, m3, a3, b3, s3.length), e3.top += -_3 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y3, e3.right = e3.left + y3;
            }(_2, r2, n2, i2, x2, o2, l2, u2, p2, c2, f2, m2), !function(t2) {
              for (const e3 of t2)
                if (e3.positionedGlyphs.length !== 0)
                  return false;
              return true;
            }(w2) && _2;
          }
          const $l = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Rl = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function Ul(t2, e2, r2, n2, i2, s2) {
            if (e2.imageName) {
              const t3 = n2[e2.imageName];
              return t3 ? t3.displaySize[0] * e2.scale * il / s2 + i2 : 0;
            }
            {
              const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
              return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
            }
          }
          function Ol(t2, e2, r2, n2) {
            const i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function ql(t2, e2, r2) {
            let n2 = 0;
            return t2 === 10 && (n2 -= 1e4), r2 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
          }
          function jl(t2, e2, r2, n2, i2, s2) {
            let a2 = null, o2 = Ol(e2, r2, i2, s2);
            for (const t3 of n2) {
              const n3 = Ol(e2 - t3.x, r2, i2, s2) + t3.badness;
              n3 <= o2 && (a2 = t3, o2 = n3);
            }
            return { index: t2, x: e2, priorBreak: a2, badness: o2 };
          }
          function Nl(t2) {
            return t2 ? Nl(t2.priorBreak).concat(t2.index) : [];
          }
          function Kl(t2, e2, r2, n2, i2, s2, a2) {
            if (s2 !== "point")
              return [];
            if (!t2)
              return [];
            const o2 = [], l2 = function(t3, e3, r3, n3, i3, s3) {
              let a3 = 0;
              for (let r4 = 0; r4 < t3.length(); r4++) {
                const o3 = t3.getSection(r4);
                a3 += Ul(t3.getCharCode(r4), o3, n3, i3, e3, s3);
              }
              return a3 / Math.max(1, Math.ceil(a3 / r3));
            }(t2, e2, r2, n2, i2, a2), u2 = t2.text.indexOf("\u200B") >= 0;
            let c2 = 0;
            for (let r3 = 0; r3 < t2.length(); r3++) {
              const s3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
              if ($l[p2] || (c2 += Ul(p2, s3, n2, i2, e2, a2)), r3 < t2.length() - 1) {
                const e3 = !((h2 = p2) < 11904 || !(Cn["Bopomofo Extended"](h2) || Cn.Bopomofo(h2) || Cn["CJK Compatibility Forms"](h2) || Cn["CJK Compatibility Ideographs"](h2) || Cn["CJK Compatibility"](h2) || Cn["CJK Radicals Supplement"](h2) || Cn["CJK Strokes"](h2) || Cn["CJK Symbols and Punctuation"](h2) || Cn["CJK Unified Ideographs Extension A"](h2) || Cn["CJK Unified Ideographs"](h2) || Cn["Enclosed CJK Letters and Months"](h2) || Cn["Halfwidth and Fullwidth Forms"](h2) || Cn.Hiragana(h2) || Cn["Ideographic Description Characters"](h2) || Cn["Kangxi Radicals"](h2) || Cn["Katakana Phonetic Extensions"](h2) || Cn.Katakana(h2) || Cn["Vertical Forms"](h2) || Cn["Yi Radicals"](h2) || Cn["Yi Syllables"](h2)));
                (Rl[p2] || e3 || s3.imageName) && o2.push(jl(r3 + 1, c2, l2, o2, ql(p2, t2.getCharCode(r3 + 1), e3 && u2), false));
              }
            }
            var h2;
            return Nl(jl(t2.length(), c2, l2, o2, 0, true));
          }
          function Zl(t2) {
            let e2 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r2 };
          }
          function Gl(t2, e2, r2, n2, i2) {
            if (!n2 && !i2)
              return;
            const s2 = t2[r2], a2 = (t2[r2].x + s2.metrics.advance * s2.scale) * n2;
            for (let n3 = e2; n3 <= r2; n3++)
              t2[n3].x -= a2, t2[n3].y += i2;
          }
          function Jl(t2, e2, r2) {
            const { horizontalAlign: n2, verticalAlign: i2 } = Zl(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
            return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
          }
          function Xl(t2, e2, r2, n2, i2, s2) {
            const a2 = t2.image;
            let o2;
            if (a2.content) {
              const t3 = a2.content, e3 = a2.pixelRatio || 1;
              o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
            }
            const l2 = e2.left * s2, u2 = e2.right * s2;
            let c2, h2, p2, f2;
            r2 === "width" || r2 === "both" ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
            const d2 = e2.top * s2, y2 = e2.bottom * s2;
            return r2 === "height" || r2 === "both" ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
          }
          const Yl = 128;
          function Hl(t2, e2) {
            const { expression: r2 } = e2;
            if (r2.kind === "constant")
              return { kind: "constant", layoutSize: r2.evaluate(new Hn(t2 + 1)) };
            if (r2.kind === "source")
              return { kind: "source" };
            {
              const { zoomStops: e3, interpolationType: n2 } = r2;
              let i2 = 0;
              for (; i2 < e3.length && e3[i2] <= t2; )
                i2++;
              i2 = Math.max(0, i2 - 1);
              let s2 = i2;
              for (; s2 < e3.length && e3[s2] < t2 + 1; )
                s2++;
              s2 = Math.min(e3.length - 1, s2);
              const a2 = e3[i2], o2 = e3[s2];
              return r2.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Hn(a2)), maxSize: r2.evaluate(new Hn(o2)), interpolationType: n2 };
            }
          }
          class Wl extends S {
            constructor(t2, e2, r2, n2) {
              super(t2, e2), this.angle = r2, n2 !== void 0 && (this.segment = n2);
            }
            clone() {
              return new Wl(this.x, this.y, this.angle, this.segment);
            }
          }
          function Ql(t2, e2, r2, n2, i2) {
            if (e2.segment === void 0)
              return true;
            let s2 = e2, a2 = e2.segment + 1, o2 = 0;
            for (; o2 > -r2 / 2; ) {
              if (a2--, a2 < 0)
                return false;
              o2 -= t2[a2].dist(s2), s2 = t2[a2];
            }
            o2 += t2[a2].dist(t2[a2 + 1]), a2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r2 / 2; ) {
              const e3 = t2[a2], r3 = t2[a2 + 1];
              if (!r3)
                return false;
              let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
              for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
                u2 -= l2.shift().angleDelta;
              if (u2 > i2)
                return false;
              a2++, o2 += e3.dist(r3);
            }
            return true;
          }
          function tu(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++)
              e2 += t2[r2].dist(t2[r2 + 1]);
            return e2;
          }
          function eu(t2, e2, r2) {
            return t2 ? 0.6 * e2 * r2 : 0;
          }
          function ru(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function nu(t2, e2, r2, n2, i2, s2) {
            const a2 = eu(r2, i2, s2), o2 = ru(r2, n2) * s2;
            let l2 = 0;
            const u2 = tu(t2) / 2;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
              if (l2 + s3 > u2) {
                const c2 = (u2 - l2) / s3, h2 = Se(n3.x, i3.x, c2), p2 = Se(n3.y, i3.y, c2), f2 = new Wl(h2, p2, i3.angleTo(n3), r3);
                return f2._round(), !a2 || Ql(t2, f2, o2, a2, e2) ? f2 : void 0;
              }
              l2 += s3;
            }
          }
          function iu(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = eu(n2, s2, a2), c2 = ru(n2, i2), h2 = c2 * a2, p2 = t2[0].x === 0 || t2[0].x === l2 || t2[0].y === 0 || t2[0].y === l2;
            return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), su(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
          }
          function su(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = s2 / 2, c2 = tu(t2);
            let h2 = 0, p2 = e2 - r2, f2 = [];
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
              for (; p2 + r2 < h2 + d2; ) {
                p2 += r2;
                const m2 = (p2 - h2) / d2, g2 = Se(a3.x, o3.x, m2), x2 = Se(a3.y, o3.y, m2);
                if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                  const r3 = new Wl(g2, x2, y2, e3);
                  r3._round(), n2 && !Ql(t2, r3, s2, n2, i2) || f2.push(r3);
                }
              }
              h2 += d2;
            }
            return o2 || f2.length || a2 || (f2 = su(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
          }
          function au(t2, e2, r2, n2, i2) {
            const s2 = [];
            for (let a2 = 0; a2 < t2.length; a2++) {
              const o2 = t2[a2];
              let l2;
              for (let t3 = 0; t3 < o2.length - 1; t3++) {
                let a3 = o2[t3], u2 = o2[t3 + 1];
                a3.x < e2 && u2.x < e2 || (a3.x < e2 ? a3 = new S(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e2 && (u2 = new S(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r2 && u2.y < r2 || (a3.y < r2 ? a3 = new S(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round() : u2.y < r2 && (u2 = new S(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new S(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new S(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new S(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new S(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
              }
            }
            return s2;
          }
          function ou(t2, e2, r2, n2) {
            const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2, l2 = s2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = o2 - d2, g2 = l2 - y2;
            let x2 = 0, v2 = d2, b2 = 0, w2 = y2, _2 = 0, A2 = m2, k2 = 0, z2 = g2;
            if (s2.content && n2) {
              const t3 = s2.content;
              x2 = lu(h2, 0, t3[0]), b2 = lu(p2, 0, t3[1]), v2 = lu(h2, t3[0], t3[2]), w2 = lu(p2, t3[1], t3[3]), _2 = t3[0] - x2, k2 = t3[1] - b2, A2 = t3[2] - t3[0] - v2, z2 = t3[3] - t3[1] - w2;
            }
            const I2 = (n3, i3, o3, l3) => {
              const h3 = cu(n3.stretch - x2, v2, u2, t2.left), p3 = hu(n3.fixed - _2, A2, n3.stretch, d2), f3 = cu(i3.stretch - b2, w2, c2, t2.top), m3 = hu(i3.fixed - k2, z2, i3.stretch, y2), g3 = cu(o3.stretch - x2, v2, u2, t2.left), I3 = hu(o3.fixed - _2, A2, o3.stretch, d2), M2 = cu(l3.stretch - b2, w2, c2, t2.top), B2 = hu(l3.fixed - k2, z2, l3.stretch, y2), C2 = new S(h3, f3), P2 = new S(g3, f3), V2 = new S(g3, M2), E2 = new S(h3, M2), F2 = new S(p3 / a2, m3 / a2), T2 = new S(I3 / a2, B2 / a2), L2 = e2 * Math.PI / 180;
              if (L2) {
                const t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
                C2._matMult(r3), P2._matMult(r3), E2._matMult(r3), V2._matMult(r3);
              }
              const D2 = n3.stretch + n3.fixed, $2 = i3.stretch + i3.fixed;
              return { tl: C2, tr: P2, bl: E2, br: V2, tex: { x: s2.paddedRect.x + 1 + D2, y: s2.paddedRect.y + 1 + $2, w: o3.stretch + o3.fixed - D2, h: l3.stretch + l3.fixed - $2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T2, minFontScaleX: A2 / a2 / u2, minFontScaleY: z2 / a2 / c2, isSDF: r2 };
            };
            if (n2 && (s2.stretchX || s2.stretchY)) {
              const t3 = uu(h2, m2, d2), e3 = uu(p2, g2, y2);
              for (let r3 = 0; r3 < t3.length - 1; r3++) {
                const n3 = t3[r3], s3 = t3[r3 + 1];
                for (let t4 = 0; t4 < e3.length - 1; t4++)
                  i2.push(I2(n3, e3[t4], s3, e3[t4 + 1]));
              }
            } else
              i2.push(I2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
            return i2;
          }
          function lu(t2, e2, r2) {
            let n2 = 0;
            for (const i2 of t2)
              n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
            return n2;
          }
          function uu(t2, e2, r2) {
            const n2 = [{ fixed: -1, stretch: 0 }];
            for (const [e3, r3] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
            }
            return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
          }
          function cu(t2, e2, r2, n2) {
            return t2 / e2 * r2 + n2;
          }
          function hu(t2, e2, r2, n2) {
            return t2 - e2 * r2 / n2;
          }
          Sn("Anchor", Wl);
          class pu {
            constructor(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              if (this.boxStartIndex = t2.length, l2) {
                let t3 = s2.top, e3 = s2.bottom;
                const r3 = s2.collisionPadding;
                r3 && (t3 -= r3[1], e3 += r3[3]);
                let n3 = e3 - t3;
                n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
              } else {
                let l3 = s2.top * a2 - o2, c2 = s2.bottom * a2 + o2, h2 = s2.left * a2 - o2, p2 = s2.right * a2 + o2;
                const f2 = s2.collisionPadding;
                if (f2 && (h2 -= f2[0] * a2, l3 -= f2[1] * a2, p2 += f2[2] * a2, c2 += f2[3] * a2), u2) {
                  const t3 = new S(h2, l3), e3 = new S(p2, l3), r3 = new S(h2, c2), n3 = new S(p2, c2), i3 = u2 * Math.PI / 180;
                  t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), h2 = Math.min(t3.x, e3.x, r3.x, n3.x), p2 = Math.max(t3.x, e3.x, r3.x, n3.x), l3 = Math.min(t3.y, e3.y, r3.y, n3.y), c2 = Math.max(t3.y, e3.y, r3.y, n3.y);
                }
                t2.emplaceBack(e2.x, e2.y, h2, l3, p2, c2, r2, n2, i2);
              }
              this.boxEndIndex = t2.length;
            }
          }
          class fu {
            constructor(t2 = [], e2 = du) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
                for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                  this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this.length++, this._up(this.length - 1);
            }
            pop() {
              if (this.length === 0)
                return;
              const t2 = this.data[0], e2 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r2 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r2(n2, s2) >= 0)
                  break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1), s2 = e2[n3];
                const a2 = n3 + 1;
                if (a2 < this.length && r2(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r2(s2, i2) >= 0)
                  break;
                e2[t2] = s2, t2 = n3;
              }
              e2[t2] = i2;
            }
          }
          function du(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function yu(t2, e2 = 1, r2 = false) {
            let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
            const o2 = t2[0];
            for (let t3 = 0; t3 < o2.length; t3++) {
              const e3 = o2[t3];
              (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
            }
            const l2 = Math.min(s2 - n2, a2 - i2);
            let u2 = l2 / 2;
            const c2 = new fu([], mu);
            if (l2 === 0)
              return new S(n2, i2);
            for (let e3 = n2; e3 < s2; e3 += l2)
              for (let r3 = i2; r3 < a2; r3 += l2)
                c2.push(new gu(e3 + u2, r3 + u2, u2, t2));
            let h2 = function(t3) {
              let e3 = 0, r3 = 0, n3 = 0;
              const i3 = t3[0];
              for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
                const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
                r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
              }
              return new gu(r3 / e3, n3 / e3, 0, t3);
            }(t2), p2 = c2.length;
            for (; c2.length; ) {
              const n3 = c2.pop();
              (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u2 = n3.h / 2, c2.push(new gu(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new gu(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new gu(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new gu(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
            }
            return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
          }
          function mu(t2, e2) {
            return e2.max - t2.max;
          }
          function gu(t2, e2, r2, n2) {
            this.p = new S(t2, e2), this.h = r2, this.d = function(t3, e3) {
              let r3 = false, n3 = 1 / 0;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const s2 = e3[i2];
                for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                  const i4 = s2[e4], o2 = s2[a2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, ea(t3, i4, o2));
                }
              }
              return (r3 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
          const xu = Number.POSITIVE_INFINITY;
          function vu(t2, e2) {
            return e2[1] !== xu ? function(t3, e3, r2) {
              let n2 = 0, i2 = 0;
              switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r2;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e3;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e3;
              }
              return [n2, i2];
            }(t2, e2[0], e2[1]) : function(t3, e3) {
              let r2 = 0, n2 = 0;
              e3 < 0 && (e3 = 0);
              const i2 = e3 / Math.sqrt(2);
              switch (t3) {
                case "top-right":
                case "top-left":
                  n2 = i2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n2 = 7 - i2;
                  break;
                case "bottom":
                  n2 = 7 - e3;
                  break;
                case "top":
                  n2 = e3 - 7;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                  r2 = -i2;
                  break;
                case "top-left":
                case "bottom-left":
                  r2 = i2;
                  break;
                case "left":
                  r2 = e3;
                  break;
                case "right":
                  r2 = -e3;
              }
              return [r2, n2];
            }(t2, e2[0]);
          }
          function bu(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function wu(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            let p2 = a2.textMaxSize.evaluate(r2, {});
            p2 === void 0 && (p2 = o2);
            const f2 = e2.layers[0].layout, y2 = f2.get("icon-offset").evaluate(r2, {}, h2), m2 = ku(n2.horizontal), g2 = o2 / 24, x2 = e2.tilePixelRatio * g2, v2 = e2.tilePixelRatio * p2 / 24, b2 = e2.tilePixelRatio * l2, w2 = e2.tilePixelRatio * f2.get("symbol-spacing"), _2 = f2.get("text-padding") * e2.tilePixelRatio, A2 = f2.get("icon-padding") * e2.tilePixelRatio, k2 = f2.get("text-max-angle") / 180 * Math.PI, S2 = f2.get("text-rotation-alignment") !== "viewport" && f2.get("symbol-placement") !== "point", z2 = f2.get("icon-rotation-alignment") === "map" && f2.get("symbol-placement") !== "point", I2 = f2.get("symbol-placement"), M2 = w2 / 2, B2 = f2.get("icon-text-fit");
            let C2;
            i2 && B2 !== "none" && (e2.allowVerticalPlacement && n2.vertical && (C2 = Xl(i2, n2.vertical, B2, f2.get("icon-text-fit-padding"), y2, g2)), m2 && (i2 = Xl(i2, m2, B2, f2.get("icon-text-fit-padding"), y2, g2)));
            const P2 = (l3, p3) => {
              p3.x < 0 || p3.x >= Os || p3.y < 0 || p3.y >= Os || function(e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3, p4, f3, y3, m3, g3, x3, v3, b3, w3, _3, A3, k3, S3, z3) {
                const I3 = e3.addToLineVertexArray(r3, n3);
                let M3, B3, C3, P3, V2 = 0, E2 = 0, F2 = 0, T2 = 0, L2 = -1, D2 = -1;
                const $2 = {};
                let R2 = ws(""), U2 = 0, O2 = 0;
                if (l4._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [U2, O2] = l4.layout.get("text-offset").evaluate(_3, {}, S3).map((t2) => t2 * il) : (U2 = l4.layout.get("text-radial-offset").evaluate(_3, {}, S3) * il, O2 = xu), e3.allowVerticalPlacement && i3.vertical) {
                  const t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3) + 90;
                  C3 = new pu(u3, r3, c3, h3, p4, i3.vertical, f3, y3, m3, t2), o3 && (P3 = new pu(u3, r3, c3, h3, p4, o3, x3, v3, m3, t2));
                }
                if (s3) {
                  const n4 = l4.layout.get("icon-rotate").evaluate(_3, {}), i4 = l4.layout.get("icon-text-fit") !== "none", a4 = ou(s3, n4, k3, i4), f4 = o3 ? ou(o3, n4, k3, i4) : void 0;
                  B3 = new pu(u3, r3, c3, h3, p4, s3, x3, v3, false, n4), V2 = 4 * a4.length;
                  const y4 = e3.iconSizeData;
                  let m4 = null;
                  y4.kind === "source" ? (m4 = [Yl * l4.layout.get("icon-size").evaluate(_3, {})], m4[0] > _u && d(`${e3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : y4.kind === "composite" && (m4 = [Yl * A3.compositeIconSizes[0].evaluate(_3, {}, S3), Yl * A3.compositeIconSizes[1].evaluate(_3, {}, S3)], (m4[0] > _u || m4[1] > _u) && d(`${e3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, m4, w3, b3, _3, t.WritingMode.none, r3, I3.lineStartIndex, I3.lineLength, -1, S3), L2 = e3.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e3.addSymbols(e3.icon, f4, m4, w3, b3, _3, t.WritingMode.vertical, r3, I3.lineStartIndex, I3.lineLength, -1, S3), D2 = e3.icon.placedSymbolArray.length - 1);
                }
                const q2 = Object.keys(i3.horizontal);
                for (const n4 of q2) {
                  const s4 = i3.horizontal[n4];
                  if (!M3) {
                    R2 = ws(s4.text);
                    const t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3);
                    M3 = new pu(u3, r3, c3, h3, p4, s4, f3, y3, m3, t2);
                  }
                  const o4 = s4.positionedLines.length === 1;
                  if (F2 += Au(e3, r3, s4, a3, l4, m3, _3, g3, I3, i3.vertical ? t.WritingMode.horizontal : t.WritingMode.horizontalOnly, o4 ? q2 : [n4], $2, L2, A3, S3), o4)
                    break;
                }
                i3.vertical && (T2 += Au(e3, r3, i3.vertical, a3, l4, m3, _3, g3, I3, t.WritingMode.vertical, ["vertical"], $2, D2, A3, S3));
                const j2 = M3 ? M3.boxStartIndex : e3.collisionBoxArray.length, N2 = M3 ? M3.boxEndIndex : e3.collisionBoxArray.length, K2 = C3 ? C3.boxStartIndex : e3.collisionBoxArray.length, Z2 = C3 ? C3.boxEndIndex : e3.collisionBoxArray.length, G2 = B3 ? B3.boxStartIndex : e3.collisionBoxArray.length, J2 = B3 ? B3.boxEndIndex : e3.collisionBoxArray.length, X2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, Y2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length;
                let H2 = -1;
                const W2 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
                H2 = W2(M3, H2), H2 = W2(C3, H2), H2 = W2(B3, H2), H2 = W2(P3, H2);
                const Q2 = H2 > -1 ? 1 : 0;
                Q2 && (H2 *= z3 / il), e3.glyphOffsetArray.length >= Eu.MAX_GLYPHS && d("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), _3.sortKey !== void 0 && e3.addToSortKeyRanges(e3.symbolInstances.length, _3.sortKey), e3.symbolInstances.emplaceBack(r3.x, r3.y, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical || -1, L2, D2, R2, j2, N2, K2, Z2, G2, J2, X2, Y2, c3, F2, T2, V2, E2, Q2, 0, f3, U2, O2, H2);
              }(e2, p3, l3, n2, i2, s2, C2, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, x2, _2, S2, u2, b2, A2, z2, y2, r2, a2, c2, h2, o2);
            };
            if (I2 === "line")
              for (const t2 of au(r2.geometry, 0, 0, Os, Os)) {
                const r3 = iu(t2, w2, k2, n2.vertical || m2, i2, 24, v2, e2.overscaling, Os);
                for (const n3 of r3) {
                  const r4 = m2;
                  r4 && Su(e2, r4.text, M2, n3) || P2(t2, n3);
                }
              }
            else if (I2 === "line-center") {
              for (const t2 of r2.geometry)
                if (t2.length > 1) {
                  const e3 = nu(t2, k2, n2.vertical || m2, i2, 24, v2);
                  e3 && P2(t2, e3);
                }
            } else if (r2.type === "Polygon")
              for (const t2 of oo(r2.geometry, 0)) {
                const e3 = yu(t2, 16);
                P2(t2[0], new Wl(e3.x, e3.y, 0));
              }
            else if (r2.type === "LineString")
              for (const t2 of r2.geometry)
                P2(t2, new Wl(t2[0].x, t2[0].y, 0));
            else if (r2.type === "Point")
              for (const t2 of r2.geometry)
                for (const e3 of t2)
                  P2([e3], new Wl(e3.x, e3.y, 0));
          }
          const _u = 32640;
          function Au(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, y2) {
            const m2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
              const l3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, u3 = [];
              for (const t4 of e3.positionedLines)
                for (const n4 of t4.positionedGlyphs) {
                  if (!n4.rect)
                    continue;
                  const s4 = n4.rect || {};
                  let c3 = 4, h3 = true, p3 = 1, f3 = 0;
                  const d2 = (i3 || o3) && n4.vertical, y3 = n4.metrics.advance * n4.scale / 2;
                  if (o3 && e3.verticalizable) {
                    const e4 = (n4.scale - 1) * il, r4 = (il - n4.metrics.width * n4.scale) / 2;
                    f3 = t4.lineOffset / 2 - (n4.imageName ? -r4 : e4);
                  }
                  if (n4.imageName) {
                    const t5 = a3[n4.imageName];
                    h3 = t5.sdf, p3 = t5.pixelRatio, c3 = 1 / p3;
                  }
                  const m3 = i3 ? [n4.x + y3, n4.y] : [0, 0];
                  let g3 = i3 ? [0, 0] : [n4.x + y3 + r3[0], n4.y + r3[1] - f3], x3 = [0, 0];
                  d2 && (x3 = g3, g3 = [0, 0]);
                  const v2 = (n4.metrics.left - c3) * n4.scale - y3 + g3[0], b2 = (-n4.metrics.top - c3) * n4.scale + g3[1], w2 = v2 + s4.w * n4.scale / p3, _2 = b2 + s4.h * n4.scale / p3, A2 = new S(v2, b2), k2 = new S(w2, b2), z2 = new S(v2, _2), I2 = new S(w2, _2);
                  if (d2) {
                    const t5 = new S(-y3, y3 - Fl), e4 = -Math.PI / 2, r4 = 12 - y3, i4 = new S(22 - r4, -(n4.imageName ? r4 : 0)), s5 = new S(...x3);
                    A2._rotateAround(e4, t5)._add(i4)._add(s5), k2._rotateAround(e4, t5)._add(i4)._add(s5), z2._rotateAround(e4, t5)._add(i4)._add(s5), I2._rotateAround(e4, t5)._add(i4)._add(s5);
                  }
                  if (l3) {
                    const t5 = Math.sin(l3), e4 = Math.cos(l3), r4 = [e4, -t5, t5, e4];
                    A2._matMult(r4), k2._matMult(r4), z2._matMult(r4), I2._matMult(r4);
                  }
                  const M2 = new S(0, 0), B2 = new S(0, 0);
                  u3.push({ tl: A2, tr: k2, bl: z2, br: I2, tex: s4, writingMode: e3.writingMode, glyphOffset: m3, sectionIndex: n4.sectionIndex, isSDF: h3, pixelOffsetTL: M2, pixelOffsetBR: B2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              return u3;
            }(0, r2, o2, i2, s2, a2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
            let x2 = null;
            g2.kind === "source" ? (x2 = [Yl * i2.layout.get("text-size").evaluate(a2, {})], x2[0] > _u && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : g2.kind === "composite" && (x2 = [Yl * f2.compositeTextSizes[0].evaluate(a2, {}, y2), Yl * f2.compositeTextSizes[1].evaluate(a2, {}, y2)], (x2[0] > _u || x2[1] > _u) && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, o2, s2, a2, u2, e2, l2.lineStartIndex, l2.lineLength, p2, y2);
            for (const e3 of c2)
              h2[e3] = t2.text.placedSymbolArray.length - 1;
            return 4 * m2.length;
          }
          function ku(t2) {
            for (const e2 in t2)
              return t2[e2];
            return null;
          }
          function Su(t2, e2, r2, n2) {
            const i2 = t2.compareText;
            if (e2 in i2) {
              const t3 = i2[e2];
              for (let e3 = t3.length - 1; e3 >= 0; e3--)
                if (n2.dist(t3[e3]) < r2)
                  return true;
            } else
              i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          const zu = xo.VectorTileFeature.types, Iu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function Mu(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = o2 ? Math.min(_u, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(_u, Math.round(o2[1])) : 0;
            t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
          }
          function Bu(t2, e2, r2) {
            t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
          }
          function Cu(t2) {
            for (const e2 of t2.sections)
              if ($n(e2.text))
                return true;
            return false;
          }
          class Pu {
            constructor(t2) {
              this.layoutVertexArray = new is(), this.indexArray = new us(), this.programConfigurations = t2, this.segments = new fs(), this.dynamicLayoutVertexArray = new ss(), this.opacityVertexArray = new as(), this.placedSymbolArray = new Ni();
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
            }
            upload(t2, e2, r2, n2) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ho.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Wo.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Iu, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          Sn("SymbolBuffers", Pu);
          class Vu {
            constructor(t2, e2, r2) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new fs(), this.collisionVertexArray = new ls();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Qo.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
          }
          Sn("CollisionBuffers", Vu);
          class Eu {
            constructor(e2) {
              this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = pa([]), this.placementViewportMatrix = pa([]);
              const r2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = Hl(this.zoom, r2["text-size"]), this.iconSizeData = Hl(this.zoom, r2["icon-size"]);
              const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
              this.canOverlap = $u(n2, "text-overlap", "text-allow-overlap") !== "never" || $u(n2, "icon-overlap", "icon-allow-overlap") !== "never" || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = s2 !== "viewport-y" && !i2.isConstant(), this.sortFeaturesByY = (s2 === "viewport-y" || s2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n2.get("symbol-placement") === "point" && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.WritingMode[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
            }
            createArrays() {
              this.text = new Pu(new $s(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Pu(new $s(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Gi(), this.lineVertexArray = new Ji(), this.symbolInstances = new Zi();
            }
            calculateGlyphDependencies(t2, e2, r2, n2, i2) {
              for (let s2 = 0; s2 < t2.length; s2++)
                if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
                  const r3 = nl[t2.charAt(s2)];
                  r3 && (e2[r3.charCodeAt(0)] = true);
                }
            }
            populate(e2, r2, n2) {
              const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = (o2.value.kind !== "constant" || o2.value.value instanceof Lt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && (a2.value.kind !== "constant" || a2.value.value.length > 0), c2 = l2.value.kind !== "constant" || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
              if (this.features = [], !u2 && !c2)
                return;
              const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new Hn(this.zoom);
              for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
                const e3 = i2._featureFilter.needGeometry, g2 = Ks(r3, e3);
                if (!i2._featureFilter.filter(y2, g2, n2))
                  continue;
                let x2, v2;
                if (e3 || (g2.geometry = Ns(r3)), u2) {
                  const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Lt.factory(t2);
                  Cu(e4) && (this.hasRTLText = true), (!this.hasRTLText || Jn() === "unavailable" || this.hasRTLText && Yn.isParsed()) && (x2 = rl(e4, i2, g2));
                }
                if (c2) {
                  const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                  v2 = t2 instanceof Dt ? t2 : Dt.fromString(t2);
                }
                if (!x2 && !v2)
                  continue;
                const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
                if (this.features.push({ id: o3, text: x2, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: zu[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
                  const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = s2.get("text-rotation-alignment") !== "viewport" && s2.get("symbol-placement") !== "point";
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.WritingMode.vertical) >= 0;
                  for (const t2 of x2.sections)
                    if (t2.image)
                      p2[t2.image.name] = true;
                    else {
                      const n3 = Pn(x2.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                      this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                    }
                }
              }
              s2.get("symbol-placement") === "line" && (this.features = function(t2) {
                const e3 = {}, r3 = {}, n3 = [];
                let i3 = 0;
                function s3(e4) {
                  n3.push(t2[e4]), i3++;
                }
                function a3(t3, e4, i4) {
                  const s4 = r3[t3];
                  return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
                }
                function o3(t3, r4, i4) {
                  const s4 = e3[r4];
                  return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
                }
                function l3(t3, e4, r4) {
                  const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return `${t3}:${n4.x}:${n4.y}`;
                }
                for (let u3 = 0; u3 < t2.length; u3++) {
                  const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    s3(u3);
                    continue;
                  }
                  const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                  if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                    const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                    delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                  } else
                    f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
                }
                return n3.filter((t3) => t3.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
            }
            isEmpty() {
              return this.symbolInstances.length === 0 && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e2) {
              const r2 = this.lineVertexArray.length;
              if (t2.segment !== void 0) {
                let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
                const i2 = {};
                for (let n3 = t2.segment + 1; n3 < e2.length; n3++)
                  i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
                for (let r4 = t2.segment || 0; r4 >= 0; r4--)
                  i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
                for (let t3 = 0; t3 < e2.length; t3++) {
                  const e3 = i2[t3];
                  this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const f2 = e2.indexArray, d2 = e2.layoutVertexArray, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.WritingMode.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
              for (let t2 = 0; t2 < r2.length; t2++) {
                const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], k2 = y2.vertexLength, S2 = w2[1];
                Mu(d2, l2.x, l2.y, i3.x, S2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), Mu(d2, l2.x, l2.y, s3.x, S2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), Mu(d2, l2.x, l2.y, o3.x, S2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), Mu(d2, l2.x, l2.y, u3.x, S2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), Bu(e2.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(k2, k2 + 1, k2 + 2), f2.emplaceBack(k2 + 1, k2 + 2, k2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A2]);
              }
              e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
            }
            _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
              return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
            }
            addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), l2 = o2.vertexLength, u2 = i2.layoutVertexArray, c2 = i2.collisionVertexArray, h2 = a2.anchorX, p2 = a2.anchorY;
              this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(t2, e2)), this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(r2, e2)), this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(r2, n2)), this._addCollisionDebugVertex(u2, c2, s2, h2, p2, new S(t2, n2)), o2.vertexLength += 4;
              const f2 = i2.indexArray;
              f2.emplaceBack(l2, l2 + 1), f2.emplaceBack(l2 + 1, l2 + 2), f2.emplaceBack(l2 + 2, l2 + 3), f2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t2, e2, r2, n2) {
              for (let i2 = t2; i2 < e2; i2++) {
                const t3 = this.collisionBoxArray.get(i2);
                this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
              }
            }
            generateCollisionDebugBuffers() {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Vu(os, tl.members, cs), this.iconCollisionBox = new Vu(os, tl.members, cs);
              for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
                const e2 = this.symbolInstances.get(t2);
                this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
              }
            }
            _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = {};
              for (let n3 = e2; n3 < r2; n3++) {
                const e3 = t2.get(n3);
                u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
                break;
              }
              for (let e3 = n2; e3 < i2; e3++) {
                const r3 = t2.get(e3);
                u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e3 = s2; e3 < a2; e3++) {
                const r3 = t2.get(e3);
                u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e3 = o2; e3 < l2; e3++) {
                const r3 = t2.get(e3);
                u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
                break;
              }
              return u2;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r2 = this.symbolInstances.get(e2);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t2, e2) {
              const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
                t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== void 0)
                return this.symbolInstanceIndexes;
              const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                s2.push(t3);
                const a2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
              }
              return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
            }
            addToSortKeyRanges(t2, e2) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e2 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                    t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                  }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          Sn("SymbolBucket", Eu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Eu.MAX_GLYPHS = 65535, Eu.addDynamicAttributes = Bu;
          const Fu = new hi({ "symbol-placement": new ai(nt.layout_symbol["symbol-placement"]), "symbol-spacing": new ai(nt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ai(nt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new oi(nt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ai(nt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ai(nt.layout_symbol["icon-allow-overlap"]), "icon-overlap": new ai(nt.layout_symbol["icon-overlap"]), "icon-ignore-placement": new ai(nt.layout_symbol["icon-ignore-placement"]), "icon-optional": new ai(nt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ai(nt.layout_symbol["icon-rotation-alignment"]), "icon-size": new oi(nt.layout_symbol["icon-size"]), "icon-text-fit": new ai(nt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ai(nt.layout_symbol["icon-text-fit-padding"]), "icon-image": new oi(nt.layout_symbol["icon-image"]), "icon-rotate": new oi(nt.layout_symbol["icon-rotate"]), "icon-padding": new ai(nt.layout_symbol["icon-padding"]), "icon-keep-upright": new ai(nt.layout_symbol["icon-keep-upright"]), "icon-offset": new oi(nt.layout_symbol["icon-offset"]), "icon-anchor": new oi(nt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ai(nt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ai(nt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ai(nt.layout_symbol["text-rotation-alignment"]), "text-field": new oi(nt.layout_symbol["text-field"]), "text-font": new oi(nt.layout_symbol["text-font"]), "text-size": new oi(nt.layout_symbol["text-size"]), "text-max-width": new oi(nt.layout_symbol["text-max-width"]), "text-line-height": new ai(nt.layout_symbol["text-line-height"]), "text-letter-spacing": new oi(nt.layout_symbol["text-letter-spacing"]), "text-justify": new oi(nt.layout_symbol["text-justify"]), "text-radial-offset": new oi(nt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ai(nt.layout_symbol["text-variable-anchor"]), "text-anchor": new oi(nt.layout_symbol["text-anchor"]), "text-max-angle": new ai(nt.layout_symbol["text-max-angle"]), "text-writing-mode": new ai(nt.layout_symbol["text-writing-mode"]), "text-rotate": new oi(nt.layout_symbol["text-rotate"]), "text-padding": new ai(nt.layout_symbol["text-padding"]), "text-keep-upright": new ai(nt.layout_symbol["text-keep-upright"]), "text-transform": new oi(nt.layout_symbol["text-transform"]), "text-offset": new oi(nt.layout_symbol["text-offset"]), "text-allow-overlap": new ai(nt.layout_symbol["text-allow-overlap"]), "text-overlap": new ai(nt.layout_symbol["text-overlap"]), "text-ignore-placement": new ai(nt.layout_symbol["text-ignore-placement"]), "text-optional": new ai(nt.layout_symbol["text-optional"]) });
          var Tu = { paint: new hi({ "icon-opacity": new oi(nt.paint_symbol["icon-opacity"]), "icon-color": new oi(nt.paint_symbol["icon-color"]), "icon-halo-color": new oi(nt.paint_symbol["icon-halo-color"]), "icon-halo-width": new oi(nt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new oi(nt.paint_symbol["icon-halo-blur"]), "icon-translate": new ai(nt.paint_symbol["icon-translate"]), "icon-translate-anchor": new ai(nt.paint_symbol["icon-translate-anchor"]), "text-opacity": new oi(nt.paint_symbol["text-opacity"]), "text-color": new oi(nt.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new oi(nt.paint_symbol["text-halo-color"]), "text-halo-width": new oi(nt.paint_symbol["text-halo-width"]), "text-halo-blur": new oi(nt.paint_symbol["text-halo-blur"]), "text-translate": new ai(nt.paint_symbol["text-translate"]), "text-translate-anchor": new ai(nt.paint_symbol["text-translate-anchor"]) }), layout: Fu };
          class Lu {
            constructor(t2) {
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ht, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e2 = this.defaultValue.property.overrides;
                if (e2 && e2.hasOverride(t2.formattedSection))
                  return e2.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          Sn("FormatSectionOverride", Lu, { omit: ["defaultValue"] });
          class Du extends fi {
            constructor(t2) {
              super(t2, Tu);
            }
            recalculate(t2, e2) {
              if (super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
                const t3 = this.layout.get("text-writing-mode");
                if (t3) {
                  const e3 = [];
                  for (const r2 of t3)
                    e3.indexOf(r2) < 0 && e3.push(r2);
                  this.layout._values["text-writing-mode"] = e3;
                } else
                  this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t2, e2, r2, n2) {
              const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
              return s2.isDataDriven() || Pr(s2.value) || !i2 ? i2 : function(t3, e3) {
                return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
              }(e2.properties, i2);
            }
            createBucket(t2) {
              return new Eu(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            _setPaintOverrides() {
              for (const t2 of Tu.paint.overridableProperties) {
                if (!Du.hasPaintOverride(this.layout, t2))
                  continue;
                const e2 = this.paint.get(t2), r2 = new Lu(e2), n2 = new Cr(r2, e2.property.specification);
                let i2 = null;
                i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new Er("source", n2) : new Fr("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new ii(e2.property, i2, e2.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Du.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e2) {
              const r2 = t2.get("text-field"), n2 = Tu.paint.properties[e2];
              let i2 = false;
              const s2 = (t3) => {
                for (const e3 of t3)
                  if (n2.overrides && n2.overrides.hasOverride(e3))
                    return void (i2 = true);
              };
              if (r2.value.kind === "constant" && r2.value.value instanceof Lt)
                s2(r2.value.value.sections);
              else if (r2.value.kind === "source") {
                const t3 = (e4) => {
                  i2 || (e4 instanceof qt && Ut(e4.value) === vt ? s2(e4.value.sections) : e4 instanceof Zt ? s2(e4.sections) : e4.eachChild(t3));
                }, e3 = r2.value;
                e3._styleExpression && t3(e3._styleExpression.expression);
              }
              return i2;
            }
          }
          function $u(t2, e2, r2) {
            let n2 = "never";
            const i2 = t2.get(e2);
            return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
          }
          var Ru = { paint: new hi({ "background-color": new ai(nt.paint_background["background-color"]), "background-pattern": new ui(nt.paint_background["background-pattern"]), "background-opacity": new ai(nt.paint_background["background-opacity"]) }) }, Uu = { paint: new hi({ "raster-opacity": new ai(nt.paint_raster["raster-opacity"]), "raster-hue-rotate": new ai(nt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ai(nt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ai(nt.paint_raster["raster-brightness-max"]), "raster-saturation": new ai(nt.paint_raster["raster-saturation"]), "raster-contrast": new ai(nt.paint_raster["raster-contrast"]), "raster-resampling": new ai(nt.paint_raster["raster-resampling"]), "raster-fade-duration": new ai(nt.paint_raster["raster-fade-duration"]) }) };
          class Ou extends fi {
            constructor(t2) {
              super(t2, {}), this.onAdd = (t3) => {
                this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
              }, this.onRemove = (t3) => {
                this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
              }, this.implementation = t2;
            }
            is3D() {
              return this.implementation.renderingMode === "3d";
            }
            hasOffscreenPass() {
              return this.implementation.prerender !== void 0;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
            }
          }
          const qu = { circle: class extends fi {
            constructor(t2) {
              super(t2, ua);
            }
            createBucket(t2) {
              return new Gs(t2);
            }
            queryRadius(t2) {
              const e2 = t2;
              return sa("circle-radius", this, e2) + sa("circle-stroke-width", this, e2) + aa(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = oa(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, a2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = this.paint.get("circle-pitch-alignment") === "map", h2 = c2 ? l2 : function(t3, e3) {
                return t3.map((t4) => ga(t4, e3));
              }(l2, o2), p2 = c2 ? u2 * a2 : u2;
              for (const t3 of n2)
                for (const e3 of t3) {
                  const t4 = c2 ? e3 : ga(e3, o2);
                  let r3 = p2;
                  const n3 = ma([], [e3.x, e3.y, 0, 1], o2);
                  if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? r3 *= n3[3] / s2.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (r3 *= s2.cameraToCenterDistance / n3[3]), Xs(h2, t4, r3))
                    return true;
                }
              return false;
            }
          }, heatmap: class extends fi {
            constructor(t2) {
              super(t2, va), this._updateColorRamp();
            }
            createBucket(t2) {
              return new xa(t2);
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              t2 === "heatmap-color" && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = Sa({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
            }
          }, hillshade: class extends fi {
            constructor(t2) {
              super(t2, za);
            }
            hasOffscreenPass() {
              return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
            }
          }, fill: class extends fi {
            constructor(t2) {
              super(t2, fo);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
              const r2 = this.paint._values["fill-outline-color"];
              r2.value.kind === "constant" && r2.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new ho(t2);
            }
            queryRadius() {
              return aa(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2) {
              return Ys(oa(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, a2), n2);
            }
            isTileClipped() {
              return true;
            }
          }, "fill-extrusion": class extends fi {
            constructor(t2) {
              super(t2, Lo);
            }
            createBucket(t2) {
              return new Eo(t2);
            }
            queryRadius() {
              return aa(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = oa(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, a2), u2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), h2 = function(t3, e3, r3, n3) {
                const i3 = [];
                for (const r4 of t3) {
                  const t4 = [r4.x, r4.y, 0, 1];
                  ma(t4, t4, e3), i3.push(new S(t4[0] / t4[3], t4[1] / t4[3]));
                }
                return i3;
              }(l2, o2), p2 = function(t3, e3, r3, n3) {
                const i3 = [], s3 = [], a3 = n3[8] * e3, o3 = n3[9] * e3, l3 = n3[10] * e3, u3 = n3[11] * e3, c3 = n3[8] * r3, h3 = n3[9] * r3, p3 = n3[10] * r3, f2 = n3[11] * r3;
                for (const e4 of t3) {
                  const t4 = [], r4 = [];
                  for (const i4 of e4) {
                    const e5 = i4.x, s4 = i4.y, d2 = n3[0] * e5 + n3[4] * s4 + n3[12], y2 = n3[1] * e5 + n3[5] * s4 + n3[13], m2 = n3[2] * e5 + n3[6] * s4 + n3[14], g2 = n3[3] * e5 + n3[7] * s4 + n3[15], x2 = m2 + l3, v2 = g2 + u3, b2 = d2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f2, k2 = new S((d2 + a3) / v2, (y2 + o3) / v2);
                    k2.z = x2 / v2, t4.push(k2);
                    const z2 = new S(b2 / A2, w2 / A2);
                    z2.z = _2 / A2, r4.push(z2);
                  }
                  i3.push(t4), s3.push(r4);
                }
                return [i3, s3];
              }(n2, c2, u2, o2);
              return function(t3, e3, r3) {
                let n3 = 1 / 0;
                Ys(r3, e3) && (n3 = $o(r3, e3[0]));
                for (let i3 = 0; i3 < e3.length; i3++) {
                  const s3 = e3[i3], a3 = t3[i3];
                  for (let t4 = 0; t4 < s3.length - 1; t4++) {
                    const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                    Js(r3, i4) && (n3 = Math.min(n3, $o(r3, i4)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(p2[0], p2[1], h2);
            }
          }, line: class extends fi {
            constructor(t2) {
              super(t2, Jo), this.gradientVersion = 0;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              t2 === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof ke, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Xo.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new Zo(t2);
            }
            queryRadius(t2) {
              const e2 = t2, r2 = Yo(sa("line-width", this, e2), sa("line-gap-width", this, e2)), n2 = sa("line-offset", this, e2);
              return r2 / 2 + Math.abs(n2) + aa(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = oa(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, a2), l2 = a2 / 2 * Yo(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), u2 = this.paint.get("line-offset").evaluate(e2, r2);
              return u2 && (n2 = function(t3, e3) {
                const r3 = [];
                for (let n3 = 0; n3 < t3.length; n3++) {
                  const i3 = t3[n3], s3 = [];
                  for (let t4 = 0; t4 < i3.length; t4++) {
                    const r4 = i3[t4 - 1], n4 = i3[t4], a3 = i3[t4 + 1], o3 = t4 === 0 ? new S(0, 0) : n4.sub(r4)._unit()._perp(), l3 = t4 === i3.length - 1 ? new S(0, 0) : a3.sub(n4)._unit()._perp(), u3 = o3._add(l3)._unit(), c2 = u3.x * l3.x + u3.y * l3.y;
                    c2 !== 0 && u3._mult(1 / c2), s3.push(u3._mult(e3)._add(n4));
                  }
                  r3.push(s3);
                }
                return r3;
              }(n2, u2 * a2)), function(t3, e3, r3) {
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i3 = e3[n3];
                  if (t3.length >= 3) {
                    for (let e4 = 0; e4 < i3.length; e4++)
                      if (na(t3, i3[e4]))
                        return true;
                  }
                  if (Hs(t3, i3, r3))
                    return true;
                }
                return false;
              }(o2, n2, l2);
            }
            isTileClipped() {
              return true;
            }
          }, symbol: Du, background: class extends fi {
            constructor(t2) {
              super(t2, Ru);
            }
          }, raster: class extends fi {
            constructor(t2) {
              super(t2, Uu);
            }
          } };
          class ju {
            constructor(t2) {
              this._callback = t2, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              delete this._channel, this._callback = () => {
              };
            }
          }
          const Nu = 63710088e-1;
          class Ku {
            constructor(t2, e2) {
              if (isNaN(t2) || isNaN(e2))
                throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
              if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new Ku(a(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
              return Nu * Math.acos(Math.min(i2, 1));
            }
            toBounds(t2 = 0) {
              const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
              return new Zu(new Ku(this.lng - r2, this.lat - e2), new Ku(this.lng + r2, this.lat + e2));
            }
            static convert(t2) {
              if (t2 instanceof Ku)
                return t2;
              if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
                return new Ku(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
                return new Ku(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          class Zu {
            constructor(t2, e2) {
              t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : t2.length === 4 ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
            }
            setNorthEast(t2) {
              return this._ne = t2 instanceof Ku ? new Ku(t2.lng, t2.lat) : Ku.convert(t2), this;
            }
            setSouthWest(t2) {
              return this._sw = t2 instanceof Ku ? new Ku(t2.lng, t2.lat) : Ku.convert(t2), this;
            }
            extend(t2) {
              const e2 = this._sw, r2 = this._ne;
              let n2, i2;
              if (t2 instanceof Ku)
                n2 = t2, i2 = t2;
              else {
                if (!(t2 instanceof Zu))
                  return Array.isArray(t2) ? t2.length === 4 || t2.every(Array.isArray) ? this.extend(Zu.convert(t2)) : this.extend(Ku.convert(t2)) : this;
                if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                  return this;
              }
              return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Ku(n2.lng, n2.lat), this._ne = new Ku(i2.lng, i2.lat)), this;
            }
            getCenter() {
              return new Ku((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new Ku(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new Ku(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(t2) {
              const { lng: e2, lat: r2 } = Ku.convert(t2);
              let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
            }
            static convert(t2) {
              return t2 instanceof Zu ? t2 : t2 ? new Zu(t2) : t2;
            }
          }
          const Gu = 2 * Math.PI * Nu;
          function Ju(t2) {
            return Gu * Math.cos(t2 * Math.PI / 180);
          }
          function Xu(t2) {
            return (180 + t2) / 360;
          }
          function Yu(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function Hu(t2, e2) {
            return t2 / Ju(e2);
          }
          function Wu(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          class Qu {
            constructor(t2, e2, r2 = 0) {
              this.x = +t2, this.y = +e2, this.z = +r2;
            }
            static fromLngLat(t2, e2 = 0) {
              const r2 = Ku.convert(t2);
              return new Qu(Xu(r2.lng), Yu(r2.lat), Hu(e2, r2.lat));
            }
            toLngLat() {
              return new Ku(360 * this.x - 180, Wu(this.y));
            }
            toAltitude() {
              return this.z * Ju(Wu(this.y));
            }
            meterInMercatorCoordinateUnits() {
              return 1 / Gu * (t2 = Wu(this.y), 1 / Math.cos(t2 * Math.PI / 180));
              var t2;
            }
          }
          function tc(t2, e2, r2) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          class ec {
            constructor(t2, e2, r2) {
              this.z = t2, this.x = e2, this.y = r2, this.key = ic(0, t2, t2, e2, r2);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e2, r2) {
              const n2 = (s2 = this.y, a2 = this.z, o2 = tc(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l2 = tc(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
              var i2, s2, a2, o2, l2;
              const u2 = function(t3, e3, r3) {
                let n3, i3 = "";
                for (let s3 = t3; s3 > 0; s3--)
                  n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
                return i3;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(r2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
            }
            isChildOf(t2) {
              const e2 = this.z - t2.z;
              return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
            }
            getTilePoint(t2) {
              const e2 = Math.pow(2, this.z);
              return new S((t2.x * e2 - this.x) * Os, (t2.y * e2 - this.y) * Os);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class rc {
            constructor(t2, e2) {
              this.wrap = t2, this.canonical = e2, this.key = ic(t2, e2.z, e2.z, e2.x, e2.y);
            }
          }
          class nc {
            constructor(t2, e2, r2, n2, i2) {
              this.overscaledZ = t2, this.wrap = e2, this.canonical = new ec(r2, +n2, +i2), this.key = ic(e2, t2, r2, n2, i2);
            }
            clone() {
              return new nc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              const e2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new nc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new nc(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
            }
            calculateScaledKey(t2, e2) {
              const r2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? ic(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : ic(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap)
                return false;
              const e2 = this.canonical.z - t2.canonical.z;
              return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
            }
            children(t2) {
              if (this.overscaledZ >= t2)
                return [new nc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new nc(e2, this.wrap, e2, r2, n2), new nc(e2, this.wrap, e2, r2 + 1, n2), new nc(e2, this.wrap, e2, r2, n2 + 1), new nc(e2, this.wrap, e2, r2 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new nc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new nc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new rc(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t2) {
              return this.canonical.getTilePoint(new Qu(t2.x - this.wrap, t2.y));
            }
          }
          function ic(t2, e2, r2, n2, i2) {
            (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
            const s2 = 1 << r2;
            return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
          }
          Sn("CanonicalTileID", ec), Sn("OverscaledTileID", nc, { omit: ["posMatrix"] });
          class sc {
            constructor(t2, e2, r2) {
              if (this.uid = t2, e2.height !== e2.width)
                throw new RangeError("DEM tiles must be square");
              if (r2 && r2 !== "mapbox" && r2 !== "terrarium")
                return void d(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e2.height;
              const n2 = this.dim = e2.height - 2;
              this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox";
              for (let t3 = 0; t3 < n2; t3++)
                this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(n2, t3)] = this.data[this._idx(n2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, n2)] = this.data[this._idx(t3, n2 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t3 = 0; t3 < n2; t3++)
                for (let e3 = 0; e3 < n2; e3++) {
                  const r3 = this.get(t3, e3);
                  r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
                }
            }
            get(t2, e2) {
              const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
              return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
            }
            getUnpackVector() {
              return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
            }
            _idx(t2, e2) {
              if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e2 + 1) * this.stride + (t2 + 1);
            }
            _unpackMapbox(t2, e2, r2) {
              return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
            }
            _unpackTerrarium(t2, e2, r2) {
              return 256 * t2 + e2 + r2 / 256 - 32768;
            }
            getPixels() {
              return new ka({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t2, e2, r2) {
              if (this.dim !== t2.dim)
                throw new Error("dem dimension mismatch");
              let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
              switch (e2) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r2) {
                case -1:
                  s2 = a2 - 1;
                  break;
                case 1:
                  a2 = s2 + 1;
              }
              const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
              for (let e3 = s2; e3 < a2; e3++)
                for (let r3 = n2; r3 < i2; r3++)
                  this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
            }
          }
          Sn("DEMData", sc);
          class ac {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r2 = t2[e2];
                this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              return this._numberToString[t2];
            }
          }
          class oc {
            constructor(t2, e2, r2, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
            }
            get geometry() {
              return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { geometry: this.geometry };
              for (const e2 in this)
                e2 !== "_geometry" && e2 !== "_vectorTileFeature" && (t2[e2] = this[e2]);
              return t2;
            }
          }
          class lc {
            constructor(t2, e2) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new An(Os, 16, 0), this.grid3D = new An(Os, 16, 0), this.featureIndexArray = new Yi(), this.promoteId = e2;
            }
            insert(t2, e2, r2, n2, i2, s2) {
              const a2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n2, i2);
              const o2 = s2 ? this.grid3D : this.grid;
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r3.length; t4++) {
                  const e3 = r3[t4];
                  n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
                }
                n3[0] < Os && n3[1] < Os && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new xo.VectorTile(new sl(this.rawTileData)).layers, this.sourceLayerCoder = new ac(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t2, e2, r2, n2) {
              this.loadVTLayers();
              const i2 = t2.params || {}, s2 = Os / t2.tileSize / t2.scale, a2 = Zr(i2.filter), o2 = t2.queryGeometry, l2 = t2.queryPadding * s2, u2 = cc(o2), c2 = this.grid.query(u2.minX - l2, u2.minY - l2, u2.maxX + l2, u2.maxY + l2), h2 = cc(t2.cameraQueryGeometry), p2 = this.grid3D.query(h2.minX - l2, h2.minY - l2, h2.maxX + l2, h2.maxY + l2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
                for (const s4 of t3)
                  if (e4 <= s4.x && r4 <= s4.y && n4 >= s4.x && i4 >= s4.y)
                    return true;
                const s3 = [new S(e4, r4), new S(e4, i4), new S(n4, i4), new S(n4, r4)];
                if (t3.length > 2) {
                  for (const e5 of s3)
                    if (na(t3, e5))
                      return true;
                }
                for (let e5 = 0; e5 < t3.length - 1; e5++)
                  if (ia(t3[e5], t3[e5 + 1], s3))
                    return true;
                return false;
              }(t2.cameraQueryGeometry, e3 - l2, r3 - l2, n3 + l2, i3 + l2));
              for (const t3 of p2)
                c2.push(t3);
              c2.sort(hc);
              const f2 = {};
              let d2;
              for (let l3 = 0; l3 < c2.length; l3++) {
                const u3 = c2[l3];
                if (u3 === d2)
                  continue;
                d2 = u3;
                const h3 = this.featureIndexArray.get(u3);
                let p3 = null;
                this.loadMatchingFeature(f2, h3.bucketIndex, h3.sourceLayerIndex, h3.featureIndex, a2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Ns(e3)), r3.queryIntersectsFeature(o2, e3, n3, p3, this.z, t2.transform, s2, t2.pixelPosMatrix)));
              }
              return f2;
            }
            loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, l2, u2, c2, h2) {
              const p2 = this.bucketLayerIDs[e2];
              if (s2 && !function(t3, e3) {
                for (let r3 = 0; r3 < t3.length; r3++)
                  if (e3.indexOf(t3[r3]) >= 0)
                    return true;
                return false;
              }(s2, p2))
                return;
              const f2 = this.sourceLayerCoder.decode(r2), d2 = this.vtLayers[f2].feature(n2);
              if (i2.needGeometry) {
                const t3 = Ks(d2, true);
                if (!i2.filter(new Hn(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  return;
              } else if (!i2.filter(new Hn(this.tileID.overscaledZ), d2))
                return;
              const y2 = this.getId(d2, f2);
              for (let e3 = 0; e3 < p2.length; e3++) {
                const r3 = p2[e3];
                if (s2 && s2.indexOf(r3) < 0)
                  continue;
                const i3 = l2[r3];
                if (!i3)
                  continue;
                let f3 = {};
                y2 && c2 && (f3 = c2.getState(i3.sourceLayer || "_geojsonTileLayer", y2));
                const m2 = o({}, u2[r3]);
                m2.paint = uc(m2.paint, i3.paint, d2, f3, a2), m2.layout = uc(m2.layout, i3.layout, d2, f3, a2);
                const g2 = !h2 || h2(d2, i3, f3);
                if (!g2)
                  continue;
                const x2 = new oc(d2, this.z, this.x, this.y, y2);
                x2.layer = m2;
                let v2 = t2[r3];
                v2 === void 0 && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x2, intersectionZ: g2 });
              }
            }
            lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = Zr(i2);
              for (const i3 of t2)
                this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, a2, o2, e2);
              return l2;
            }
            hasLayer(t2) {
              for (const e2 of this.bucketLayerIDs)
                for (const r2 of e2)
                  if (t2 === r2)
                    return true;
              return false;
            }
            getId(t2, e2) {
              let r2 = t2.id;
              return this.promoteId && (r2 = t2.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof r2 == "boolean" && (r2 = Number(r2))), r2;
            }
          }
          function uc(t2, e2, r2, n2, i2) {
            return c(t2, (t3, s2) => {
              const a2 = e2 instanceof si ? e2.get(s2) : null;
              return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
            });
          }
          function cc(t2) {
            let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const s2 of t2)
              e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
          }
          function hc(t2, e2) {
            return e2 - t2;
          }
          var pc;
          Sn("FeatureIndex", lc, { omit: ["rawTileData", "sourceLayerCoder"] }), t.PerformanceMarkers = void 0, (pc = t.PerformanceMarkers || (t.PerformanceMarkers = {})).create = "create", pc.load = "load", pc.fullLoad = "fullLoad";
          let fc = null, dc = [];
          const yc = 1e3 / 30, mc = { mark(t2) {
            performance.mark(t2);
          }, frame(t2) {
            const e2 = t2;
            fc != null && dc.push(e2 - fc), fc = e2;
          }, clearMetrics() {
            fc = null, dc = [], performance.clearMeasures("loadTime"), performance.clearMeasures("fullLoadTime");
            for (const e2 in t.PerformanceMarkers)
              performance.clearMarks(t.PerformanceMarkers[e2]);
          }, getPerformanceMetrics() {
            performance.measure("loadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.load), performance.measure("fullLoadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.fullLoad);
            const e2 = performance.getEntriesByName("loadTime")[0].duration, r2 = performance.getEntriesByName("fullLoadTime")[0].duration, n2 = dc.length, i2 = 1 / (dc.reduce((t2, e3) => t2 + e3, 0) / n2 / 1e3), s2 = dc.filter((t2) => t2 > yc).reduce((t2, e3) => t2 + (e3 - yc) / yc, 0);
            return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100 };
          } };
          t.AJAXError = q, t.ARRAY_TYPE = ha, t.Actor = class {
            constructor(t2, e2, r2) {
              this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, u(["receive", "process"], this), this.invoker = new ju(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = g() ? t2 : window;
            }
            send(t2, e2, r2, n2, i2 = false) {
              const s2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r2 && (this.callbacks[s2] = r2);
              const a2 = _(this.globalScope) ? void 0 : [];
              return this.target.postMessage({ id: s2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: In(e2, a2) }, a2), { cancel: () => {
                r2 && delete this.callbacks[s2], this.target.postMessage({ id: s2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
              } };
            }
            receive(t2) {
              const e2 = t2.data, r2 = e2.id;
              if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
                if (e2.type === "<cancel>") {
                  delete this.tasks[r2];
                  const t3 = this.cancelCallbacks[r2];
                  delete this.cancelCallbacks[r2], t3 && t3();
                } else
                  g() || e2.mustQueue ? (this.tasks[r2] = e2, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e2);
            }
            process() {
              if (!this.taskQueue.length)
                return;
              const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
              delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e2 && this.processTask(t2, e2);
            }
            processTask(t2, e2) {
              if (e2.type === "<response>") {
                const r2 = this.callbacks[t2];
                delete this.callbacks[t2], r2 && (e2.error ? r2(Mn(e2.error)) : r2(null, Mn(e2.data)));
              } else {
                let r2 = false;
                const n2 = _(this.globalScope) ? void 0 : [], i2 = e2.hasCallback ? (e3, i3) => {
                  r2 = true, delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? In(e3) : null, data: In(i3, n2) }, n2);
                } : (t3) => {
                  r2 = true;
                };
                let s2 = null;
                const a2 = Mn(e2.data);
                if (this.parent[e2.type])
                  s2 = this.parent[e2.type](e2.sourceMapId, a2, i2);
                else if (this.parent.getWorkerSource) {
                  const t3 = e2.type.split(".");
                  s2 = this.parent.getWorkerSource(e2.sourceMapId, t3[0], a2.source)[t3[1]](a2, i2);
                } else
                  i2(new Error(`Could not find function ${e2.type}`));
                !r2 && s2 && s2.cancel && (this.cancelCallbacks[t2] = s2.cancel);
              }
            }
            remove() {
              this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }, t.AlphaImage = Aa, t.CanonicalTileID = ec, t.CollisionBoxArray = qi, t.CollisionCircleLayoutArray = class extends Ci {
          }, t.Color = Et, t.DEMData = sc, t.DataConstantProperty = ai, t.DictionaryCoder = ac, t.EXTENT = Os, t.ErrorEvent = et, t.EvaluationParameters = Hn, t.Event = tt, t.Evented = rt, t.FeatureIndex = lc, t.FillBucket = ho, t.FillExtrusionBucket = Eo, t.GeoJSONFeature = oc, t.ImageAtlas = El, t.ImagePosition = Vl, t.LineBucket = Zo, t.LineStripIndexArray = class extends Ri {
          }, t.LngLat = Ku, t.LngLatBounds = Zu, t.MercatorCoordinate = Qu, t.ONE_EM = il, t.OverscaledTileID = nc, t.PerformanceUtils = mc, t.PosArray = Hi, t.Properties = hi, t.QuadTriangleArray = class extends Vi {
          }, t.RGBAImage = ka, t.RasterBoundsArray = class extends bi {
          }, t.RequestPerformance = class {
            constructor(t2) {
              this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
            }
            finish() {
              performance.mark(this._marks.end);
              let t2 = performance.getEntriesByName(this._marks.measure);
              return t2.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
            }
          }, t.ResourceType = O, t.SegmentVector = fs, t.SymbolBucket = Eu, t.Transitionable = ti, t.TriangleIndexArray = us, t.Uniform1f = Is, t.Uniform1i = class extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
            }
          }, t.Uniform2f = class extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
            }
          }, t.Uniform3f = class extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
            }
          }, t.Uniform4f = Ms, t.UniformColor = Bs, t.UniformMatrix4f = class extends zs {
            constructor(t2, e2) {
              super(t2, e2), this.current = Cs;
            }
            set(t2) {
              if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
                return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
              for (let e2 = 1; e2 < 16; e2++)
                if (t2[e2] !== this.current[e2]) {
                  this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
                  break;
                }
            }
          }, t.UnwrappedTileID = rc, t.ValidationError = it, t.ZoomHistory = Bn, t.addDynamicAttributes = Bu, t.asyncAll = function(t2, e2, r2) {
            if (!t2.length)
              return r2(null, []);
            let n2 = t2.length;
            const i2 = new Array(t2.length);
            let s2 = null;
            t2.forEach((t3, a2) => {
              e2(t3, (t4, e3) => {
                t4 && (s2 = t4), i2[a2] = e3, --n2 == 0 && r2(s2, i2);
              });
            });
          }, t.bezier = n, t.bindAll = u, t.cacheEntryPossiblyAdded = function(t2) {
            F++, F > V && (t2.getActor().send("enforceCacheSizeLimit", P), F = 0);
          }, t.clamp = s, t.clearTileCache = function(t2) {
            const e2 = caches.delete(M);
            t2 && e2.catch(t2).then(() => t2());
          }, t.clipLine = au, t.clone = function(t2) {
            var e2 = new ha(16);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
          }, t.clone$1 = p, t.collisionCircleLayout = el, t.config = I, t.copy = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }, t.create = function() {
            var t2 = new ha(16);
            return ha != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }, t.createExpression = Vr, t.createFilter = Zr, t.createLayout = gi, t.createStyleLayer = function(t2) {
            return t2.type === "custom" ? new Ou(t2) : new qu[t2.type](t2);
          }, t.dot = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
          }, t.ease = i, t.emitValidationErrors = _n, t.enforceCacheSizeLimit = function(t2) {
            E(), B && B.then((e2) => {
              e2.keys().then((r2) => {
                for (let n2 = 0; n2 < r2.length - t2; n2++)
                  e2.delete(r2[n2]);
              });
            });
          }, t.equals = function(t2, e2) {
            var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y2 = t2[13], m2 = t2[14], g2 = t2[15], x2 = e2[0], v2 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A2 = e2[5], k2 = e2[6], S2 = e2[7], z2 = e2[8], I2 = e2[9], M2 = e2[10], B2 = e2[11], C2 = e2[12], P2 = e2[13], V2 = e2[14], E2 = e2[15];
            return Math.abs(r2 - x2) <= ca * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v2) <= ca * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= ca * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(s2 - w2) <= ca * Math.max(1, Math.abs(s2), Math.abs(w2)) && Math.abs(a2 - _2) <= ca * Math.max(1, Math.abs(a2), Math.abs(_2)) && Math.abs(o2 - A2) <= ca * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - k2) <= ca * Math.max(1, Math.abs(l2), Math.abs(k2)) && Math.abs(u2 - S2) <= ca * Math.max(1, Math.abs(u2), Math.abs(S2)) && Math.abs(c2 - z2) <= ca * Math.max(1, Math.abs(c2), Math.abs(z2)) && Math.abs(h2 - I2) <= ca * Math.max(1, Math.abs(h2), Math.abs(I2)) && Math.abs(p2 - M2) <= ca * Math.max(1, Math.abs(p2), Math.abs(M2)) && Math.abs(f2 - B2) <= ca * Math.max(1, Math.abs(f2), Math.abs(B2)) && Math.abs(d2 - C2) <= ca * Math.max(1, Math.abs(d2), Math.abs(C2)) && Math.abs(y2 - P2) <= ca * Math.max(1, Math.abs(y2), Math.abs(P2)) && Math.abs(m2 - V2) <= ca * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E2) <= ca * Math.max(1, Math.abs(g2), Math.abs(E2));
          }, t.evaluateSizeForFeature = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
            return t2.kind === "source" ? n2 / Yl : t2.kind === "composite" ? Se(n2 / Yl, i2 / Yl, r2) : e2;
          }, t.evaluateSizeForZoom = function(t2, e2) {
            let r2 = 0, n2 = 0;
            if (t2.kind === "constant")
              n2 = t2.layoutSize;
            else if (t2.kind !== "source") {
              const { interpolationType: i2, minZoom: a2, maxZoom: o2 } = t2, l2 = i2 ? s(Ne.interpolationFactor(i2, e2, a2, o2), 0, 1) : 0;
              t2.kind === "camera" ? n2 = Se(t2.minSize, t2.maxSize, l2) : r2 = l2;
            }
            return { uSizeT: r2, uSize: n2 };
          }, t.evaluateVariableOffset = vu, t.evented = Gn, t.exported = k, t.exported$1 = T, t.extend = o, t.filterObject = h, t.fromScaling = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }, t.getAnchorAlignment = Zl, t.getAnchorJustification = bu, t.getArrayBuffer = Z, t.getImage = H, t.getJSON = function(t2, e2) {
            return K(o(t2, { type: "json" }), e2);
          }, t.getOverlapMode = $u, t.getRTLTextPluginStatus = Jn, t.getReferrer = j, t.getVideo = function(t2, e2) {
            const r2 = window.document.createElement("video");
            r2.muted = true, r2.onloadstart = function() {
              e2(null, r2);
            };
            for (let e3 = 0; e3 < t2.length; e3++) {
              const n2 = window.document.createElement("source");
              G(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
            }
            return { cancel: () => {
            } };
          }, t.identity = pa, t.invert = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, k2 = c2 * y2 - h2 * d2, S2 = c2 * m2 - p2 * d2, z2 = c2 * g2 - f2 * d2, I2 = h2 * m2 - p2 * y2, M2 = h2 * g2 - f2 * y2, B2 = p2 * g2 - f2 * m2, C2 = x2 * B2 - v2 * M2 + b2 * I2 + w2 * z2 - _2 * S2 + A2 * k2;
            return C2 ? (t2[0] = (o2 * B2 - l2 * M2 + u2 * I2) * (C2 = 1 / C2), t2[1] = (i2 * M2 - n2 * B2 - s2 * I2) * C2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l2 * z2 - a2 * B2 - u2 * S2) * C2, t2[5] = (r2 * B2 - i2 * z2 + s2 * S2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (a2 * M2 - o2 * z2 + u2 * k2) * C2, t2[9] = (n2 * z2 - r2 * M2 - s2 * k2) * C2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C2, t2[12] = (o2 * S2 - a2 * I2 - l2 * k2) * C2, t2[13] = (r2 * I2 - n2 * S2 + i2 * k2) * C2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C2, t2) : null;
          }, t.isImageBitmap = A, t.isSafari = _, t.keysDifference = function(t2, e2) {
            const r2 = [];
            for (const n2 in t2)
              n2 in e2 || r2.push(n2);
            return r2;
          }, t.lazyLoadRTLTextPlugin = function() {
            Yn.isLoading() || Yn.isLoaded() || Jn() !== "deferred" || Xn();
          }, t.makeRequest = K, t.mapObject = c, t.mercatorXfromLng = Xu, t.mercatorYfromLat = Yu, t.mercatorZfromAltitude = Hu, t.mul = ya, t.mul$1 = function(t2, e2, r2) {
            return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
          }, t.multiply = fa, t.nextPowerOfTwo = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }, t.number = Se, t.ortho = function(t2, e2, r2, n2, i2, s2, a2) {
            var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
            return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
          }, t.parseCacheControl = x, t.parseGlyphPBF = function(t2) {
            return new sl(t2).readFields(Ml, []);
          }, t.pbf = sl, t.performSymbolLayout = function(e2, r2, n2, i2, s2, a2, o2) {
            e2.createArrays(), e2.tilePixelRatio = Os / (512 * e2.overscaling), e2.compareText = {}, e2.iconsNeedLinear = false;
            const l2 = e2.layers[0].layout, u2 = e2.layers[0]._unevaluatedLayout._values, c2 = { layoutIconSize: u2["icon-size"].possiblyEvaluate(new Hn(e2.zoom + 1), o2), layoutTextSize: u2["text-size"].possiblyEvaluate(new Hn(e2.zoom + 1), o2), textMaxSize: u2["text-size"].possiblyEvaluate(new Hn(18)) };
            if (e2.textSizeData.kind === "composite") {
              const { minZoom: t2, maxZoom: r3 } = e2.textSizeData;
              c2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new Hn(t2), o2), u2["text-size"].possiblyEvaluate(new Hn(r3), o2)];
            }
            if (e2.iconSizeData.kind === "composite") {
              const { minZoom: t2, maxZoom: r3 } = e2.iconSizeData;
              c2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new Hn(t2), o2), u2["icon-size"].possiblyEvaluate(new Hn(r3), o2)];
            }
            const h2 = l2.get("text-line-height") * il, p2 = l2.get("text-rotation-alignment") !== "viewport" && l2.get("symbol-placement") !== "point", f2 = l2.get("text-keep-upright"), y2 = l2.get("text-size");
            for (const a3 of e2.features) {
              const u3 = l2.get("text-font").evaluate(a3, {}, o2).join(","), m2 = y2.evaluate(a3, {}, o2), g2 = c2.layoutTextSize.evaluate(a3, {}, o2), x2 = c2.layoutIconSize.evaluate(a3, {}, o2), v2 = { horizontal: {}, vertical: void 0 }, b2 = a3.text;
              let w2, _2 = [0, 0];
              if (b2) {
                const i3 = b2.toString(), c3 = l2.get("text-letter-spacing").evaluate(a3, {}, o2) * il, d2 = Vn(i3) ? c3 : 0, y3 = l2.get("text-anchor").evaluate(a3, {}, o2), x3 = l2.get("text-variable-anchor");
                if (!x3) {
                  const t2 = l2.get("text-radial-offset").evaluate(a3, {}, o2);
                  _2 = t2 ? vu(y3, [t2 * il, xu]) : l2.get("text-offset").evaluate(a3, {}, o2).map((t3) => t3 * il);
                }
                let w3 = p2 ? "center" : l2.get("text-justify").evaluate(a3, {}, o2);
                const A3 = l2.get("symbol-placement"), k3 = A3 === "point" ? l2.get("text-max-width").evaluate(a3, {}, o2) * il : 0, S2 = () => {
                  e2.allowVerticalPlacement && Pn(i3) && (v2.vertical = Dl(b2, r2, n2, s2, u3, k3, h2, y3, "left", d2, _2, t.WritingMode.vertical, true, A3, g2, m2));
                };
                if (!p2 && x3) {
                  const e3 = w3 === "auto" ? x3.map((t2) => bu(t2)) : [w3];
                  let i4 = false;
                  for (let a4 = 0; a4 < e3.length; a4++) {
                    const o3 = e3[a4];
                    if (!v2.horizontal[o3])
                      if (i4)
                        v2.horizontal[o3] = v2.horizontal[0];
                      else {
                        const e4 = Dl(b2, r2, n2, s2, u3, k3, h2, "center", o3, d2, _2, t.WritingMode.horizontal, false, A3, g2, m2);
                        e4 && (v2.horizontal[o3] = e4, i4 = e4.positionedLines.length === 1);
                      }
                  }
                  S2();
                } else {
                  w3 === "auto" && (w3 = bu(y3));
                  const e3 = Dl(b2, r2, n2, s2, u3, k3, h2, y3, w3, d2, _2, t.WritingMode.horizontal, false, A3, g2, m2);
                  e3 && (v2.horizontal[w3] = e3), S2(), Pn(i3) && p2 && f2 && (v2.vertical = Dl(b2, r2, n2, s2, u3, k3, h2, y3, w3, d2, _2, t.WritingMode.vertical, false, A3, g2, m2));
                }
              }
              let A2 = false;
              if (a3.icon && a3.icon.name) {
                const t2 = i2[a3.icon.name];
                t2 && (w2 = Jl(s2[a3.icon.name], l2.get("icon-offset").evaluate(a3, {}, o2), l2.get("icon-anchor").evaluate(a3, {}, o2)), A2 = !!t2.sdf, e2.sdfIcons === void 0 ? e2.sdfIcons = A2 : e2.sdfIcons !== A2 && d("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.pixelRatio || l2.get("icon-rotate").constantOr(1) !== 0) && (e2.iconsNeedLinear = true));
              }
              const k2 = ku(v2.horizontal) || v2.vertical;
              e2.iconsInText = !!k2 && k2.iconsInText, (k2 || w2) && wu(e2, a3, v2, w2, i2, c2, g2, x2, _2, A2, o2);
            }
            a2 && e2.generateCollisionDebugBuffers();
          }, t.perspective = function(t2, e2, r2, n2, i2) {
            var s2, a2 = 1 / Math.tan(e2 / 2);
            return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.pick = function(t2, e2) {
            const r2 = {};
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.plugin = Yn, t.pointGeometry = S, t.polygonIntersectsPolygon = Js, t.potpack = Pl, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = Sn, t.registerForPluginStateChange = function(t2) {
            return t2({ pluginStatus: jn, pluginURL: Nn }), Gn.on("pluginStateChange", t2), t2;
          }, t.renderColorRamp = Sa, t.rotateX = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
          }, t.rotateZ = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
            return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
          }, t.scale = function(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], s2 = r2[2];
            return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }, t.setCacheLimits = function(t2, e2) {
            P = t2, V = e2;
          }, t.setRTLTextPlugin = function(t2, e2, r2 = false) {
            if (jn === Rn || jn === Un || jn === On)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Nn = k.resolveURL(t2), jn = Rn, qn = e2, Zn(), r2 || Xn();
          }, t.spec = nt, t.sphericalToCartesian = function([t2, e2, r2]) {
            return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
          }, t.toEvaluationFeature = Ks, t.transformMat4 = ma, t.translate = function(t2, e2, r2) {
            var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
            return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
          }, t.triggerPluginCompletionEvent = Kn, t.unicodeBlockLookup = Cn, t.uniqueId = function() {
            return l++;
          }, t.validateCustomStyleLayer = function(t2) {
            const e2 = [], r2 = t2.id;
            return r2 === void 0 && e2.push({ message: `layers.${r2}: missing required property "id"` }), t2.render === void 0 && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
          }, t.validateLight = vn, t.validateStyle = xn, t.vectorTile = xo, t.warnOnce = d, t.wrap = a;
        });
        define2(["./shared"], function(e) {
          "use strict";
          function t(e2) {
            const o2 = typeof e2;
            if (o2 === "number" || o2 === "boolean" || o2 === "string" || e2 == null)
              return JSON.stringify(e2);
            if (Array.isArray(e2)) {
              let o3 = "[";
              for (const i3 of e2)
                o3 += `${t(i3)},`;
              return `${o3}]`;
            }
            const i2 = Object.keys(e2).sort();
            let r2 = "{";
            for (let o3 = 0; o3 < i2.length; o3++)
              r2 += `${JSON.stringify(i2[o3])}:${t(e2[i2[o3]])},`;
            return `${r2}}`;
          }
          function o(o2) {
            let i2 = "";
            for (const r2 of e.refProperties)
              i2 += `/${t(o2[r2])}`;
            return i2;
          }
          class i {
            constructor(e2) {
              this.keyCache = {}, e2 && this.replace(e2);
            }
            replace(e2) {
              this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
            }
            update(t2, i2) {
              for (const o2 of t2) {
                this._layerConfigs[o2.id] = o2;
                const t3 = this._layers[o2.id] = e.createStyleLayer(o2);
                t3._featureFilter = e.createFilter(t3.filter), this.keyCache[o2.id] && delete this.keyCache[o2.id];
              }
              for (const e2 of i2)
                delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
              this.familiesBySource = {};
              const r2 = function(e2, t3) {
                const i3 = {};
                for (let r4 = 0; r4 < e2.length; r4++) {
                  const n2 = t3 && t3[e2[r4].id] || o(e2[r4]);
                  t3 && (t3[e2[r4].id] = n2);
                  let s2 = i3[n2];
                  s2 || (s2 = i3[n2] = []), s2.push(e2[r4]);
                }
                const r3 = [];
                for (const e3 in i3)
                  r3.push(i3[e3]);
                return r3;
              }(Object.values(this._layerConfigs), this.keyCache);
              for (const e2 of r2) {
                const t3 = e2.map((e3) => this._layers[e3.id]), o2 = t3[0];
                if (o2.visibility === "none")
                  continue;
                const i3 = o2.source || "";
                let r3 = this.familiesBySource[i3];
                r3 || (r3 = this.familiesBySource[i3] = {});
                const n2 = o2.sourceLayer || "_geojsonTileLayer";
                let s2 = r3[n2];
                s2 || (s2 = r3[n2] = []), s2.push(t3);
              }
            }
          }
          class r {
            constructor(t2) {
              const o2 = {}, i2 = [];
              for (const e2 in t2) {
                const r3 = t2[e2], n3 = o2[e2] = {};
                for (const e3 in r3) {
                  const t3 = r3[+e3];
                  if (!t3 || t3.bitmap.width === 0 || t3.bitmap.height === 0)
                    continue;
                  const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                  i2.push(o3), n3[e3] = { rect: o3, metrics: t3.metrics };
                }
              }
              const { w: r2, h: n2 } = e.potpack(i2), s2 = new e.AlphaImage({ width: r2 || 1, height: n2 || 1 });
              for (const i3 in t2) {
                const r3 = t2[i3];
                for (const t3 in r3) {
                  const n3 = r3[+t3];
                  if (!n3 || n3.bitmap.width === 0 || n3.bitmap.height === 0)
                    continue;
                  const a2 = o2[i3][t3].rect;
                  e.AlphaImage.copy(n3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, n3.bitmap);
                }
              }
              this.image = s2, this.positions = o2;
            }
          }
          e.register("GlyphAtlas", r);
          class n {
            constructor(t2) {
              this.tileID = new e.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
            }
            parse(t2, o2, i2, n2, a2) {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.CollisionBoxArray();
              const l2 = new e.DictionaryCoder(Object.keys(t2.layers).sort()), c2 = new e.FeatureIndex(this.tileID, this.promoteId);
              c2.bucketLayerIDs = [];
              const u2 = {}, h2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, f2 = o2.familiesBySource[this.source];
              for (const o3 in f2) {
                const r2 = t2.layers[o3];
                if (!r2)
                  continue;
                r2.version === 1 && e.warnOnce(`Vector tile source "${this.source}" layer "${o3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n3 = l2.encode(o3), a3 = [];
                for (let e2 = 0; e2 < r2.length; e2++) {
                  const t3 = r2.feature(e2), i3 = c2.getId(t3, o3);
                  a3.push({ feature: t3, id: i3, index: e2, sourceLayerIndex: n3 });
                }
                for (const e2 of f2[o3]) {
                  const t3 = e2[0];
                  t3.minzoom && this.zoom < Math.floor(t3.minzoom) || t3.maxzoom && this.zoom >= t3.maxzoom || t3.visibility !== "none" && (s(e2, this.zoom, i2), (u2[t3.id] = t3.createBucket({ index: c2.bucketLayerIDs.length, layers: e2, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, h2, this.tileID.canonical), c2.bucketLayerIDs.push(e2.map((e3) => e3.id)));
                }
              }
              let p2, d2, g2, m2;
              const y2 = e.mapObject(h2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
              Object.keys(y2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: y2 }, (e2, t3) => {
                p2 || (p2 = e2, d2 = t3, w2.call(this));
              }) : d2 = {};
              const v2 = Object.keys(h2.iconDependencies);
              v2.length ? n2.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "icons" }, (e2, t3) => {
                p2 || (p2 = e2, g2 = t3, w2.call(this));
              }) : g2 = {};
              const x2 = Object.keys(h2.patternDependencies);
              function w2() {
                if (p2)
                  return a2(p2);
                if (d2 && g2 && m2) {
                  const t3 = new r(d2), o3 = new e.ImageAtlas(g2, m2);
                  for (const r2 in u2) {
                    const n3 = u2[r2];
                    n3 instanceof e.SymbolBucket ? (s(n3.layers, this.zoom, i2), e.performSymbolLayout(n3, d2, t3.positions, g2, o3.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : n3.hasPattern && (n3 instanceof e.LineBucket || n3 instanceof e.FillBucket || n3 instanceof e.FillExtrusionBucket) && (s(n3.layers, this.zoom, i2), n3.addFeatures(h2, this.tileID.canonical, o3.patternPositions));
                  }
                  this.status = "done", a2(null, { buckets: Object.values(u2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: o3, glyphMap: this.returnDependencies ? d2 : null, iconMap: this.returnDependencies ? g2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
                }
              }
              x2.length ? n2.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (e2, t3) => {
                p2 || (p2 = e2, m2 = t3, w2.call(this));
              }) : m2 = {}, w2.call(this);
            }
          }
          function s(t2, o2, i2) {
            const r2 = new e.EvaluationParameters(o2);
            for (const e2 of t2)
              e2.recalculate(r2, i2);
          }
          function a(t2, o2) {
            const i2 = e.getArrayBuffer(t2.request, (t3, i3, r2, n2) => {
              t3 ? o2(t3) : i3 && o2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i3)), rawData: i3, cacheControl: r2, expires: n2 });
            });
            return () => {
              i2.cancel(), o2();
            };
          }
          class l {
            constructor(e2, t2, o2, i2) {
              this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.loadVectorData = i2 || a, this.loading = {}, this.loaded = {};
            }
            loadTile(t2, o2) {
              const i2 = t2.uid;
              this.loading || (this.loading = {});
              const r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request), s2 = this.loading[i2] = new n(t2);
              s2.abort = this.loadVectorData(t2, (t3, n2) => {
                if (delete this.loading[i2], t3 || !n2)
                  return s2.status = "done", this.loaded[i2] = s2, o2(t3);
                const a2 = n2.rawData, l2 = {};
                n2.expires && (l2.expires = n2.expires), n2.cacheControl && (l2.cacheControl = n2.cacheControl);
                const c2 = {};
                if (r2) {
                  const e2 = r2.finish();
                  e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
                }
                s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, i3) => {
                  if (t4 || !i3)
                    return o2(t4);
                  o2(null, e.extend({ rawTileData: a2.slice(0) }, i3, l2, c2));
                }), this.loaded = this.loaded || {}, this.loaded[i2] = s2;
              });
            }
            reloadTile(e2, t2) {
              const o2 = this.loaded, i2 = e2.uid, r2 = this;
              if (o2 && o2[i2]) {
                const n2 = o2[i2];
                n2.showCollisionBoxes = e2.showCollisionBoxes;
                const s2 = (e3, o3) => {
                  const i3 = n2.reloadCallback;
                  i3 && (delete n2.reloadCallback, n2.parse(n2.vectorTile, r2.layerIndex, this.availableImages, r2.actor, i3)), t2(e3, o3);
                };
                n2.status === "parsing" ? n2.reloadCallback = s2 : n2.status === "done" && (n2.vectorTile ? n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
              }
            }
            abortTile(e2, t2) {
              const o2 = this.loading, i2 = e2.uid;
              o2 && o2[i2] && o2[i2].abort && (o2[i2].abort(), delete o2[i2]), t2();
            }
            removeTile(e2, t2) {
              const o2 = this.loaded, i2 = e2.uid;
              o2 && o2[i2] && delete o2[i2], t2();
            }
          }
          class c {
            constructor() {
              this.loaded = {};
            }
            loadTile(t2, o2) {
              const { uid: i2, encoding: r2, rawImageData: n2 } = t2, s2 = e.isImageBitmap(n2) ? this.getImageData(n2) : n2, a2 = new e.DEMData(i2, s2, r2);
              this.loaded = this.loaded || {}, this.loaded[i2] = a2, o2(null, a2);
            }
            getImageData(t2) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
              const o2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
            }
            removeTile(e2) {
              const t2 = this.loaded, o2 = e2.uid;
              t2 && t2[o2] && delete t2[o2];
            }
          }
          var u = function e2(t2, o2) {
            var i2, r2 = t2 && t2.type;
            if (r2 === "FeatureCollection")
              for (i2 = 0; i2 < t2.features.length; i2++)
                e2(t2.features[i2], o2);
            else if (r2 === "GeometryCollection")
              for (i2 = 0; i2 < t2.geometries.length; i2++)
                e2(t2.geometries[i2], o2);
            else if (r2 === "Feature")
              e2(t2.geometry, o2);
            else if (r2 === "Polygon")
              h(t2.coordinates, o2);
            else if (r2 === "MultiPolygon")
              for (i2 = 0; i2 < t2.coordinates.length; i2++)
                h(t2.coordinates[i2], o2);
            return t2;
          };
          function h(e2, t2) {
            if (e2.length !== 0) {
              f(e2[0], t2);
              for (var o2 = 1; o2 < e2.length; o2++)
                f(e2[o2], !t2);
            }
          }
          function f(e2, t2) {
            for (var o2 = 0, i2 = 0, r2 = 0, n2 = e2.length, s2 = n2 - 1; r2 < n2; s2 = r2++) {
              var a2 = (e2[r2][0] - e2[s2][0]) * (e2[s2][1] + e2[r2][1]), l2 = o2 + a2;
              i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
            }
            o2 + i2 >= 0 != !!t2 && e2.reverse();
          }
          const p = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;
          class d {
            constructor(t2) {
              this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (this._feature.type === 1) {
                const t2 = [];
                for (const o2 of this._feature.geometry)
                  t2.push([new e.pointGeometry(o2[0], o2[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const o2 of this._feature.geometry) {
                  const i2 = [];
                  for (const t3 of o2)
                    i2.push(new e.pointGeometry(t3[0], t3[1]));
                  t2.push(i2);
                }
                return t2;
              }
            }
            toGeoJSON(e2, t2, o2) {
              return p.call(this, e2, t2, o2);
            }
          }
          class g {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
            }
            feature(e2) {
              return new d(this._features[e2]);
            }
          }
          var m = { exports: {} }, y = e.pointGeometry, v = e.vectorTile.VectorTileFeature, x = w;
          function w(e2, t2) {
            this.options = t2 || {}, this.features = e2, this.length = e2.length;
          }
          function S(e2, t2) {
            this.id = typeof e2.id == "number" ? e2.id : void 0, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
          }
          w.prototype.feature = function(e2) {
            return new S(this.features[e2], this.options.extent);
          }, S.prototype.loadGeometry = function() {
            var e2 = this.rawGeometry;
            this.geometry = [];
            for (var t2 = 0; t2 < e2.length; t2++) {
              for (var o2 = e2[t2], i2 = [], r2 = 0; r2 < o2.length; r2++)
                i2.push(new y(o2[r2][0], o2[r2][1]));
              this.geometry.push(i2);
            }
            return this.geometry;
          }, S.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e2 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, r2 = -1 / 0, n2 = 0; n2 < e2.length; n2++)
              for (var s2 = e2[n2], a2 = 0; a2 < s2.length; a2++) {
                var l2 = s2[a2];
                t2 = Math.min(t2, l2.x), o2 = Math.max(o2, l2.x), i2 = Math.min(i2, l2.y), r2 = Math.max(r2, l2.y);
              }
            return [t2, i2, o2, r2];
          }, S.prototype.toGeoJSON = v.prototype.toGeoJSON;
          var M = e.pbf, I = x;
          function b(e2) {
            var t2 = new M();
            return function(e3, t3) {
              for (var o2 in e3.layers)
                t3.writeMessage(3, k, e3.layers[o2]);
            }(e2, t2), t2.finish();
          }
          function k(e2, t2) {
            var o2;
            t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
            var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (o2 = 0; o2 < e2.length; o2++)
              i2.feature = e2.feature(o2), t2.writeMessage(2, T, i2);
            var r2 = i2.keys;
            for (o2 = 0; o2 < r2.length; o2++)
              t2.writeStringField(3, r2[o2]);
            var n2 = i2.values;
            for (o2 = 0; o2 < n2.length; o2++)
              t2.writeMessage(4, L, n2[o2]);
          }
          function T(e2, t2) {
            var o2 = e2.feature;
            o2.id !== void 0 && t2.writeVarintField(1, o2.id), t2.writeMessage(2, P, e2), t2.writeVarintField(3, o2.type), t2.writeMessage(4, D, o2);
          }
          function P(e2, t2) {
            var o2 = e2.feature, i2 = e2.keys, r2 = e2.values, n2 = e2.keycache, s2 = e2.valuecache;
            for (var a2 in o2.properties) {
              var l2 = o2.properties[a2], c2 = n2[a2];
              if (l2 !== null) {
                c2 === void 0 && (i2.push(a2), n2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
                var u2 = typeof l2;
                u2 !== "string" && u2 !== "boolean" && u2 !== "number" && (l2 = JSON.stringify(l2));
                var h2 = u2 + ":" + l2, f2 = s2[h2];
                f2 === void 0 && (r2.push(l2), s2[h2] = f2 = r2.length - 1), t2.writeVarint(f2);
              }
            }
          }
          function C(e2, t2) {
            return (t2 << 3) + (7 & e2);
          }
          function _(e2) {
            return e2 << 1 ^ e2 >> 31;
          }
          function D(e2, t2) {
            for (var o2 = e2.loadGeometry(), i2 = e2.type, r2 = 0, n2 = 0, s2 = o2.length, a2 = 0; a2 < s2; a2++) {
              var l2 = o2[a2], c2 = 1;
              i2 === 1 && (c2 = l2.length), t2.writeVarint(C(1, c2));
              for (var u2 = i2 === 3 ? l2.length - 1 : l2.length, h2 = 0; h2 < u2; h2++) {
                h2 === 1 && i2 !== 1 && t2.writeVarint(C(2, u2 - 1));
                var f2 = l2[h2].x - r2, p2 = l2[h2].y - n2;
                t2.writeVarint(_(f2)), t2.writeVarint(_(p2)), r2 += f2, n2 += p2;
              }
              i2 === 3 && t2.writeVarint(C(7, 1));
            }
          }
          function L(e2, t2) {
            var o2 = typeof e2;
            o2 === "string" ? t2.writeStringField(1, e2) : o2 === "boolean" ? t2.writeBooleanField(7, e2) : o2 === "number" && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
          }
          m.exports = b, m.exports.fromVectorTileJs = b, m.exports.fromGeojsonVt = function(e2, t2) {
            t2 = t2 || {};
            var o2 = {};
            for (var i2 in e2)
              o2[i2] = new I(e2[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
            return b({ layers: o2 });
          }, m.exports.GeoJSONWrapper = I;
          var z = m.exports;
          function O(e2, t2, o2, i2, r2, n2) {
            if (r2 - i2 <= o2)
              return;
            const s2 = i2 + r2 >> 1;
            E(e2, t2, s2, i2, r2, n2 % 2), O(e2, t2, o2, i2, s2 - 1, n2 + 1), O(e2, t2, o2, s2 + 1, r2, n2 + 1);
          }
          function E(e2, t2, o2, i2, r2, n2) {
            for (; r2 > i2; ) {
              if (r2 - i2 > 600) {
                const s3 = r2 - i2 + 1, a3 = o2 - i2 + 1, l3 = Math.log(s3), c2 = 0.5 * Math.exp(2 * l3 / 3), u2 = 0.5 * Math.sqrt(l3 * c2 * (s3 - c2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
                E(e2, t2, o2, Math.max(i2, Math.floor(o2 - a3 * c2 / s3 + u2)), Math.min(r2, Math.floor(o2 + (s3 - a3) * c2 / s3 + u2)), n2);
              }
              const s2 = t2[2 * o2 + n2];
              let a2 = i2, l2 = r2;
              for (F(e2, t2, i2, o2), t2[2 * r2 + n2] > s2 && F(e2, t2, i2, r2); a2 < l2; ) {
                for (F(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + n2] < s2; )
                  a2++;
                for (; t2[2 * l2 + n2] > s2; )
                  l2--;
              }
              t2[2 * i2 + n2] === s2 ? F(e2, t2, i2, l2) : (l2++, F(e2, t2, l2, r2)), l2 <= o2 && (i2 = l2 + 1), o2 <= l2 && (r2 = l2 - 1);
            }
          }
          function F(e2, t2, o2, i2) {
            N(e2, o2, i2), N(t2, 2 * o2, 2 * i2), N(t2, 2 * o2 + 1, 2 * i2 + 1);
          }
          function N(e2, t2, o2) {
            const i2 = e2[t2];
            e2[t2] = e2[o2], e2[o2] = i2;
          }
          function A(e2, t2, o2, i2) {
            const r2 = e2 - o2, n2 = t2 - i2;
            return r2 * r2 + n2 * n2;
          }
          const G = (e2) => e2[0], J = (e2) => e2[1];
          class Z {
            constructor(e2, t2 = G, o2 = J, i2 = 64, r2 = Float64Array) {
              this.nodeSize = i2, this.points = e2;
              const n2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new n2(e2.length), a2 = this.coords = new r2(2 * e2.length);
              for (let i3 = 0; i3 < e2.length; i3++)
                s2[i3] = i3, a2[2 * i3] = t2(e2[i3]), a2[2 * i3 + 1] = o2(e2[i3]);
              O(s2, a2, i2, 0, s2.length - 1, 0);
            }
            range(e2, t2, o2, i2) {
              return function(e3, t3, o3, i3, r2, n2, s2) {
                const a2 = [0, e3.length - 1, 0], l2 = [];
                let c2, u2;
                for (; a2.length; ) {
                  const h2 = a2.pop(), f2 = a2.pop(), p2 = a2.pop();
                  if (f2 - p2 <= s2) {
                    for (let s3 = p2; s3 <= f2; s3++)
                      c2 = t3[2 * s3], u2 = t3[2 * s3 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e3[s3]);
                    continue;
                  }
                  const d2 = Math.floor((p2 + f2) / 2);
                  c2 = t3[2 * d2], u2 = t3[2 * d2 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e3[d2]);
                  const g2 = (h2 + 1) % 2;
                  (h2 === 0 ? o3 <= c2 : i3 <= u2) && (a2.push(p2), a2.push(d2 - 1), a2.push(g2)), (h2 === 0 ? r2 >= c2 : n2 >= u2) && (a2.push(d2 + 1), a2.push(f2), a2.push(g2));
                }
                return l2;
              }(this.ids, this.coords, e2, t2, o2, i2, this.nodeSize);
            }
            within(e2, t2, o2) {
              return function(e3, t3, o3, i2, r2, n2) {
                const s2 = [0, e3.length - 1, 0], a2 = [], l2 = r2 * r2;
                for (; s2.length; ) {
                  const c2 = s2.pop(), u2 = s2.pop(), h2 = s2.pop();
                  if (u2 - h2 <= n2) {
                    for (let r3 = h2; r3 <= u2; r3++)
                      A(t3[2 * r3], t3[2 * r3 + 1], o3, i2) <= l2 && a2.push(e3[r3]);
                    continue;
                  }
                  const f2 = Math.floor((h2 + u2) / 2), p2 = t3[2 * f2], d2 = t3[2 * f2 + 1];
                  A(p2, d2, o3, i2) <= l2 && a2.push(e3[f2]);
                  const g2 = (c2 + 1) % 2;
                  (c2 === 0 ? o3 - r2 <= p2 : i2 - r2 <= d2) && (s2.push(h2), s2.push(f2 - 1), s2.push(g2)), (c2 === 0 ? o3 + r2 >= p2 : i2 + r2 >= d2) && (s2.push(f2 + 1), s2.push(u2), s2.push(g2));
                }
                return a2;
              }(this.ids, this.coords, e2, t2, o2, this.nodeSize);
            }
          }
          const B = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, j = Math.fround || (Y = new Float32Array(1), (e2) => (Y[0] = +e2, Y[0]));
          var Y;
          class V {
            constructor(e2) {
              this.options = K(Object.create(B), e2), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e2) {
              const { log: t2, minZoom: o2, maxZoom: i2, nodeSize: r2 } = this.options;
              t2 && console.time("total time");
              const n2 = `prepare ${e2.length} points`;
              t2 && console.time(n2), this.points = e2;
              let s2 = [];
              for (let t3 = 0; t3 < e2.length; t3++)
                e2[t3].geometry && s2.push(R(e2[t3], t3));
              this.trees[i2 + 1] = new Z(s2, Q, ee, r2, Float32Array), t2 && console.timeEnd(n2);
              for (let e3 = i2; e3 >= o2; e3--) {
                const o3 = +Date.now();
                s2 = this._cluster(s2, e3), this.trees[e3] = new Z(s2, Q, ee, r2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - o3);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e2, t2) {
              let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
              const i2 = Math.max(-90, Math.min(90, e2[1]));
              let r2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
              const n2 = Math.max(-90, Math.min(90, e2[3]));
              if (e2[2] - e2[0] >= 360)
                o2 = -180, r2 = 180;
              else if (o2 > r2) {
                const e3 = this.getClusters([o2, i2, 180, n2], t2), s3 = this.getClusters([-180, i2, r2, n2], t2);
                return e3.concat(s3);
              }
              const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range($(o2), U(n2), $(r2), U(i2)), l2 = [];
              for (const e3 of a2) {
                const t3 = s2.points[e3];
                l2.push(t3.numPoints ? W(t3) : this.points[t3.index]);
              }
              return l2;
            }
            getChildren(e2) {
              const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", r2 = this.trees[o2];
              if (!r2)
                throw new Error(i2);
              const n2 = r2.points[t2];
              if (!n2)
                throw new Error(i2);
              const s2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = r2.within(n2.x, n2.y, s2), l2 = [];
              for (const t3 of a2) {
                const o3 = r2.points[t3];
                o3.parentId === e2 && l2.push(o3.numPoints ? W(o3) : this.points[o3.index]);
              }
              if (l2.length === 0)
                throw new Error(i2);
              return l2;
            }
            getLeaves(e2, t2, o2) {
              const i2 = [];
              return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
            }
            getTile(e2, t2, o2) {
              const i2 = this.trees[this._limitZoom(e2)], r2 = Math.pow(2, e2), { extent: n2, radius: s2 } = this.options, a2 = s2 / n2, l2 = (o2 - a2) / r2, c2 = (o2 + 1 + a2) / r2, u2 = { features: [] };
              return this._addTileFeatures(i2.range((t2 - a2) / r2, l2, (t2 + 1 + a2) / r2, c2), i2.points, t2, o2, r2, u2), t2 === 0 && this._addTileFeatures(i2.range(1 - a2 / r2, l2, 1, c2), i2.points, r2, o2, r2, u2), t2 === r2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / r2, c2), i2.points, -1, o2, r2, u2), u2.features.length ? u2 : null;
            }
            getClusterExpansionZoom(e2) {
              let t2 = this._getOriginZoom(e2) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const o2 = this.getChildren(e2);
                if (t2++, o2.length !== 1)
                  break;
                e2 = o2[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e2, t2, o2, i2, r2) {
              const n2 = this.getChildren(t2);
              for (const t3 of n2) {
                const n3 = t3.properties;
                if (n3 && n3.cluster ? r2 + n3.point_count <= i2 ? r2 += n3.point_count : r2 = this._appendLeaves(e2, n3.cluster_id, o2, i2, r2) : r2 < i2 ? r2++ : e2.push(t3), e2.length === o2)
                  break;
              }
              return r2;
            }
            _addTileFeatures(e2, t2, o2, i2, r2, n2) {
              for (const s2 of e2) {
                const e3 = t2[s2], a2 = e3.numPoints;
                let l2, c2, u2;
                if (a2)
                  l2 = q(e3), c2 = e3.x, u2 = e3.y;
                else {
                  const t3 = this.points[e3.index];
                  l2 = t3.properties, c2 = $(t3.geometry.coordinates[0]), u2 = U(t3.geometry.coordinates[1]);
                }
                const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i2))]], tags: l2 };
                let f2;
                a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), f2 !== void 0 && (h2.id = f2), n2.features.push(h2);
              }
            }
            _limitZoom(e2) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
            }
            _cluster(e2, t2) {
              const o2 = [], { radius: i2, extent: r2, reduce: n2, minPoints: s2 } = this.options, a2 = i2 / (r2 * Math.pow(2, t2));
              for (let i3 = 0; i3 < e2.length; i3++) {
                const r3 = e2[i3];
                if (r3.zoom <= t2)
                  continue;
                r3.zoom = t2;
                const l2 = this.trees[t2 + 1], c2 = l2.within(r3.x, r3.y, a2), u2 = r3.numPoints || 1;
                let h2 = u2;
                for (const e3 of c2) {
                  const o3 = l2.points[e3];
                  o3.zoom > t2 && (h2 += o3.numPoints || 1);
                }
                if (h2 > u2 && h2 >= s2) {
                  let e3 = r3.x * u2, s3 = r3.y * u2, a3 = n2 && u2 > 1 ? this._map(r3, true) : null;
                  const f2 = (i3 << 5) + (t2 + 1) + this.points.length;
                  for (const o3 of c2) {
                    const i4 = l2.points[o3];
                    if (i4.zoom <= t2)
                      continue;
                    i4.zoom = t2;
                    const c3 = i4.numPoints || 1;
                    e3 += i4.x * c3, s3 += i4.y * c3, i4.parentId = f2, n2 && (a3 || (a3 = this._map(r3, true)), n2(a3, this._map(i4)));
                  }
                  r3.parentId = f2, o2.push(X(e3 / h2, s3 / h2, f2, h2, a3));
                } else if (o2.push(r3), h2 > 1)
                  for (const e3 of c2) {
                    const i4 = l2.points[e3];
                    i4.zoom <= t2 || (i4.zoom = t2, o2.push(i4));
                  }
              }
              return o2;
            }
            _getOriginId(e2) {
              return e2 - this.points.length >> 5;
            }
            _getOriginZoom(e2) {
              return (e2 - this.points.length) % 32;
            }
            _map(e2, t2) {
              if (e2.numPoints)
                return t2 ? K({}, e2.properties) : e2.properties;
              const o2 = this.points[e2.index].properties, i2 = this.options.map(o2);
              return t2 && i2 === o2 ? K({}, i2) : i2;
            }
          }
          function X(e2, t2, o2, i2, r2) {
            return { x: j(e2), y: j(t2), zoom: 1 / 0, id: o2, parentId: -1, numPoints: i2, properties: r2 };
          }
          function R(e2, t2) {
            const [o2, i2] = e2.geometry.coordinates;
            return { x: j($(o2)), y: j(U(i2)), zoom: 1 / 0, index: t2, parentId: -1 };
          }
          function W(e2) {
            return { type: "Feature", id: e2.id, properties: q(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), H(e2.y)] } };
            var t2;
          }
          function q(e2) {
            const t2 = e2.numPoints, o2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
            return K(K({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: o2 });
          }
          function $(e2) {
            return e2 / 360 + 0.5;
          }
          function U(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function H(e2) {
            const t2 = (180 - 360 * e2) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function K(e2, t2) {
            for (const o2 in t2)
              e2[o2] = t2[o2];
            return e2;
          }
          function Q(e2) {
            return e2.x;
          }
          function ee(e2) {
            return e2.y;
          }
          function te(e2, t2, o2, i2) {
            for (var r2, n2 = i2, s2 = o2 - t2 >> 1, a2 = o2 - t2, l2 = e2[t2], c2 = e2[t2 + 1], u2 = e2[o2], h2 = e2[o2 + 1], f2 = t2 + 3; f2 < o2; f2 += 3) {
              var p2 = oe(e2[f2], e2[f2 + 1], l2, c2, u2, h2);
              if (p2 > n2)
                r2 = f2, n2 = p2;
              else if (p2 === n2) {
                var d2 = Math.abs(f2 - s2);
                d2 < a2 && (r2 = f2, a2 = d2);
              }
            }
            n2 > i2 && (r2 - t2 > 3 && te(e2, t2, r2, i2), e2[r2 + 2] = n2, o2 - r2 > 3 && te(e2, r2, o2, i2));
          }
          function oe(e2, t2, o2, i2, r2, n2) {
            var s2 = r2 - o2, a2 = n2 - i2;
            if (s2 !== 0 || a2 !== 0) {
              var l2 = ((e2 - o2) * s2 + (t2 - i2) * a2) / (s2 * s2 + a2 * a2);
              l2 > 1 ? (o2 = r2, i2 = n2) : l2 > 0 && (o2 += s2 * l2, i2 += a2 * l2);
            }
            return (s2 = e2 - o2) * s2 + (a2 = t2 - i2) * a2;
          }
          function ie(e2, t2, o2, i2) {
            var r2 = { id: e2 === void 0 ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e3) {
              var t3 = e3.geometry, o3 = e3.type;
              if (o3 === "Point" || o3 === "MultiPoint" || o3 === "LineString")
                re(e3, t3);
              else if (o3 === "Polygon" || o3 === "MultiLineString")
                for (var i3 = 0; i3 < t3.length; i3++)
                  re(e3, t3[i3]);
              else if (o3 === "MultiPolygon")
                for (i3 = 0; i3 < t3.length; i3++)
                  for (var r3 = 0; r3 < t3[i3].length; r3++)
                    re(e3, t3[i3][r3]);
            }(r2), r2;
          }
          function re(e2, t2) {
            for (var o2 = 0; o2 < t2.length; o2 += 3)
              e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
          }
          function ne(e2, t2, o2, i2) {
            if (t2.geometry) {
              var r2 = t2.geometry.coordinates, n2 = t2.geometry.type, s2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2), a2 = [], l2 = t2.id;
              if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), n2 === "Point")
                se(r2, a2);
              else if (n2 === "MultiPoint")
                for (var c2 = 0; c2 < r2.length; c2++)
                  se(r2[c2], a2);
              else if (n2 === "LineString")
                ae(r2, a2, s2, false);
              else if (n2 === "MultiLineString") {
                if (o2.lineMetrics) {
                  for (c2 = 0; c2 < r2.length; c2++)
                    ae(r2[c2], a2 = [], s2, false), e2.push(ie(l2, "LineString", a2, t2.properties));
                  return;
                }
                le(r2, a2, s2, false);
              } else if (n2 === "Polygon")
                le(r2, a2, s2, true);
              else {
                if (n2 !== "MultiPolygon") {
                  if (n2 === "GeometryCollection") {
                    for (c2 = 0; c2 < t2.geometry.geometries.length; c2++)
                      ne(e2, { id: l2, geometry: t2.geometry.geometries[c2], properties: t2.properties }, o2, i2);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (c2 = 0; c2 < r2.length; c2++) {
                  var u2 = [];
                  le(r2[c2], u2, s2, true), a2.push(u2);
                }
              }
              e2.push(ie(l2, n2, a2, t2.properties));
            }
          }
          function se(e2, t2) {
            t2.push(ce(e2[0])), t2.push(ue(e2[1])), t2.push(0);
          }
          function ae(e2, t2, o2, i2) {
            for (var r2, n2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
              var l2 = ce(e2[a2][0]), c2 = ue(e2[a2][1]);
              t2.push(l2), t2.push(c2), t2.push(0), a2 > 0 && (s2 += i2 ? (r2 * c2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - r2, 2) + Math.pow(c2 - n2, 2))), r2 = l2, n2 = c2;
            }
            var u2 = t2.length - 3;
            t2[2] = 1, te(t2, 0, u2, o2), t2[u2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
          }
          function le(e2, t2, o2, i2) {
            for (var r2 = 0; r2 < e2.length; r2++) {
              var n2 = [];
              ae(e2[r2], n2, o2, i2), t2.push(n2);
            }
          }
          function ce(e2) {
            return e2 / 360 + 0.5;
          }
          function ue(e2) {
            var t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function he(e2, t2, o2, i2, r2, n2, s2, a2) {
            if (i2 /= t2, n2 >= (o2 /= t2) && s2 < i2)
              return e2;
            if (s2 < o2 || n2 >= i2)
              return null;
            for (var l2 = [], c2 = 0; c2 < e2.length; c2++) {
              var u2 = e2[c2], h2 = u2.geometry, f2 = u2.type, p2 = r2 === 0 ? u2.minX : u2.minY, d2 = r2 === 0 ? u2.maxX : u2.maxY;
              if (p2 >= o2 && d2 < i2)
                l2.push(u2);
              else if (!(d2 < o2 || p2 >= i2)) {
                var g2 = [];
                if (f2 === "Point" || f2 === "MultiPoint")
                  fe(h2, g2, o2, i2, r2);
                else if (f2 === "LineString")
                  pe(h2, g2, o2, i2, r2, false, a2.lineMetrics);
                else if (f2 === "MultiLineString")
                  ge(h2, g2, o2, i2, r2, false);
                else if (f2 === "Polygon")
                  ge(h2, g2, o2, i2, r2, true);
                else if (f2 === "MultiPolygon")
                  for (var m2 = 0; m2 < h2.length; m2++) {
                    var y2 = [];
                    ge(h2[m2], y2, o2, i2, r2, true), y2.length && g2.push(y2);
                  }
                if (g2.length) {
                  if (a2.lineMetrics && f2 === "LineString") {
                    for (m2 = 0; m2 < g2.length; m2++)
                      l2.push(ie(u2.id, f2, g2[m2], u2.tags));
                    continue;
                  }
                  f2 !== "LineString" && f2 !== "MultiLineString" || (g2.length === 1 ? (f2 = "LineString", g2 = g2[0]) : f2 = "MultiLineString"), f2 !== "Point" && f2 !== "MultiPoint" || (f2 = g2.length === 3 ? "Point" : "MultiPoint"), l2.push(ie(u2.id, f2, g2, u2.tags));
                }
              }
            }
            return l2.length ? l2 : null;
          }
          function fe(e2, t2, o2, i2, r2) {
            for (var n2 = 0; n2 < e2.length; n2 += 3) {
              var s2 = e2[n2 + r2];
              s2 >= o2 && s2 <= i2 && (t2.push(e2[n2]), t2.push(e2[n2 + 1]), t2.push(e2[n2 + 2]));
            }
          }
          function pe(e2, t2, o2, i2, r2, n2, s2) {
            for (var a2, l2, c2 = de(e2), u2 = r2 === 0 ? ye : ve, h2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
              var p2 = e2[f2], d2 = e2[f2 + 1], g2 = e2[f2 + 2], m2 = e2[f2 + 3], y2 = e2[f2 + 4], v2 = r2 === 0 ? p2 : d2, x2 = r2 === 0 ? m2 : y2, w2 = false;
              s2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(d2 - y2, 2))), v2 < o2 ? x2 > o2 && (l2 = u2(c2, p2, d2, m2, y2, o2), s2 && (c2.start = h2 + a2 * l2)) : v2 > i2 ? x2 < i2 && (l2 = u2(c2, p2, d2, m2, y2, i2), s2 && (c2.start = h2 + a2 * l2)) : me(c2, p2, d2, g2), x2 < o2 && v2 >= o2 && (l2 = u2(c2, p2, d2, m2, y2, o2), w2 = true), x2 > i2 && v2 <= i2 && (l2 = u2(c2, p2, d2, m2, y2, i2), w2 = true), !n2 && w2 && (s2 && (c2.end = h2 + a2 * l2), t2.push(c2), c2 = de(e2)), s2 && (h2 += a2);
            }
            var S2 = e2.length - 3;
            p2 = e2[S2], d2 = e2[S2 + 1], g2 = e2[S2 + 2], (v2 = r2 === 0 ? p2 : d2) >= o2 && v2 <= i2 && me(c2, p2, d2, g2), S2 = c2.length - 3, n2 && S2 >= 3 && (c2[S2] !== c2[0] || c2[S2 + 1] !== c2[1]) && me(c2, c2[0], c2[1], c2[2]), c2.length && t2.push(c2);
          }
          function de(e2) {
            var t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function ge(e2, t2, o2, i2, r2, n2) {
            for (var s2 = 0; s2 < e2.length; s2++)
              pe(e2[s2], t2, o2, i2, r2, n2, false);
          }
          function me(e2, t2, o2, i2) {
            e2.push(t2), e2.push(o2), e2.push(i2);
          }
          function ye(e2, t2, o2, i2, r2, n2) {
            var s2 = (n2 - t2) / (i2 - t2);
            return e2.push(n2), e2.push(o2 + (r2 - o2) * s2), e2.push(1), s2;
          }
          function ve(e2, t2, o2, i2, r2, n2) {
            var s2 = (n2 - o2) / (r2 - o2);
            return e2.push(t2 + (i2 - t2) * s2), e2.push(n2), e2.push(1), s2;
          }
          function xe(e2, t2) {
            for (var o2 = [], i2 = 0; i2 < e2.length; i2++) {
              var r2, n2 = e2[i2], s2 = n2.type;
              if (s2 === "Point" || s2 === "MultiPoint" || s2 === "LineString")
                r2 = we(n2.geometry, t2);
              else if (s2 === "MultiLineString" || s2 === "Polygon") {
                r2 = [];
                for (var a2 = 0; a2 < n2.geometry.length; a2++)
                  r2.push(we(n2.geometry[a2], t2));
              } else if (s2 === "MultiPolygon")
                for (r2 = [], a2 = 0; a2 < n2.geometry.length; a2++) {
                  for (var l2 = [], c2 = 0; c2 < n2.geometry[a2].length; c2++)
                    l2.push(we(n2.geometry[a2][c2], t2));
                  r2.push(l2);
                }
              o2.push(ie(n2.id, s2, r2, n2.tags));
            }
            return o2;
          }
          function we(e2, t2) {
            var o2 = [];
            o2.size = e2.size, e2.start !== void 0 && (o2.start = e2.start, o2.end = e2.end);
            for (var i2 = 0; i2 < e2.length; i2 += 3)
              o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
            return o2;
          }
          function Se(e2, t2) {
            if (e2.transformed)
              return e2;
            var o2, i2, r2, n2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
            for (o2 = 0; o2 < e2.features.length; o2++) {
              var l2 = e2.features[o2], c2 = l2.geometry, u2 = l2.type;
              if (l2.geometry = [], u2 === 1)
                for (i2 = 0; i2 < c2.length; i2 += 2)
                  l2.geometry.push(Me(c2[i2], c2[i2 + 1], t2, n2, s2, a2));
              else
                for (i2 = 0; i2 < c2.length; i2++) {
                  var h2 = [];
                  for (r2 = 0; r2 < c2[i2].length; r2 += 2)
                    h2.push(Me(c2[i2][r2], c2[i2][r2 + 1], t2, n2, s2, a2));
                  l2.geometry.push(h2);
                }
            }
            return e2.transformed = true, e2;
          }
          function Me(e2, t2, o2, i2, r2, n2) {
            return [Math.round(o2 * (e2 * i2 - r2)), Math.round(o2 * (t2 * i2 - n2))];
          }
          function Ie(e2, t2, o2, i2, r2) {
            for (var n2 = t2 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t2) * r2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
              s2.numFeatures++, be(s2, e2[a2], n2, r2);
              var l2 = e2[a2].minX, c2 = e2[a2].minY, u2 = e2[a2].maxX, h2 = e2[a2].maxY;
              l2 < s2.minX && (s2.minX = l2), c2 < s2.minY && (s2.minY = c2), u2 > s2.maxX && (s2.maxX = u2), h2 > s2.maxY && (s2.maxY = h2);
            }
            return s2;
          }
          function be(e2, t2, o2, i2) {
            var r2 = t2.geometry, n2 = t2.type, s2 = [];
            if (n2 === "Point" || n2 === "MultiPoint")
              for (var a2 = 0; a2 < r2.length; a2 += 3)
                s2.push(r2[a2]), s2.push(r2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
            else if (n2 === "LineString")
              ke(s2, r2, e2, o2, false, false);
            else if (n2 === "MultiLineString" || n2 === "Polygon")
              for (a2 = 0; a2 < r2.length; a2++)
                ke(s2, r2[a2], e2, o2, n2 === "Polygon", a2 === 0);
            else if (n2 === "MultiPolygon")
              for (var l2 = 0; l2 < r2.length; l2++) {
                var c2 = r2[l2];
                for (a2 = 0; a2 < c2.length; a2++)
                  ke(s2, c2[a2], e2, o2, true, a2 === 0);
              }
            if (s2.length) {
              var u2 = t2.tags || null;
              if (n2 === "LineString" && i2.lineMetrics) {
                for (var h2 in u2 = {}, t2.tags)
                  u2[h2] = t2.tags[h2];
                u2.mapbox_clip_start = r2.start / r2.size, u2.mapbox_clip_end = r2.end / r2.size;
              }
              var f2 = { geometry: s2, type: n2 === "Polygon" || n2 === "MultiPolygon" ? 3 : n2 === "LineString" || n2 === "MultiLineString" ? 2 : 1, tags: u2 };
              t2.id !== null && (f2.id = t2.id), e2.features.push(f2);
            }
          }
          function ke(e2, t2, o2, i2, r2, n2) {
            var s2 = i2 * i2;
            if (i2 > 0 && t2.size < (r2 ? s2 : i2))
              o2.numPoints += t2.length / 3;
            else {
              for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
                (i2 === 0 || t2[l2 + 2] > s2) && (o2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), o2.numPoints++;
              r2 && function(e3, t3) {
                for (var o3 = 0, i3 = 0, r3 = e3.length, n3 = r3 - 2; i3 < r3; n3 = i3, i3 += 2)
                  o3 += (e3[i3] - e3[n3]) * (e3[i3 + 1] + e3[n3 + 1]);
                if (o3 > 0 === t3)
                  for (i3 = 0, r3 = e3.length; i3 < r3 / 2; i3 += 2) {
                    var s3 = e3[i3], a3 = e3[i3 + 1];
                    e3[i3] = e3[r3 - 2 - i3], e3[i3 + 1] = e3[r3 - 1 - i3], e3[r3 - 2 - i3] = s3, e3[r3 - 1 - i3] = a3;
                  }
              }(a2, n2), e2.push(a2);
            }
          }
          function Te(e2, t2) {
            var o2 = (t2 = this.options = function(e3, t3) {
              for (var o3 in t3)
                e3[o3] = t3[o3];
              return e3;
            }(Object.create(this.options), t2)).debug;
            if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var i2 = function(e3, t3) {
              var o3 = [];
              if (e3.type === "FeatureCollection")
                for (var i3 = 0; i3 < e3.features.length; i3++)
                  ne(o3, e3.features[i3], t3, i3);
              else
                ne(o3, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
              return o3;
            }(e2, t2);
            this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
              var o3 = t3.buffer / t3.extent, i3 = e3, r2 = he(e3, 1, -1 - o3, o3, 0, -1, 2, t3), n2 = he(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
              return (r2 || n2) && (i3 = he(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], r2 && (i3 = xe(r2, 1).concat(i3)), n2 && (i3 = i3.concat(xe(n2, -1)))), i3;
            }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function Pe(e2, t2, o2) {
            return 32 * ((1 << e2) * o2 + t2) + e2;
          }
          function Ce(e2, t2) {
            const o2 = e2.tileID.canonical;
            if (!this._geoJSONIndex)
              return t2(null, null);
            const i2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
            if (!i2)
              return t2(null, null);
            const r2 = new g(i2.features);
            let n2 = z(r2);
            n2.byteOffset === 0 && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: r2, rawData: n2.buffer });
          }
          Te.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, Te.prototype.splitTile = function(e2, t2, o2, i2, r2, n2, s2) {
            for (var a2 = [e2, t2, o2, i2], l2 = this.options, c2 = l2.debug; a2.length; ) {
              i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
              var u2 = 1 << t2, h2 = Pe(t2, o2, i2), f2 = this.tiles[h2];
              if (!f2 && (c2 > 1 && console.time("creation"), f2 = this.tiles[h2] = Ie(e2, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
                c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
                var p2 = "z" + t2;
                this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
              }
              if (f2.source = e2, r2) {
                if (t2 === l2.maxZoom || t2 === r2)
                  continue;
                var d2 = 1 << r2 - t2;
                if (o2 !== Math.floor(n2 / d2) || i2 !== Math.floor(s2 / d2))
                  continue;
              } else if (t2 === l2.indexMaxZoom || f2.numPoints <= l2.indexMaxPoints)
                continue;
              if (f2.source = null, e2.length !== 0) {
                c2 > 1 && console.time("clipping");
                var g2, m2, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, I2 = 0.5 + S2, b2 = 1 + S2;
                g2 = m2 = y2 = v2 = null, x2 = he(e2, u2, o2 - S2, o2 + I2, 0, f2.minX, f2.maxX, l2), w2 = he(e2, u2, o2 + M2, o2 + b2, 0, f2.minX, f2.maxX, l2), e2 = null, x2 && (g2 = he(x2, u2, i2 - S2, i2 + I2, 1, f2.minY, f2.maxY, l2), m2 = he(x2, u2, i2 + M2, i2 + b2, 1, f2.minY, f2.maxY, l2), x2 = null), w2 && (y2 = he(w2, u2, i2 - S2, i2 + I2, 1, f2.minY, f2.maxY, l2), v2 = he(w2, u2, i2 + M2, i2 + b2, 1, f2.minY, f2.maxY, l2), w2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(g2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(m2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(y2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
              }
            }
          }, Te.prototype.getTile = function(e2, t2, o2) {
            var i2 = this.options, r2 = i2.extent, n2 = i2.debug;
            if (e2 < 0 || e2 > 24)
              return null;
            var s2 = 1 << e2, a2 = Pe(e2, t2 = (t2 % s2 + s2) % s2, o2);
            if (this.tiles[a2])
              return Se(this.tiles[a2], r2);
            n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
            for (var l2, c2 = e2, u2 = t2, h2 = o2; !l2 && c2 > 0; )
              c2--, u2 = Math.floor(u2 / 2), h2 = Math.floor(h2 / 2), l2 = this.tiles[Pe(c2, u2, h2)];
            return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", c2, u2, h2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, c2, u2, h2, e2, t2, o2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? Se(this.tiles[a2], r2) : null) : null;
          };
          class _e extends l {
            constructor(e2, t2, o2, i2) {
              super(e2, t2, o2, Ce), i2 && (this.loadGeoJSON = i2);
            }
            loadData(t2, o2) {
              var i2;
              (i2 = this._pendingRequest) === null || i2 === void 0 || i2.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
              const r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request);
              this._pendingCallback = o2, this._pendingRequest = this.loadGeoJSON(t2, (i3, n2) => {
                if (delete this._pendingCallback, delete this._pendingRequest, i3 || !n2)
                  return o2(i3);
                if (typeof n2 != "object")
                  return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                {
                  u(n2, true);
                  try {
                    if (t2.filter) {
                      const o3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if (o3.result === "error")
                        throw new Error(o3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                      const i4 = n2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2));
                      n2 = { type: "FeatureCollection", features: i4 };
                    }
                    this._geoJSONIndex = t2.cluster ? new V(function({ superclusterOptions: t3, clusterProperties: o3 }) {
                      if (!o3 || !t3)
                        return t3;
                      const i4 = {}, r3 = {}, n3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a2 = Object.keys(o3);
                      for (const t4 of a2) {
                        const [n4, s4] = o3[t4], a3 = e.createExpression(s4), l2 = e.createExpression(typeof n4 == "string" ? [n4, ["accumulated"], ["get", t4]] : n4);
                        i4[t4] = a3.value, r3[t4] = l2.value;
                      }
                      return t3.map = (e2) => {
                        s3.properties = e2;
                        const t4 = {};
                        for (const e3 of a2)
                          t4[e3] = i4[e3].evaluate(n3, s3);
                        return t4;
                      }, t3.reduce = (e2, t4) => {
                        s3.properties = t4;
                        for (const t5 of a2)
                          n3.accumulated = e2[t5], e2[t5] = r3[t5].evaluate(n3, s3);
                      }, t3;
                    }(t2)).load(n2.features) : function(e2, t3) {
                      return new Te(e2, t3);
                    }(n2, t2.geojsonVtOptions);
                  } catch (i4) {
                    return o2(i4);
                  }
                  this.loaded = {};
                  const s2 = {};
                  if (r2) {
                    const e2 = r2.finish();
                    e2 && (s2.resourceTiming = {}, s2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
                  }
                  o2(null, s2);
                }
              });
            }
            reloadTile(e2, t2) {
              const o2 = this.loaded;
              return o2 && o2[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
            }
            loadGeoJSON(t2, o2) {
              if (t2.request)
                return e.getJSON(t2.request, o2);
              if (typeof t2.data == "string")
                try {
                  o2(null, JSON.parse(t2.data));
                } catch (e2) {
                  o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              else
                o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              return { cancel: () => {
              } };
            }
            removeSource(e2, t2) {
              this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t2();
            }
            getClusterExpansionZoom(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterChildren(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterLeaves(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
              } catch (e3) {
                t2(e3);
              }
            }
          }
          class De {
            constructor(t2) {
              this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: _e }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
                if (this.workerSourceTypes[e2])
                  throw new Error(`Worker source with name "${e2}" already registered.`);
                this.workerSourceTypes[e2] = t3;
              }, this.self.registerRTLTextPlugin = (t3) => {
                if (e.plugin.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              };
            }
            setReferrer(e2, t2) {
              this.referrer = t2;
            }
            setImages(e2, t2, o2) {
              this.availableImages[e2] = t2;
              for (const o3 in this.workerSources[e2]) {
                const i2 = this.workerSources[e2][o3];
                for (const e3 in i2)
                  i2[e3].availableImages = t2;
              }
              o2();
            }
            setLayers(e2, t2, o2) {
              this.getLayerIndex(e2).replace(t2), o2();
            }
            updateLayers(e2, t2, o2) {
              this.getLayerIndex(e2).update(t2.layers, t2.removedIds), o2();
            }
            loadTile(e2, t2, o2) {
              this.getWorkerSource(e2, t2.type, t2.source).loadTile(t2, o2);
            }
            loadDEMTile(e2, t2, o2) {
              this.getDEMWorkerSource(e2, t2.source).loadTile(t2, o2);
            }
            reloadTile(e2, t2, o2) {
              this.getWorkerSource(e2, t2.type, t2.source).reloadTile(t2, o2);
            }
            abortTile(e2, t2, o2) {
              this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, o2);
            }
            removeTile(e2, t2, o2) {
              this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, o2);
            }
            removeDEMTile(e2, t2) {
              this.getDEMWorkerSource(e2, t2.source).removeTile(t2);
            }
            removeSource(e2, t2, o2) {
              if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
                return;
              const i2 = this.workerSources[e2][t2.type][t2.source];
              delete this.workerSources[e2][t2.type][t2.source], i2.removeSource !== void 0 ? i2.removeSource(t2, o2) : o2();
            }
            loadWorkerSource(e2, t2, o2) {
              try {
                this.self.importScripts(t2.url), o2();
              } catch (e3) {
                o2(e3.toString());
              }
            }
            syncRTLPluginState(t2, o2, i2) {
              try {
                e.plugin.setState(o2);
                const t3 = e.plugin.getPluginURL();
                if (e.plugin.isLoaded() && !e.plugin.isParsed() && t3 != null) {
                  this.self.importScripts(t3);
                  const o3 = e.plugin.isParsed();
                  i2(o3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), o3);
                }
              } catch (e2) {
                i2(e2.toString());
              }
            }
            getAvailableImages(e2) {
              let t2 = this.availableImages[e2];
              return t2 || (t2 = []), t2;
            }
            getLayerIndex(e2) {
              let t2 = this.layerIndexes[e2];
              return t2 || (t2 = this.layerIndexes[e2] = new i()), t2;
            }
            getWorkerSource(e2, t2, o2) {
              if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
                const i2 = { send: (t3, o3, i3) => {
                  this.actor.send(t3, o3, i3, e2);
                } };
                this.workerSources[e2][t2][o2] = new this.workerSourceTypes[t2](i2, this.getLayerIndex(e2), this.getAvailableImages(e2));
              }
              return this.workerSources[e2][t2][o2];
            }
            getDEMWorkerSource(e2, t2) {
              return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new c()), this.demWorkerSources[e2][t2];
            }
            enforceCacheSizeLimit(t2, o2) {
              e.enforceCacheSizeLimit(o2);
            }
          }
          return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope && (self.worker = new De(self)), De;
        });
        define2(["./shared"], function(t) {
          "use strict";
          var e = i;
          function i(t2) {
            return !function(t3) {
              return typeof window == "undefined" || typeof document == "undefined" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window))
                  return false;
                var t4, e3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
                try {
                  e3 = new Worker(o2), t4 = true;
                } catch (e4) {
                  t4 = false;
                }
                return e3 && e3.terminate(), URL.revokeObjectURL(o2), t4;
              }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                var t4 = document.createElement("canvas");
                t4.width = t4.height = 1;
                var e3 = t4.getContext("2d");
                if (!e3)
                  return false;
                var i2 = e3.getImageData(0, 0, 1, 1);
                return i2 && i2.width === t4.width;
              }() ? (o[e2 = t3 && t3.failIfMajorPerformanceCaveat] === void 0 && (o[e2] = function(t4) {
                var e3, o2 = function(t5) {
                  var e4 = document.createElement("canvas"), o3 = Object.create(i.webGLContextAttributes);
                  return o3.failIfMajorPerformanceCaveat = t5, e4.getContext("webgl", o3) || e4.getContext("experimental-webgl", o3);
                }(t4);
                if (!o2)
                  return false;
                try {
                  e3 = o2.createShader(o2.VERTEX_SHADER);
                } catch (t5) {
                  return false;
                }
                return !(!e3 || o2.isContextLost()) && (o2.shaderSource(e3, "void main() {}"), o2.compileShader(e3), o2.getShaderParameter(e3, o2.COMPILE_STATUS) === true);
              }(e2)), o[e2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
              var e2;
            }(t2);
          }
          var o = {};
          function a(t2, e2) {
            if (Array.isArray(t2)) {
              if (!Array.isArray(e2) || t2.length !== e2.length)
                return false;
              for (let i2 = 0; i2 < t2.length; i2++)
                if (!a(t2[i2], e2[i2]))
                  return false;
              return true;
            }
            if (typeof t2 == "object" && t2 !== null && e2 !== null) {
              if (typeof e2 != "object")
                return false;
              if (Object.keys(t2).length !== Object.keys(e2).length)
                return false;
              for (const i2 in t2)
                if (!a(t2[i2], e2[i2]))
                  return false;
              return true;
            }
            return t2 === e2;
          }
          i.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
          class s {
            static testProp(t2) {
              if (!s.docStyle)
                return t2[0];
              for (let e2 = 0; e2 < t2.length; e2++)
                if (t2[e2] in s.docStyle)
                  return t2[e2];
              return t2[0];
            }
            static create(t2, e2, i2) {
              const o2 = window.document.createElement(t2);
              return e2 !== void 0 && (o2.className = e2), i2 && i2.appendChild(o2), o2;
            }
            static createNS(t2, e2) {
              return window.document.createElementNS(t2, e2);
            }
            static disableDrag() {
              s.docStyle && s.selectProp && (s.userSelect = s.docStyle[s.selectProp], s.docStyle[s.selectProp] = "none");
            }
            static enableDrag() {
              s.docStyle && s.selectProp && (s.docStyle[s.selectProp] = s.userSelect);
            }
            static setTransform(t2, e2) {
              t2.style[s.transformProp] = e2;
            }
            static addEventListener(t2, e2, i2, o2 = {}) {
              t2.addEventListener(e2, i2, "passive" in o2 ? o2 : o2.capture);
            }
            static removeEventListener(t2, e2, i2, o2 = {}) {
              t2.removeEventListener(e2, i2, "passive" in o2 ? o2 : o2.capture);
            }
            static suppressClickInternal(t2) {
              t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", s.suppressClickInternal, true);
            }
            static suppressClick() {
              window.addEventListener("click", s.suppressClickInternal, true), window.setTimeout(() => {
                window.removeEventListener("click", s.suppressClickInternal, true);
              }, 0);
            }
            static mousePos(e2, i2) {
              const o2 = e2.getBoundingClientRect();
              return new t.pointGeometry(i2.clientX - o2.left - e2.clientLeft, i2.clientY - o2.top - e2.clientTop);
            }
            static touchPos(e2, i2) {
              const o2 = e2.getBoundingClientRect(), a2 = [];
              for (let s2 = 0; s2 < i2.length; s2++)
                a2.push(new t.pointGeometry(i2[s2].clientX - o2.left - e2.clientLeft, i2[s2].clientY - o2.top - e2.clientTop));
              return a2;
            }
            static mouseButton(t2) {
              return t2.button;
            }
            static remove(t2) {
              t2.parentNode && t2.parentNode.removeChild(t2);
            }
          }
          s.docStyle = typeof window != "undefined" && window.document && window.document.documentElement.style, s.selectProp = s.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), s.transformProp = s.testProp(["transform", "WebkitTransform"]);
          class r {
            constructor(t2) {
              this._transformRequestFn = t2;
            }
            transformRequest(t2, e2) {
              return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
            }
            normalizeSpriteURL(t2, e2, i2) {
              const o2 = function(t3) {
                const e3 = t3.match(n);
                if (!e3)
                  throw new Error(`Unable to parse URL "${t3}"`);
                return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
              }(t2);
              return o2.path += `${e2}${i2}`, function(t3) {
                const e3 = t3.params.length ? `?${t3.params.join("&")}` : "";
                return `${t3.protocol}://${t3.authority}${t3.path}${e3}`;
              }(o2);
            }
            setTransformRequest(t2) {
              this._transformRequestFn = t2;
            }
          }
          const n = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function l(e2) {
            var i2 = new t.ARRAY_TYPE(3);
            return i2[0] = e2[0], i2[1] = e2[1], i2[2] = e2[2], i2;
          }
          var c, h = function(t2, e2, i2) {
            return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
          };
          c = new t.ARRAY_TYPE(3), t.ARRAY_TYPE != Float32Array && (c[0] = 0, c[1] = 0, c[2] = 0);
          var u = function(t2) {
            var e2 = t2[0], i2 = t2[1];
            return e2 * e2 + i2 * i2;
          };
          !function() {
            var e2 = new t.ARRAY_TYPE(2);
            t.ARRAY_TYPE != Float32Array && (e2[0] = 0, e2[1] = 0);
          }();
          class d {
            constructor(t2, e2, i2, o2) {
              this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e2, o2);
            }
            update(e2, i2, o2) {
              const { width: a2, height: s2 } = e2, r2 = !(this.size && this.size[0] === a2 && this.size[1] === s2 || o2), { context: n2 } = this, { gl: l2 } = n2;
              if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || i2.premultiply !== false)), r2)
                this.size = [a2, s2], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.isImageBitmap(e2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a2, s2, 0, this.format, l2.UNSIGNED_BYTE, e2.data);
              else {
                const { x: i3, y: r3 } = o2 || { x: 0, y: 0 };
                e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.isImageBitmap(e2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, l2.RGBA, l2.UNSIGNED_BYTE, e2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, a2, s2, l2.RGBA, l2.UNSIGNED_BYTE, e2.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
            }
            bind(t2, e2, i2) {
              const { context: o2 } = this, { gl: a2 } = o2;
              a2.bindTexture(a2.TEXTURE_2D, this.texture), i2 !== a2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = a2.LINEAR), t2 !== this.filter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, t2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e2 !== this.wrap && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, e2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, e2), this.wrap = e2);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }
          function _(t2) {
            const { userImage: e2 } = t2;
            return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
          }
          class m extends t.Evented {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(t2) {
              if (this.loaded !== t2 && (this.loaded = t2, t2)) {
                for (const { ids: t3, callback: e2 } of this.requestors)
                  this._notify(t3, e2);
                this.requestors = [];
              }
            }
            getImage(t2) {
              return this.images[t2];
            }
            addImage(t2, e2) {
              this._validate(t2, e2) && (this.images[t2] = e2);
            }
            _validate(e2, i2) {
              let o2 = true;
              return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "content" value`))), o2 = false), o2;
            }
            _validateStretch(t2, e2) {
              if (!t2)
                return true;
              let i2 = 0;
              for (const o2 of t2) {
                if (o2[0] < i2 || o2[1] < o2[0] || e2 < o2[1])
                  return false;
                i2 = o2[1];
              }
              return true;
            }
            _validateContent(t2, e2) {
              return !(t2 && (t2.length !== 4 || t2[0] < 0 || e2.data.width < t2[0] || t2[1] < 0 || e2.data.height < t2[1] || t2[2] < 0 || e2.data.width < t2[2] || t2[3] < 0 || e2.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
            }
            updateImage(t2, e2) {
              e2.version = this.images[t2].version + 1, this.images[t2] = e2, this.updatedImages[t2] = true;
            }
            removeImage(t2) {
              const e2 = this.images[t2];
              delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(t2, e2) {
              let i2 = true;
              if (!this.isLoaded())
                for (const e3 of t2)
                  this.images[e3] || (i2 = false);
              this.isLoaded() || i2 ? this._notify(t2, e2) : this.requestors.push({ ids: t2, callback: e2 });
            }
            _notify(e2, i2) {
              const o2 = {};
              for (const i3 of e2) {
                this.images[i3] || this.fire(new t.Event("styleimagemissing", { id: i3 }));
                const e3 = this.images[i3];
                e3 ? o2[i3] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              i2(null, o2);
            }
            getPixelSize() {
              const { width: t2, height: e2 } = this.atlasImage;
              return { width: t2, height: e2 };
            }
            getPattern(e2) {
              const i2 = this.patterns[e2], o2 = this.getImage(e2);
              if (!o2)
                return null;
              if (i2 && i2.position.version === o2.version)
                return i2.position;
              if (i2)
                i2.position.version = o2.version;
              else {
                const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(i3, o2);
                this.patterns[e2] = { bin: i3, position: a2 };
              }
              return this._updatePatternAtlas(), this.patterns[e2].position;
            }
            bind(t2) {
              const e2 = t2.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new d(t2, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e2 = [];
              for (const t2 in this.patterns)
                e2.push(this.patterns[t2].bin);
              const { w: i2, h: o2 } = t.potpack(e2), a2 = this.atlasImage;
              a2.resize({ width: i2 || 1, height: o2 || 1 });
              for (const e3 in this.patterns) {
                const { bin: i3 } = this.patterns[e3], o3 = i3.x + 1, s2 = i3.y + 1, r2 = this.images[e3].data, n2 = r2.width, l2 = r2.height;
                t.RGBAImage.copy(r2, a2, { x: 0, y: 0 }, { x: o3, y: s2 }, { width: n2, height: l2 }), t.RGBAImage.copy(r2, a2, { x: 0, y: l2 - 1 }, { x: o3, y: s2 - 1 }, { width: n2, height: 1 }), t.RGBAImage.copy(r2, a2, { x: 0, y: 0 }, { x: o3, y: s2 + l2 }, { width: n2, height: 1 }), t.RGBAImage.copy(r2, a2, { x: n2 - 1, y: 0 }, { x: o3 - 1, y: s2 }, { width: 1, height: l2 }), t.RGBAImage.copy(r2, a2, { x: 0, y: 0 }, { x: o3 + n2, y: s2 }, { width: 1, height: l2 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(t2) {
              for (const e2 of t2) {
                if (this.callbackDispatchedThisFrame[e2])
                  continue;
                this.callbackDispatchedThisFrame[e2] = true;
                const t3 = this.images[e2];
                _(t3) && this.updateImage(e2, t3);
              }
            }
          }
          const p = 1e20;
          function f(t2, e2, i2, o2, a2, s2, r2, n2, l2) {
            for (let c2 = e2; c2 < e2 + o2; c2++)
              g(t2, i2 * s2 + c2, s2, a2, r2, n2, l2);
            for (let c2 = i2; c2 < i2 + a2; c2++)
              g(t2, c2 * s2 + e2, 1, o2, r2, n2, l2);
          }
          function g(t2, e2, i2, o2, a2, s2, r2) {
            s2[0] = 0, r2[0] = -p, r2[1] = p, a2[0] = t2[e2];
            for (let n2 = 1, l2 = 0, c2 = 0; n2 < o2; n2++) {
              a2[n2] = t2[e2 + n2 * i2];
              const o3 = n2 * n2;
              do {
                const t3 = s2[l2];
                c2 = (a2[n2] - a2[t3] + o3 - t3 * t3) / (n2 - t3) / 2;
              } while (c2 <= r2[l2] && --l2 > -1);
              l2++, s2[l2] = n2, r2[l2] = c2, r2[l2 + 1] = p;
            }
            for (let n2 = 0, l2 = 0; n2 < o2; n2++) {
              for (; r2[l2 + 1] < n2; )
                l2++;
              const o3 = s2[l2], c2 = n2 - o3;
              t2[e2 + n2 * i2] = a2[o3] + c2 * c2;
            }
          }
          class x {
            constructor(t2, e2) {
              this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
            }
            setURL(t2) {
              this.url = t2;
            }
            getGlyphs(e2, i2) {
              const o2 = [];
              for (const t2 in e2)
                for (const i3 of e2[t2])
                  o2.push({ stack: t2, id: i3 });
              t.asyncAll(o2, ({ stack: t2, id: e3 }, i3) => {
                let o3 = this.entries[t2];
                o3 || (o3 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
                let a2 = o3.glyphs[e3];
                if (a2 !== void 0)
                  return void i3(null, { stack: t2, id: e3, glyph: a2 });
                if (a2 = this._tinySDF(o3, t2, e3), a2)
                  return o3.glyphs[e3] = a2, void i3(null, { stack: t2, id: e3, glyph: a2 });
                const s2 = Math.floor(e3 / 256);
                if (256 * s2 > 65535)
                  return void i3(new Error("glyphs > 65535 not supported"));
                if (o3.ranges[s2])
                  return void i3(null, { stack: t2, id: e3, glyph: a2 });
                let r2 = o3.requests[s2];
                r2 || (r2 = o3.requests[s2] = [], x.loadGlyphRange(t2, s2, this.url, this.requestManager, (t3, e4) => {
                  if (e4) {
                    for (const t4 in e4)
                      this._doesCharSupportLocalGlyph(+t4) || (o3.glyphs[+t4] = e4[+t4]);
                    o3.ranges[s2] = true;
                  }
                  for (const i4 of r2)
                    i4(t3, e4);
                  delete o3.requests[s2];
                })), r2.push((o4, a3) => {
                  o4 ? i3(o4) : a3 && i3(null, { stack: t2, id: e3, glyph: a3[e3] || null });
                });
              }, (t2, e3) => {
                if (t2)
                  i2(t2);
                else if (e3) {
                  const t3 = {};
                  for (const { stack: i3, id: o3, glyph: a2 } of e3)
                    (t3[i3] || (t3[i3] = {}))[o3] = a2 && { id: a2.id, bitmap: a2.bitmap.clone(), metrics: a2.metrics };
                  i2(null, t3);
                }
              });
            }
            _doesCharSupportLocalGlyph(e2) {
              return !!this.localIdeographFontFamily && (t.unicodeBlockLookup["CJK Unified Ideographs"](e2) || t.unicodeBlockLookup["Hangul Syllables"](e2) || t.unicodeBlockLookup.Hiragana(e2) || t.unicodeBlockLookup.Katakana(e2));
            }
            _tinySDF(e2, i2, o2) {
              const a2 = this.localIdeographFontFamily;
              if (!a2)
                return;
              if (!this._doesCharSupportLocalGlyph(o2))
                return;
              let s2 = e2.tinySDF;
              if (!s2) {
                let t2 = "400";
                /bold/i.test(i2) ? t2 = "900" : /medium/i.test(i2) ? t2 = "500" : /light/i.test(i2) && (t2 = "200"), s2 = e2.tinySDF = new x.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: a2, fontWeight: t2 });
              }
              const r2 = s2.draw(String.fromCharCode(o2));
              return { id: o2, bitmap: new t.AlphaImage({ width: r2.width || 30, height: r2.height || 30 }, r2.data), metrics: { width: r2.glyphWidth || 24, height: r2.glyphHeight || 24, left: r2.glyphLeft || 0, top: r2.glyphTop - 27 || -8, advance: r2.glyphAdvance || 24 } };
            }
          }
          x.loadGlyphRange = function(e2, i2, o2, a2, s2) {
            const r2 = 256 * i2, n2 = r2 + 255, l2 = a2.transformRequest(o2.replace("{fontstack}", e2).replace("{range}", `${r2}-${n2}`), t.ResourceType.Glyphs);
            t.getArrayBuffer(l2, (e3, i3) => {
              if (e3)
                s2(e3);
              else if (i3) {
                const e4 = {};
                for (const o3 of t.parseGlyphPBF(i3))
                  e4[o3.id] = o3;
                s2(null, e4);
              }
            });
          }, x.TinySDF = class {
            constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: i2 = 8, cutoff: o2 = 0.25, fontFamily: a2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: r2 = "normal" } = {}) {
              this.buffer = e2, this.cutoff = o2, this.radius = i2;
              const n2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(n2), c2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              c2.font = `${r2} ${s2} ${t2}px ${a2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
            }
            _createCanvas(t2) {
              const e2 = document.createElement("canvas");
              return e2.width = e2.height = t2, e2;
            }
            draw(t2) {
              const { width: e2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: o2, actualBoundingBoxLeft: a2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), r2 = Math.ceil(i2), n2 = Math.min(this.size - this.buffer, Math.ceil(s2 - a2)), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(o2)), c2 = n2 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, u2 = Math.max(c2 * h2, 0), d2 = new Uint8ClampedArray(u2), _2 = { data: d2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l2, glyphTop: r2, glyphLeft: 0, glyphAdvance: e2 };
              if (n2 === 0 || l2 === 0)
                return _2;
              const { ctx: m2, buffer: g2, gridInner: x2, gridOuter: v2 } = this;
              m2.clearRect(g2, g2, n2, l2), m2.fillText(t2, g2, g2 + r2);
              const y2 = m2.getImageData(g2, g2, n2, l2);
              v2.fill(p, 0, u2), x2.fill(0, 0, u2);
              for (let t3 = 0; t3 < l2; t3++)
                for (let e3 = 0; e3 < n2; e3++) {
                  const i3 = y2.data[4 * (t3 * n2 + e3) + 3] / 255;
                  if (i3 === 0)
                    continue;
                  const o3 = (t3 + g2) * c2 + e3 + g2;
                  if (i3 === 1)
                    v2[o3] = 0, x2[o3] = p;
                  else {
                    const t4 = 0.5 - i3;
                    v2[o3] = t4 > 0 ? t4 * t4 : 0, x2[o3] = t4 < 0 ? t4 * t4 : 0;
                  }
                }
              f(v2, 0, 0, c2, h2, c2, this.f, this.v, this.z), f(x2, g2, g2, n2, l2, c2, this.f, this.v, this.z);
              for (let t3 = 0; t3 < u2; t3++) {
                const e3 = Math.sqrt(v2[t3]) - Math.sqrt(x2[t3]);
                d2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
              }
              return _2;
            }
          };
          const v = new t.Properties({ anchor: new t.DataConstantProperty(t.spec.light.anchor), position: new class {
            constructor() {
              this.specification = t.spec.light.position;
            }
            possiblyEvaluate(e2, i2) {
              return t.sphericalToCartesian(e2.expression.evaluate(i2));
            }
            interpolate(e2, i2, o2) {
              return { x: t.number(e2.x, i2.x, o2), y: t.number(e2.y, i2.y, o2), z: t.number(e2.z, i2.z, o2) };
            }
          }(), color: new t.DataConstantProperty(t.spec.light.color), intensity: new t.DataConstantProperty(t.spec.light.intensity) }), y = "-transition";
          class b extends t.Evented {
            constructor(e2) {
              super(), this._transitionable = new t.Transitionable(v), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e2, i2 = {}) {
              if (!this._validate(t.validateLight, e2, i2))
                for (const t2 in e2) {
                  const i3 = e2[t2];
                  t2.endsWith(y) ? this._transitionable.setTransition(t2.slice(0, -y.length), i3) : this._transitionable.setValue(t2, i3);
                }
            }
            updateTransitions(t2) {
              this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t2) {
              this.properties = this._transitioning.possiblyEvaluate(t2);
            }
            _validate(e2, i2, o2) {
              return (!o2 || o2.validate !== false) && t.emitValidationErrors(this, e2.call(t.validateStyle, t.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.spec })));
            }
          }
          class w {
            constructor(t2, e2) {
              this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(t2, e2) {
              const i2 = t2.join(",") + String(e2);
              return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
            }
            getDashRanges(t2, e2, i2) {
              const o2 = [];
              let a2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, s2 = t2[0] * i2, r2 = true;
              o2.push({ left: a2, right: s2, isDash: r2, zeroLength: t2[0] === 0 });
              let n2 = t2[0];
              for (let e3 = 1; e3 < t2.length; e3++) {
                r2 = !r2;
                const l2 = t2[e3];
                a2 = n2 * i2, n2 += l2, s2 = n2 * i2, o2.push({ left: a2, right: s2, isDash: r2, zeroLength: l2 === 0 });
              }
              return o2;
            }
            addRoundDash(t2, e2, i2) {
              const o2 = e2 / 2;
              for (let e3 = -i2; e3 <= i2; e3++) {
                const a2 = this.width * (this.nextRow + i2 + e3);
                let s2 = 0, r2 = t2[s2];
                for (let n2 = 0; n2 < this.width; n2++) {
                  n2 / r2.right > 1 && (r2 = t2[++s2]);
                  const l2 = Math.abs(n2 - r2.left), c2 = Math.abs(n2 - r2.right), h2 = Math.min(l2, c2);
                  let u2;
                  const d2 = e3 / i2 * (o2 + 1);
                  if (r2.isDash) {
                    const t3 = o2 - Math.abs(d2);
                    u2 = Math.sqrt(h2 * h2 + t3 * t3);
                  } else
                    u2 = o2 - Math.sqrt(h2 * h2 + d2 * d2);
                  this.data[a2 + n2] = Math.max(0, Math.min(255, u2 + 128));
                }
              }
            }
            addRegularDash(t2) {
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                const i3 = t2[e3], o3 = t2[e3 + 1];
                i3.zeroLength ? t2.splice(e3, 1) : o3 && o3.isDash === i3.isDash && (o3.left = i3.left, t2.splice(e3, 1));
              }
              const e2 = t2[0], i2 = t2[t2.length - 1];
              e2.isDash === i2.isDash && (e2.left = i2.left - this.width, i2.right = e2.right + this.width);
              const o2 = this.width * this.nextRow;
              let a2 = 0, s2 = t2[a2];
              for (let e3 = 0; e3 < this.width; e3++) {
                e3 / s2.right > 1 && (s2 = t2[++a2]);
                const i3 = Math.abs(e3 - s2.left), r2 = Math.abs(e3 - s2.right), n2 = Math.min(i3, r2);
                this.data[o2 + e3] = Math.max(0, Math.min(255, (s2.isDash ? n2 : -n2) + 128));
              }
            }
            addDash(e2, i2) {
              const o2 = i2 ? 7 : 0, a2 = 2 * o2 + 1;
              if (this.nextRow + a2 > this.height)
                return t.warnOnce("LineAtlas out of space"), null;
              let s2 = 0;
              for (let t2 = 0; t2 < e2.length; t2++)
                s2 += e2[t2];
              if (s2 !== 0) {
                const t2 = this.width / s2, a3 = this.getDashRanges(e2, this.width, t2);
                i2 ? this.addRoundDash(a3, t2, o2) : this.addRegularDash(a3);
              }
              const r2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: s2 };
              return this.nextRow += a2, this.dirty = true, r2;
            }
            bind(t2) {
              const e2 = t2.gl;
              this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
            }
          }
          class T {
            constructor(e2, i2) {
              this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
              const o2 = this.workerPool.acquire(this.id);
              for (let t2 = 0; t2 < o2.length; t2++) {
                const e3 = new T.Actor(o2[t2], i2, this.id);
                e3.name = `Worker ${t2}`, this.actors.push(e3);
              }
            }
            broadcast(e2, i2, o2) {
              t.asyncAll(this.actors, (t2, o3) => {
                t2.send(e2, i2, o3);
              }, o2 = o2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
              this.actors.forEach((t2) => {
                t2.remove();
              }), this.actors = [], this.workerPool.release(this.id);
            }
          }
          function E(e2, i2, o2) {
            const a2 = function(i3, a3) {
              if (i3)
                return o2(i3);
              if (a3) {
                const i4 = t.pick(t.extend(a3, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                a3.vector_layers && (i4.vectorLayers = a3.vector_layers, i4.vectorLayerIds = i4.vectorLayers.map((t2) => t2.id)), o2(null, i4);
              }
            };
            return e2.url ? t.getJSON(i2.transformRequest(e2.url, t.ResourceType.Source), a2) : t.exported.frame(() => a2(null, e2));
          }
          T.Actor = t.Actor;
          class I {
            constructor(e2, i2, o2) {
              this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
            }
            validateBounds(t2) {
              return Array.isArray(t2) && t2.length === 4 ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
            }
            contains(e2) {
              const i2 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), a2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), s2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), r2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
              return e2.x >= o2 && e2.x < s2 && e2.y >= a2 && e2.y < r2;
            }
          }
          class S extends t.Evented {
            constructor(e2, i2, o2, a2) {
              if (super(), this.id = e2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(a2);
            }
            load() {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = E(this._options, this.map._requestManager, (e2, i2) => {
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e2 ? this.fire(new t.ErrorEvent(e2)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new I(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setSourceProperty(t2) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t2(), this.load();
            }
            setTiles(t2) {
              return this.setSourceProperty(() => {
                this._options.tiles = t2;
              }), this;
            }
            setUrl(t2) {
              return this.setSourceProperty(() => {
                this.url = t2, this._options.url = t2;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.extend({}, this._options);
            }
            loadTile(e2, i2) {
              const o2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              function s2(o3, a3) {
                return delete e2.request, e2.aborted ? i2(null) : o3 && o3.status !== 404 ? i2(o3) : (a3 && a3.resourceTiming && (e2.resourceTiming = a3.resourceTiming), this.map._refreshExpiredTiles && a3 && e2.setExpiryData(a3), e2.loadVectorData(a3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (e2.reloadCallback && (this.loadTile(e2, e2.reloadCallback), e2.reloadCallback = null)));
              }
              a2.request.collectResourceTiming = this._collectResourceTiming, e2.actor && e2.state !== "expired" ? e2.state === "loading" ? e2.reloadCallback = i2 : e2.request = e2.actor.send("reloadTile", a2, s2.bind(this)) : (e2.actor = this.dispatcher.getActor(), e2.request = e2.actor.send("loadTile", a2, s2.bind(this)));
            }
            abortTile(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
            }
            unloadTile(t2) {
              t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
            }
            hasTransition() {
              return false;
            }
          }
          class C extends t.Evented {
            constructor(e2, i2, o2, a2) {
              super(), this.id = e2, this.dispatcher = o2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, i2), t.extend(this, t.pick(i2, ["url", "scheme", "tileSize"]));
            }
            load() {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = E(this._options, this.map._requestManager, (e2, i2) => {
                this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new t.ErrorEvent(e2)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new I(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.extend({}, this._options);
            }
            hasTile(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }
            loadTile(e2, i2) {
              const o2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e2.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (o3, a2, s2) => {
                if (delete e2.request, e2.aborted)
                  e2.state = "unloaded", i2(null);
                else if (o3)
                  e2.state = "errored", i2(o3);
                else if (a2) {
                  this.map._refreshExpiredTiles && e2.setExpiryData(s2);
                  const o4 = this.map.painter.context, r2 = o4.gl;
                  e2.texture = this.map.painter.getTileTexture(a2.width), e2.texture ? e2.texture.update(a2, { useMipmap: true }) : (e2.texture = new d(o4, a2, r2.RGBA, { useMipmap: true }), e2.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST), o4.extTextureFilterAnisotropic && r2.texParameterf(r2.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), e2.state = "loaded", t.cacheEntryPossiblyAdded(this.dispatcher), i2(null);
                }
              });
            }
            abortTile(t2, e2) {
              t2.request && (t2.request.cancel(), delete t2.request), e2();
            }
            unloadTile(t2, e2) {
              t2.texture && this.map.painter.saveTileTexture(t2.texture), e2();
            }
            hasTransition() {
              return false;
            }
          }
          let D;
          class z extends C {
            constructor(e2, i2, o2, a2) {
              super(e2, i2, o2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
            }
            serialize() {
              return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
            }
            loadTile(e2, i2) {
              const o2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              function a2(t2, o3) {
                t2 && (e2.state = "errored", i2(t2)), o3 && (e2.dem = o3, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded", i2(null));
              }
              e2.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), function(o3, s2) {
                if (delete e2.request, e2.aborted)
                  e2.state = "unloaded", i2(null);
                else if (o3)
                  e2.state = "errored", i2(o3);
                else if (s2) {
                  this.map._refreshExpiredTiles && e2.setExpiryData(s2), delete s2.cacheControl, delete s2.expires;
                  const i3 = t.isImageBitmap(s2) && (D == null && (D = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), D) ? s2 : t.exported.getImageData(s2, 1), o4 = { uid: e2.uid, coord: e2.tileID, source: this.id, rawImageData: i3, encoding: this.encoding };
                  e2.actor && e2.state !== "expired" || (e2.actor = this.dispatcher.getActor(), e2.actor.send("loadDEMTile", o4, a2.bind(this)));
                }
              }.bind(this)), e2.neighboringTiles = this._getNeighboringTiles(e2.tileID);
            }
            _getNeighboringTiles(e2) {
              const i2 = e2.canonical, o2 = Math.pow(2, i2.z), a2 = (i2.x - 1 + o2) % o2, s2 = i2.x === 0 ? e2.wrap - 1 : e2.wrap, r2 = (i2.x + 1 + o2) % o2, n2 = i2.x + 1 === o2 ? e2.wrap + 1 : e2.wrap, l2 = {};
              return l2[new t.OverscaledTileID(e2.overscaledZ, s2, i2.z, a2, i2.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.OverscaledTileID(e2.overscaledZ, s2, i2.z, a2, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new t.OverscaledTileID(e2.overscaledZ, s2, i2.z, a2, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }), l2;
            }
            unloadTile(t2) {
              t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
            }
          }
          class P extends t.Evented {
            constructor(e2, i2, o2, a2) {
              super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = o2.getActor(), this.setEventedParent(a2), this._data = i2.data, this._options = t.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== void 0 && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
              const s2 = t.EXTENT / this.tileSize;
              this.workerOptions = t.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (i2.buffer !== void 0 ? i2.buffer : 128) * s2, tolerance: (i2.tolerance !== void 0 ? i2.tolerance : 0.375) * s2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== void 0 ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.EXTENT, radius: (i2.clusterRadius || 50) * s2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
            }
            load() {
              this._updateWorkerData("metadata");
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setData(t2) {
              return this._data = t2, this._updateWorkerData("content"), this;
            }
            getClusterExpansionZoom(t2, e2) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e2), this;
            }
            getClusterChildren(t2, e2) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e2), this;
            }
            getClusterLeaves(t2, e2, i2, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e2, offset: i2 }, o2), this;
            }
            _updateWorkerData(e2) {
              const i2 = t.extend({}, this.workerOptions), o2 = this._data;
              typeof o2 == "string" ? (i2.request = this.map._requestManager.transformRequest(t.exported.resolveURL(o2), t.ResourceType.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoads++, this.fire(new t.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i2, (i3, o3) => {
                if (this._pendingLoads--, this._removed || o3 && o3.abandoned)
                  return void this.fire(new t.Event("dataabort", { dataType: "source", sourceDataType: e2 }));
                let a2 = null;
                if (o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (a2 = o3.resourceTiming[this.id].slice(0)), i3)
                  return void this.fire(new t.ErrorEvent(i3));
                const s2 = { dataType: "source", sourceDataType: e2 };
                this._collectResourceTiming && a2 && a2.length > 0 && t.extend(s2, { resourceTiming: a2 }), this.fire(new t.Event("data", s2));
              });
            }
            loaded() {
              return this._pendingLoads === 0;
            }
            loadTile(t2, e2) {
              const i2 = t2.actor ? "reloadTile" : "loadTile";
              t2.actor = this.actor;
              const o2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t2.request = this.actor.send(i2, o2, (o3, a2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? e2(null) : o3 ? e2(o3) : (t2.loadVectorData(a2, this.map.painter, i2 === "reloadTile"), e2(null))));
            }
            abortTile(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
            }
            unloadTile(t2) {
              t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
            }
            onRemove() {
              this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
            }
            serialize() {
              return t.extend({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }
          var A = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class M extends t.Evented {
            constructor(t2, e2, i2, o2) {
              super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = e2;
            }
            load(e2, i2) {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (o2, a2) => {
                this._loaded = true, o2 ? this.fire(new t.ErrorEvent(o2)) : a2 && (this.image = a2, e2 && (this.coordinates = e2), i2 && i2(), this._finishLoading());
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t2) {
              return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, () => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setCoordinates(e2) {
              this.coordinates = e2;
              const i2 = e2.map(t.MercatorCoordinate.fromLngLat);
              this.tileID = function(e3) {
                let i3 = 1 / 0, o3 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
                for (const t2 of e3)
                  i3 = Math.min(i3, t2.x), o3 = Math.min(o3, t2.y), a2 = Math.max(a2, t2.x), s2 = Math.max(s2, t2.y);
                const r2 = Math.max(a2 - i3, s2 - o3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n2);
                return new t.CanonicalTileID(n2, Math.floor((i3 + a2) / 2 * l2), Math.floor((o3 + s2) / 2 * l2));
              }(i2), this.minzoom = this.maxzoom = this.tileID.z;
              const o2 = i2.map((t2) => this.tileID.getTilePoint(t2)._round());
              return this._boundsArray = new t.RasterBoundsArray(), this._boundsArray.emplaceBack(o2[0].x, o2[0].y, 0, 0), this._boundsArray.emplaceBack(o2[1].x, o2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(o2[3].x, o2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(o2[2].x, o2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            prepare() {
              if (Object.keys(this.tiles).length === 0 || !this.image)
                return;
              const e2 = this.map.painter.context, i2 = e2.gl;
              this.boundsBuffer || (this.boundsBuffer = e2.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new d(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              for (const t2 in this.tiles) {
                const e3 = this.tiles[t2];
                e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
              }
            }
            loadTile(t2, e2) {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e2(null)) : (t2.state = "errored", e2(null));
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
          }
          class R extends M {
            constructor(t2, e2, i2, o2) {
              super(t2, e2, i2, o2), this.roundZoom = true, this.type = "video", this.options = e2;
            }
            load() {
              this._loaded = false;
              const e2 = this.options;
              this.urls = [];
              for (const i2 of e2.urls)
                this.urls.push(this.map._requestManager.transformRequest(i2, t.ResourceType.Source).url);
              t.getVideo(this.urls, (e3, i2) => {
                this._loaded = true, e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (this.video = i2, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e2) {
              if (this.video) {
                const i2 = this.video.seekable;
                e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(t2) {
              this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                return;
              const e2 = this.map.painter.context, i2 = e2.gl;
              this.boundsBuffer || (this.boundsBuffer = e2.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new d(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              for (const t2 in this.tiles) {
                const e3 = this.tiles[t2];
                e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
              }
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }
          class L extends M {
            constructor(e2, i2, o2, a2) {
              super(e2, i2, o2, a2), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((t2) => !Array.isArray(t2) || t2.length !== 2 || t2.some((t3) => typeof t3 != "number")) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === void 0 || i2.animate;
            }
            load() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(t2) {
              this.map = t2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let e2 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions())
                return;
              if (Object.keys(this.tiles).length === 0)
                return;
              const i2 = this.map.painter.context, o2 = i2.gl;
              this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new d(i2, this.canvas, o2.RGBA, { premultiply: true });
              for (const t2 in this.tiles) {
                const e3 = this.tiles[t2];
                e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
              }
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const t2 of [this.canvas.width, this.canvas.height])
                if (isNaN(t2) || t2 <= 0)
                  return true;
              return false;
            }
          }
          const k = { vector: S, raster: C, "raster-dem": z, geojson: P, video: R, image: M, canvas: L };
          function B(e2, i2) {
            const o2 = t.create();
            return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.multiply(o2, o2, e2.calculatePosMatrix(i2.toUnwrapped()));
          }
          function F(t2, e2, i2, o2, a2, s2) {
            const r2 = function(t3, e3, i3) {
              if (t3)
                for (const o3 of t3) {
                  const t4 = e3[o3];
                  if (t4 && t4.source === i3 && t4.type === "fill-extrusion")
                    return true;
                }
              else
                for (const t4 in e3) {
                  const o3 = e3[t4];
                  if (o3.source === i3 && o3.type === "fill-extrusion")
                    return true;
                }
              return false;
            }(a2 && a2.layers, e2, t2.id), n2 = s2.maxPitchScaleFactor(), l2 = t2.tilesIn(o2, n2, r2);
            l2.sort(O);
            const c2 = [];
            for (const o3 of l2)
              c2.push({ wrappedTileID: o3.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(e2, i2, t2._state, o3.queryGeometry, o3.cameraQueryGeometry, o3.scale, a2, s2, n2, B(t2.transform, o3.tileID)) });
            const h2 = function(t3) {
              const e3 = {}, i3 = {};
              for (const o3 of t3) {
                const t4 = o3.queryResults, a3 = o3.wrappedTileID, s3 = i3[a3] = i3[a3] || {};
                for (const i4 in t4) {
                  const o4 = t4[i4], a4 = s3[i4] = s3[i4] || {}, r3 = e3[i4] = e3[i4] || [];
                  for (const t5 of o4)
                    a4[t5.featureIndex] || (a4[t5.featureIndex] = true, r3.push(t5));
                }
              }
              return e3;
            }(c2);
            for (const e3 in h2)
              h2[e3].forEach((e4) => {
                const i3 = e4.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
                i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
              });
            return h2;
          }
          function O(t2, e2) {
            const i2 = t2.tileID, o2 = e2.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          class U {
            constructor(e2, i2) {
              this.tileID = e2, this.uid = t.uniqueId(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.textures = [], this.textureCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(e2) {
              const i2 = e2 + this.timeAdded;
              i2 < t.exported.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
            }
            wasRequested() {
              return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
            }
            clearTextures(t2) {
              this.demTexture && t2.saveTileTexture(this.demTexture), this.textures.forEach((e2) => t2.saveTileTexture(e2)), this.demTexture = null, this.textures = [], this.textureCoords = {};
            }
            loadVectorData(e2, i2, o2) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
                e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(t2, e3) {
                  const i3 = {};
                  if (!e3)
                    return i3;
                  for (const o3 of t2) {
                    const t3 = o3.layerIds.map((t4) => e3.getLayer(t4)).filter(Boolean);
                    if (t3.length !== 0) {
                      o3.layers = t3, o3.stateDependentLayerIds && (o3.stateDependentLayers = o3.stateDependentLayerIds.map((e4) => t3.filter((t4) => t4.id === e4)[0]));
                      for (const e4 of t3)
                        i3[e4.id] = o3;
                    }
                  }
                  return i3;
                }(e2.buckets, i2.style), this.hasSymbolBuckets = false;
                for (const e3 in this.buckets) {
                  const i3 = this.buckets[e3];
                  if (i3 instanceof t.SymbolBucket) {
                    if (this.hasSymbolBuckets = true, !o2)
                      break;
                    i3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const e3 in this.buckets) {
                    const i3 = this.buckets[e3];
                    if (i3 instanceof t.SymbolBucket && i3.hasRTLText) {
                      this.hasRTLText = true, t.lazyLoadRTLTextPlugin();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const t2 in this.buckets) {
                  const e3 = this.buckets[t2];
                  this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t2).queryRadius(e3));
                }
                e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
              } else
                this.collisionBoxArray = new t.CollisionBoxArray();
            }
            unloadVectorData() {
              for (const t2 in this.buckets)
                this.buckets[t2].destroy();
              this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(t2) {
              return this.buckets[t2.id];
            }
            upload(t2) {
              for (const e3 in this.buckets) {
                const i2 = this.buckets[e3];
                i2.uploadPending() && i2.upload(t2);
              }
              const e2 = t2.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new d(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new d(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(t2) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t2, e2, i2, o2, a2, s2, r2, n2, l2, c2) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: o2, cameraQueryGeometry: a2, scale: s2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: r2, queryPadding: this.queryPadding * l2 }, t2, e2, i2) : {};
            }
            querySourceFeatures(e2, i2) {
              const o2 = this.latestFeatureIndex;
              if (!o2 || !o2.rawTileData)
                return;
              const a2 = o2.loadVTLayers(), s2 = i2 ? i2.sourceLayer : "", r2 = a2._geojsonTileLayer || a2[s2];
              if (!r2)
                return;
              const n2 = t.createFilter(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
              for (let i3 = 0; i3 < r2.length; i3++) {
                const a3 = r2.feature(i3);
                if (n2.needGeometry) {
                  const e3 = t.toEvaluationFeature(a3, true);
                  if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), e3, this.tileID.canonical))
                    continue;
                } else if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), a3))
                  continue;
                const d2 = o2.getId(a3, s2), _2 = new t.GeoJSONFeature(a3, l2, c2, h2, d2);
                _2.tile = u2, e2.push(_2);
              }
            }
            hasData() {
              return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e2) {
              const i2 = this.expirationTime;
              if (e2.cacheControl) {
                const i3 = t.parseCacheControl(e2.cacheControl);
                i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
              } else
                e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
              if (this.expirationTime) {
                const t2 = Date.now();
                let e3 = false;
                if (this.expirationTime > t2)
                  e3 = false;
                else if (i2)
                  if (this.expirationTime < i2)
                    e3 = true;
                  else {
                    const o2 = this.expirationTime - i2;
                    o2 ? this.expirationTime = t2 + Math.max(o2, 3e4) : e3 = true;
                  }
                else
                  e3 = true;
                e3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t2, e2) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t2).length === 0)
                return;
              const i2 = this.latestFeatureIndex.loadVTLayers();
              for (const o2 in this.buckets) {
                if (!e2.style.hasLayer(o2))
                  continue;
                const a2 = this.buckets[o2], s2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i2[s2], n2 = t2[s2];
                if (!r2 || !n2 || Object.keys(n2).length === 0)
                  continue;
                a2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l2 = e2 && e2.style && e2.style.getLayer(o2);
                l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a2)));
              }
            }
            holdingForFade() {
              return this.symbolFadeHoldUntil !== void 0;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t.exported.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e2) {
              this.symbolFadeHoldUntil = t.exported.now() + e2;
            }
            setDependencies(t2, e2) {
              const i2 = {};
              for (const t3 of e2)
                i2[t3] = true;
              this.dependencies[t2] = i2;
            }
            hasDependency(t2, e2) {
              for (const i2 of t2) {
                const t3 = this.dependencies[i2];
                if (t3) {
                  for (const i3 of e2)
                    if (t3[i3])
                      return true;
                }
              }
              return false;
            }
          }
          class N {
            constructor(t2, e2) {
              this.max = t2, this.onRemove = e2, this.reset();
            }
            reset() {
              for (const t2 in this.data)
                for (const e2 of this.data[t2])
                  e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
              return this.data = {}, this.order = [], this;
            }
            add(t2, e2, i2) {
              const o2 = t2.wrapped().key;
              this.data[o2] === void 0 && (this.data[o2] = []);
              const a2 = { value: e2, timeout: void 0 };
              if (i2 !== void 0 && (a2.timeout = setTimeout(() => {
                this.remove(t2, a2);
              }, i2)), this.data[o2].push(a2), this.order.push(o2), this.order.length > this.max) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            has(t2) {
              return t2.wrapped().key in this.data;
            }
            getAndRemove(t2) {
              return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
            }
            _getAndRemoveByKey(t2) {
              const e2 = this.data[t2].shift();
              return e2.timeout && clearTimeout(e2.timeout), this.data[t2].length === 0 && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
            }
            getByKey(t2) {
              const e2 = this.data[t2];
              return e2 ? e2[0].value : null;
            }
            get(t2) {
              return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
            }
            remove(t2, e2) {
              if (!this.has(t2))
                return this;
              const i2 = t2.wrapped().key, o2 = e2 === void 0 ? 0 : this.data[i2].indexOf(e2), a2 = this.data[i2][o2];
              return this.data[i2].splice(o2, 1), a2.timeout && clearTimeout(a2.timeout), this.data[i2].length === 0 && delete this.data[i2], this.onRemove(a2.value), this.order.splice(this.order.indexOf(i2), 1), this;
            }
            setMaxSize(t2) {
              for (this.max = t2; this.order.length > this.max; ) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            filter(t2) {
              const e2 = [];
              for (const i2 in this.data)
                for (const o2 of this.data[i2])
                  t2(o2.value) || e2.push(o2);
              for (const t3 of e2)
                this.remove(t3.value.tileID, t3);
            }
          }
          class G {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e2, i2, o2) {
              const a2 = String(i2);
              if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][a2] = this.stateChanges[e2][a2] || {}, t.extend(this.stateChanges[e2][a2], o2), this.deletedStates[e2] === null) {
                this.deletedStates[e2] = {};
                for (const t2 in this.state[e2])
                  t2 !== a2 && (this.deletedStates[e2][t2] = null);
              } else if (this.deletedStates[e2] && this.deletedStates[e2][a2] === null) {
                this.deletedStates[e2][a2] = {};
                for (const t2 in this.state[e2][a2])
                  o2[t2] || (this.deletedStates[e2][a2][t2] = null);
              } else
                for (const t2 in o2)
                  this.deletedStates[e2] && this.deletedStates[e2][a2] && this.deletedStates[e2][a2][t2] === null && delete this.deletedStates[e2][a2][t2];
            }
            removeFeatureState(t2, e2, i2) {
              if (this.deletedStates[t2] === null)
                return;
              const o2 = String(e2);
              if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && e2 !== void 0)
                this.deletedStates[t2][o2] !== null && (this.deletedStates[t2][o2] = this.deletedStates[t2][o2] || {}, this.deletedStates[t2][o2][i2] = null);
              else if (e2 !== void 0)
                if (this.stateChanges[t2] && this.stateChanges[t2][o2])
                  for (i2 in this.deletedStates[t2][o2] = {}, this.stateChanges[t2][o2])
                    this.deletedStates[t2][o2][i2] = null;
                else
                  this.deletedStates[t2][o2] = null;
              else
                this.deletedStates[t2] = null;
            }
            getState(e2, i2) {
              const o2 = String(i2), a2 = t.extend({}, (this.state[e2] || {})[o2], (this.stateChanges[e2] || {})[o2]);
              if (this.deletedStates[e2] === null)
                return {};
              if (this.deletedStates[e2]) {
                const t2 = this.deletedStates[e2][i2];
                if (t2 === null)
                  return {};
                for (const e3 in t2)
                  delete a2[e3];
              }
              return a2;
            }
            initializeTileState(t2, e2) {
              t2.setFeatureState(this.state, e2);
            }
            coalesceChanges(e2, i2) {
              const o2 = {};
              for (const e3 in this.stateChanges) {
                this.state[e3] = this.state[e3] || {};
                const i3 = {};
                for (const o3 in this.stateChanges[e3])
                  this.state[e3][o3] || (this.state[e3][o3] = {}), t.extend(this.state[e3][o3], this.stateChanges[e3][o3]), i3[o3] = this.state[e3][o3];
                o2[e3] = i3;
              }
              for (const e3 in this.deletedStates) {
                this.state[e3] = this.state[e3] || {};
                const i3 = {};
                if (this.deletedStates[e3] === null)
                  for (const t2 in this.state[e3])
                    i3[t2] = {}, this.state[e3][t2] = {};
                else
                  for (const t2 in this.deletedStates[e3]) {
                    if (this.deletedStates[e3][t2] === null)
                      this.state[e3][t2] = {};
                    else
                      for (const i4 of Object.keys(this.deletedStates[e3][t2]))
                        delete this.state[e3][t2][i4];
                    i3[t2] = this.state[e3][t2];
                  }
                o2[e3] = o2[e3] || {}, t.extend(o2[e3], i3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o2).length !== 0)
                for (const t2 in e2)
                  e2[t2].setFeatureState(o2, i2);
            }
          }
          class Z extends t.Evented {
            constructor(e2, i2, o2) {
              super(), this.id = e2, this.dispatcher = o2, this.on("data", (t2) => {
                t2.dataType === "source" && t2.sourceDataType === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t2.dataType === "source" && t2.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain));
              }), this.on("dataloading", () => {
                this._sourceErrored = false;
              }), this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }), this._source = function(e3, i3, o3, a2) {
                const s2 = new k[i3.type](e3, i3, o3, a2);
                if (s2.id !== e3)
                  throw new Error(`Expected Source id to be ${e3} instead of ${s2.id}`);
                return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], s2), s2;
              }(e2, i2, o2, this), this._tiles = {}, this._cache = new N(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new G();
            }
            onAdd(t2) {
              this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
            }
            onRemove(t2) {
              this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              for (const t2 in this._tiles) {
                const e2 = this._tiles[t2];
                if (e2.state !== "loaded" && e2.state !== "errored")
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const t2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(t2, e2) {
              return this._source.loadTile(t2, e2);
            }
            _unloadTile(t2) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t2, () => {
                });
            }
            _abortTile(e2) {
              this._source.abortTile && this._source.abortTile(e2, () => {
              }), this._source.fire(new t.Event("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(t2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const e2 in this._tiles) {
                const i2 = this._tiles[e2];
                i2.upload(t2), i2.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((t2) => t2.tileID).sort(q).map((t2) => t2.key);
            }
            getRenderableIds(e2) {
              const i2 = [];
              for (const t2 in this._tiles)
                this._isIdRenderable(t2, e2) && i2.push(this._tiles[t2]);
              return e2 ? i2.sort((e3, i3) => {
                const o2 = e3.tileID, a2 = i3.tileID, s2 = new t.pointGeometry(o2.canonical.x, o2.canonical.y)._rotate(this.transform.angle), r2 = new t.pointGeometry(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle);
                return o2.overscaledZ - a2.overscaledZ || r2.y - s2.y || r2.x - s2.x;
              }).map((t2) => t2.tileID.key) : i2.map((t2) => t2.tileID).sort(q).map((t2) => t2.key);
            }
            hasRenderableParent(t2) {
              const e2 = this.findLoadedParent(t2, 0);
              return !!e2 && this._isIdRenderable(e2.tileID.key);
            }
            _isIdRenderable(t2, e2) {
              return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t2 in this._tiles)
                  this._tiles[t2].state !== "errored" && this._reloadTile(t2, "reloading");
              }
            }
            _reloadTile(t2, e2) {
              const i2 = this._tiles[t2];
              i2 && (i2.state !== "loading" && (i2.state = e2), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2, e2)));
            }
            _tileLoaded(e2, i2, o2, a2) {
              if (a2)
                return e2.state = "errored", void (a2.status !== 404 ? this._source.fire(new t.ErrorEvent(a2, { tile: e2 })) : this.update(this.transform, this.terrain));
              e2.timeAdded = t.exported.now(), o2 === "expired" && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e2), this.getSource().type === "raster-dem" && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.Event("data", { dataType: "source", tile: e2, coord: e2.tileID }));
            }
            _backfillDEM(t2) {
              const e2 = this.getRenderableIds();
              for (let o2 = 0; o2 < e2.length; o2++) {
                const a2 = e2[o2];
                if (t2.neighboringTiles && t2.neighboringTiles[a2]) {
                  const e3 = this.getTileByID(a2);
                  i2(t2, e3), i2(e3, t2);
                }
              }
              function i2(t3, e3) {
                t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true;
                let i3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
                const o2 = e3.tileID.canonical.y - t3.tileID.canonical.y, a2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
                i3 === 0 && o2 === 0 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (Math.abs(i3 + a2) === 1 ? i3 += a2 : Math.abs(i3 - a2) === 1 && (i3 -= a2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, i3, o2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
              }
            }
            getTile(t2) {
              return this.getTileByID(t2.key);
            }
            getTileByID(t2) {
              return this._tiles[t2];
            }
            _retainLoadedChildren(t2, e2, i2, o2) {
              for (const a2 in this._tiles) {
                let s2 = this._tiles[a2];
                if (o2[a2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > i2)
                  continue;
                let r2 = s2.tileID;
                for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
                  const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
                  s2 = this._tiles[t3.key], s2 && s2.hasData() && (r2 = t3);
                }
                let n2 = r2;
                for (; n2.overscaledZ > e2; )
                  if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                    o2[r2.key] = r2;
                    break;
                  }
              }
            }
            findLoadedParent(t2, e2) {
              if (t2.key in this._loadedParentTiles) {
                const i2 = this._loadedParentTiles[t2.key];
                return i2 && i2.tileID.overscaledZ >= e2 ? i2 : null;
              }
              for (let i2 = t2.overscaledZ - 1; i2 >= e2; i2--) {
                const e3 = t2.scaledTo(i2), o2 = this._getLoadedTile(e3);
                if (o2)
                  return o2;
              }
            }
            _getLoadedTile(t2) {
              const e2 = this._tiles[t2.key];
              return e2 && e2.hasData() ? e2 : this._cache.getByKey(t2.wrapped().key);
            }
            updateCacheSize(t2) {
              const e2 = Math.ceil(t2.width / this._source.tileSize) + 1, i2 = Math.ceil(t2.height / this._source.tileSize) + 1, o2 = Math.floor(e2 * i2 * 5), a2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, o2) : o2;
              this._cache.setMaxSize(a2);
            }
            handleWrapJump(t2) {
              const e2 = Math.round((t2 - (this._prevLng === void 0 ? t2 : this._prevLng)) / 360);
              if (this._prevLng = t2, e2) {
                const t3 = {};
                for (const i2 in this._tiles) {
                  const o2 = this._tiles[i2];
                  o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + e2), t3[o2.tileID.key] = o2;
                }
                this._tiles = t3;
                for (const t4 in this._timers)
                  clearTimeout(this._timers[t4]), delete this._timers[t4];
                for (const t4 in this._tiles)
                  this._setTileReloadTimer(t4, this._tiles[t4]);
              }
            }
            update(e2, i2) {
              if (this.transform = e2, this.terrain = i2, !this._sourceLoaded || this._paused)
                return;
              let o2;
              this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t.OverscaledTileID(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (o2 = e2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2 }), this._source.hasTile && (o2 = o2.filter((t2) => this._source.hasTile(t2)))) : o2 = [];
              const a2 = e2.coveringZoomLevel(this._source), s2 = Math.max(a2 - Z.maxOverzooming, this._source.minzoom), r2 = Math.max(a2 + Z.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                const t2 = {};
                for (const e3 of o2)
                  if (e3.canonical.z > this._source.minzoom) {
                    const i3 = e3.scaledTo(e3.canonical.z - 1);
                    t2[i3.key] = i3;
                    const o3 = e3.scaledTo(Math.max(this._source.minzoom, Math.min(e3.canonical.z, 5)));
                    t2[o3.key] = o3;
                  }
                o2 = o2.concat(Object.values(t2));
              }
              const n2 = this._updateRetainedTiles(o2, a2);
              if (V(this._source.type)) {
                const e3 = {}, l3 = {}, c2 = Object.keys(n2);
                for (const i3 of c2) {
                  const o3 = n2[i3], a3 = this._tiles[i3];
                  if (!a3 || a3.fadeEndTime && a3.fadeEndTime <= t.exported.now())
                    continue;
                  const r3 = this.findLoadedParent(o3, s2);
                  r3 && (this._addTile(r3.tileID), e3[r3.tileID.key] = r3.tileID), l3[i3] = o3;
                }
                this._retainLoadedChildren(l3, a2, r2, n2);
                for (const t2 in e3)
                  n2[t2] || (this._coveredTiles[t2] = true, n2[t2] = e3[t2]);
                if (i2) {
                  const t2 = {}, e4 = {};
                  for (const i3 of o2)
                    this._tiles[i3.key].hasData() ? t2[i3.key] = i3 : e4[i3.key] = i3;
                  for (const i3 in e4) {
                    const o3 = e4[i3].children(this._source.maxzoom);
                    this._tiles[o3[0].key] && this._tiles[o3[1].key] && this._tiles[o3[2].key] && this._tiles[o3[3].key] && (t2[o3[0].key] = n2[o3[0].key] = o3[0], t2[o3[1].key] = n2[o3[1].key] = o3[1], t2[o3[2].key] = n2[o3[2].key] = o3[2], t2[o3[3].key] = n2[o3[3].key] = o3[3], delete e4[i3]);
                  }
                  for (const i3 in e4) {
                    const o3 = this.findLoadedParent(e4[i3], this._source.minzoom);
                    if (o3) {
                      t2[o3.tileID.key] = n2[o3.tileID.key] = o3.tileID;
                      for (const e5 in t2)
                        t2[e5].isChildOf(o3.tileID) && delete t2[e5];
                    }
                  }
                  for (const e5 in this._tiles)
                    t2[e5] || (this._coveredTiles[e5] = true);
                }
              }
              for (const t2 in n2)
                this._tiles[t2].clearFadeHold();
              const l2 = t.keysDifference(this._tiles, n2);
              for (const t2 of l2) {
                const e3 = this._tiles[t2];
                e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(t2);
              }
              this._updateLoadedParentTileCache();
            }
            releaseSymbolFadeTiles() {
              for (const t2 in this._tiles)
                this._tiles[t2].holdingForFade() && this._removeTile(t2);
            }
            _updateRetainedTiles(t2, e2) {
              const i2 = {}, o2 = {}, a2 = Math.max(e2 - Z.maxOverzooming, this._source.minzoom), s2 = Math.max(e2 + Z.maxUnderzooming, this._source.minzoom), r2 = {};
              for (const o3 of t2) {
                const t3 = this._addTile(o3);
                i2[o3.key] = o3, t3.hasData() || e2 < this._source.maxzoom && (r2[o3.key] = o3);
              }
              this._retainLoadedChildren(r2, e2, s2, i2);
              for (const s3 of t2) {
                let t3 = this._tiles[s3.key];
                if (t3.hasData())
                  continue;
                if (e2 + 1 > this._source.maxzoom) {
                  const t4 = s3.children(this._source.maxzoom)[0], e3 = this.getTile(t4);
                  if (e3 && e3.hasData()) {
                    i2[t4.key] = t4;
                    continue;
                  }
                } else {
                  const t4 = s3.children(this._source.maxzoom);
                  if (i2[t4[0].key] && i2[t4[1].key] && i2[t4[2].key] && i2[t4[3].key])
                    continue;
                }
                let r3 = t3.wasRequested();
                for (let e3 = s3.overscaledZ - 1; e3 >= a2; --e3) {
                  const a3 = s3.scaledTo(e3);
                  if (o2[a3.key])
                    break;
                  if (o2[a3.key] = true, t3 = this.getTile(a3), !t3 && r3 && (t3 = this._addTile(a3)), t3 && (i2[a3.key] = a3, r3 = t3.wasRequested(), t3.hasData()))
                    break;
                }
              }
              return i2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const t2 in this._tiles) {
                const e2 = [];
                let i2, o2 = this._tiles[t2].tileID;
                for (; o2.overscaledZ > 0; ) {
                  if (o2.key in this._loadedParentTiles) {
                    i2 = this._loadedParentTiles[o2.key];
                    break;
                  }
                  e2.push(o2.key);
                  const t3 = o2.scaledTo(o2.overscaledZ - 1);
                  if (i2 = this._getLoadedTile(t3), i2)
                    break;
                  o2 = t3;
                }
                for (const t3 of e2)
                  this._loadedParentTiles[t3] = i2;
              }
            }
            _addTile(e2) {
              let i2 = this._tiles[e2.key];
              if (i2)
                return i2;
              i2 = this._cache.getAndRemove(e2), i2 && (this._setTileReloadTimer(e2.key, i2), i2.tileID = e2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i2)));
              const o2 = i2;
              return i2 || (i2 = new U(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i2, this._tileLoaded.bind(this, i2, e2.key, i2.state))), i2.uses++, this._tiles[e2.key] = i2, o2 || this._source.fire(new t.Event("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
            }
            _setTileReloadTimer(t2, e2) {
              t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
              const i2 = e2.getExpiryTimeout();
              i2 && (this._timers[t2] = setTimeout(() => {
                this._reloadTile(t2, "expired"), delete this._timers[t2];
              }, i2));
            }
            _removeTile(t2) {
              const e2 = this._tiles[t2];
              e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const t2 in this._tiles)
                this._removeTile(t2);
              this._cache.reset();
            }
            tilesIn(e2, i2, o2) {
              const a2 = [], s2 = this.transform;
              if (!s2)
                return a2;
              const r2 = o2 ? s2.getCameraQueryGeometry(e2) : e2, n2 = e2.map((t2) => s2.pointCoordinate(t2, this.terrain)), l2 = r2.map((t2) => s2.pointCoordinate(t2, this.terrain)), c2 = this.getIds();
              let h2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
              for (const t2 of l2)
                h2 = Math.min(h2, t2.x), u2 = Math.min(u2, t2.y), d2 = Math.max(d2, t2.x), _2 = Math.max(_2, t2.y);
              for (let e3 = 0; e3 < c2.length; e3++) {
                const o3 = this._tiles[c2[e3]];
                if (o3.holdingForFade())
                  continue;
                const r3 = o3.tileID, m2 = Math.pow(2, s2.zoom - o3.tileID.overscaledZ), p2 = i2 * o3.queryPadding * t.EXTENT / o3.tileSize / m2, f2 = [r3.getTilePoint(new t.MercatorCoordinate(h2, u2)), r3.getTilePoint(new t.MercatorCoordinate(d2, _2))];
                if (f2[0].x - p2 < t.EXTENT && f2[0].y - p2 < t.EXTENT && f2[1].x + p2 >= 0 && f2[1].y + p2 >= 0) {
                  const t2 = n2.map((t3) => r3.getTilePoint(t3)), e4 = l2.map((t3) => r3.getTilePoint(t3));
                  a2.push({ tile: o3, tileID: r3, queryGeometry: t2, cameraQueryGeometry: e4, scale: m2 });
                }
              }
              return a2;
            }
            getVisibleCoordinates(t2) {
              const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
              for (const t3 of e2)
                t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
              return e2;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (V(this._source.type))
                for (const e2 in this._tiles) {
                  const i2 = this._tiles[e2];
                  if (i2.fadeEndTime !== void 0 && i2.fadeEndTime >= t.exported.now())
                    return true;
                }
              return false;
            }
            setFeatureState(t2, e2, i2) {
              this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, i2);
            }
            removeFeatureState(t2, e2, i2) {
              this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, i2);
            }
            getFeatureState(t2, e2) {
              return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
            }
            setDependencies(t2, e2, i2) {
              const o2 = this._tiles[t2];
              o2 && o2.setDependencies(e2, i2);
            }
            reloadTilesForDependencies(t2, e2) {
              for (const i2 in this._tiles)
                this._tiles[i2].hasDependency(t2, e2) && this._reloadTile(i2, "reloading");
              this._cache.filter((i2) => !i2.hasDependency(t2, e2));
            }
          }
          function q(t2, e2) {
            const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
            return t2.overscaledZ - e2.overscaledZ || o2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
          }
          function V(t2) {
            return t2 === "raster" || t2 === "image" || t2 === "video";
          }
          Z.maxOverzooming = 10, Z.maxUnderzooming = 3;
          const j = "mapboxgl_preloaded_worker_pool";
          class X {
            constructor() {
              this.active = {};
            }
            acquire(t2) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < X.workerCount; )
                  this.workers.push(new Worker(Ia.workerUrl));
              return this.active[t2] = true, this.workers.slice();
            }
            release(t2) {
              delete this.active[t2], this.numActive() === 0 && (this.workers.forEach((t3) => {
                t3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[j];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          const $ = Math.floor(t.exported.hardwareConcurrency / 2);
          let W;
          function H() {
            return W || (W = new X()), W;
          }
          function K(e2, i2) {
            const o2 = {};
            for (const t2 in e2)
              t2 !== "ref" && (o2[t2] = e2[t2]);
            return t.refProperties.forEach((t2) => {
              t2 in i2 && (o2[t2] = i2[t2]);
            }), o2;
          }
          function Y(t2) {
            t2 = t2.slice();
            const e2 = /* @__PURE__ */ Object.create(null);
            for (let i2 = 0; i2 < t2.length; i2++)
              e2[t2[i2].id] = t2[i2];
            for (let i2 = 0; i2 < t2.length; i2++)
              "ref" in t2[i2] && (t2[i2] = K(t2[i2], e2[t2[i2].ref]));
            return t2;
          }
          X.workerCount = Math.max(Math.min($, 6), 1);
          const J = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
          function Q(t2, e2, i2) {
            i2.push({ command: J.addSource, args: [t2, e2[t2]] });
          }
          function tt(t2, e2, i2) {
            e2.push({ command: J.removeSource, args: [t2] }), i2[t2] = true;
          }
          function et(t2, e2, i2, o2) {
            tt(t2, i2, o2), Q(t2, e2, i2);
          }
          function it(t2, e2, i2) {
            let o2;
            for (o2 in t2[i2])
              if (Object.prototype.hasOwnProperty.call(t2[i2], o2) && o2 !== "data" && !a(t2[i2][o2], e2[i2][o2]))
                return false;
            for (o2 in e2[i2])
              if (Object.prototype.hasOwnProperty.call(e2[i2], o2) && o2 !== "data" && !a(t2[i2][o2], e2[i2][o2]))
                return false;
            return true;
          }
          function ot(t2, e2, i2, o2, s2, r2) {
            let n2;
            for (n2 in e2 = e2 || {}, t2 = t2 || {})
              Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e2[n2]) || i2.push({ command: r2, args: [o2, n2, e2[n2], s2] }));
            for (n2 in e2)
              Object.prototype.hasOwnProperty.call(e2, n2) && !Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e2[n2]) || i2.push({ command: r2, args: [o2, n2, e2[n2], s2] }));
          }
          function at(t2) {
            return t2.id;
          }
          function st(t2, e2) {
            return t2[e2.id] = e2, t2;
          }
          class rt {
            constructor(t2, e2) {
              this.reset(t2, e2);
            }
            reset(t2, e2) {
              this.points = t2 || [], this._distances = [0];
              for (let t3 = 1; t3 < this.points.length; t3++)
                this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e2) {
              if (this.points.length === 1)
                return this.points[0];
              e2 = t.clamp(e2, 0, 1);
              let i2 = 1, o2 = this._distances[i2];
              const a2 = e2 * this.paddedLength + this.padding;
              for (; o2 < a2 && i2 < this._distances.length; )
                o2 = this._distances[++i2];
              const s2 = i2 - 1, r2 = this._distances[s2], n2 = o2 - r2, l2 = n2 > 0 ? (a2 - r2) / n2 : 0;
              return this.points[s2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          function nt(t2, e2) {
            let i2 = true;
            return t2 === "always" || t2 !== "never" && e2 !== "never" || (i2 = false), i2;
          }
          class lt {
            constructor(t2, e2, i2) {
              const o2 = this.boxCells = [], a2 = this.circleCells = [];
              this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
              for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++)
                o2.push([]), a2.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(t2, e2, i2, o2, a2) {
              this._forEachCell(e2, i2, o2, a2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(a2);
            }
            insertCircle(t2, e2, i2, o2) {
              this._forEachCell(e2 - o2, i2 - o2, e2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(o2);
            }
            _insertBoxCell(t2, e2, i2, o2, a2, s2) {
              this.boxCells[a2].push(s2);
            }
            _insertCircleCell(t2, e2, i2, o2, a2, s2) {
              this.circleCells[a2].push(s2);
            }
            _query(t2, e2, i2, o2, a2, s2, r2) {
              if (i2 < 0 || t2 > this.width || o2 < 0 || e2 > this.height)
                return [];
              const n2 = [];
              if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= o2) {
                if (a2)
                  return [{ key: null, x1: t2, y1: e2, x2: i2, y2: o2 }];
                for (let t3 = 0; t3 < this.boxKeys.length; t3++)
                  n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
                for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                  const e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], o3 = this.circles[3 * t3 + 2];
                  n2.push({ key: this.circleKeys[t3], x1: e3 - o3, y1: i3 - o3, x2: e3 + o3, y2: i3 + o3 });
                }
              } else
                this._forEachCell(t2, e2, i2, o2, this._queryCell, n2, { hitTest: a2, overlapMode: s2, seenUids: { box: {}, circle: {} } }, r2);
              return n2;
            }
            query(t2, e2, i2, o2) {
              return this._query(t2, e2, i2, o2, false, null);
            }
            hitTest(t2, e2, i2, o2, a2, s2) {
              return this._query(t2, e2, i2, o2, true, a2, s2).length > 0;
            }
            hitTestCircle(t2, e2, i2, o2, a2) {
              const s2 = t2 - i2, r2 = t2 + i2, n2 = e2 - i2, l2 = e2 + i2;
              if (r2 < 0 || s2 > this.width || l2 < 0 || n2 > this.height)
                return false;
              const c2 = [];
              return this._forEachCell(s2, n2, r2, l2, this._queryCellCircle, c2, { hitTest: true, overlapMode: o2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, a2), c2.length > 0;
            }
            _queryCell(t2, e2, i2, o2, a2, s2, r2, n2) {
              const { seenUids: l2, hitTest: c2, overlapMode: h2 } = r2, u2 = this.boxCells[a2];
              if (u2 !== null) {
                const a3 = this.bboxes;
                for (const r3 of u2)
                  if (!l2.box[r3]) {
                    l2.box[r3] = true;
                    const u3 = 4 * r3, d3 = this.boxKeys[r3];
                    if (t2 <= a3[u3 + 2] && e2 <= a3[u3 + 3] && i2 >= a3[u3 + 0] && o2 >= a3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !nt(h2, d3.overlapMode)) && (s2.push({ key: d3, x1: a3[u3], y1: a3[u3 + 1], x2: a3[u3 + 2], y2: a3[u3 + 3] }), c2))
                      return true;
                  }
              }
              const d2 = this.circleCells[a2];
              if (d2 !== null) {
                const a3 = this.circles;
                for (const r3 of d2)
                  if (!l2.circle[r3]) {
                    l2.circle[r3] = true;
                    const u3 = 3 * r3, d3 = this.circleKeys[r3];
                    if (this._circleAndRectCollide(a3[u3], a3[u3 + 1], a3[u3 + 2], t2, e2, i2, o2) && (!n2 || n2(d3)) && (!c2 || !nt(h2, d3.overlapMode))) {
                      const t3 = a3[u3], e3 = a3[u3 + 1], i3 = a3[u3 + 2];
                      if (s2.push({ key: d3, x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 }), c2)
                        return true;
                    }
                  }
              }
              return false;
            }
            _queryCellCircle(t2, e2, i2, o2, a2, s2, r2, n2) {
              const { circle: l2, seenUids: c2, overlapMode: h2 } = r2, u2 = this.boxCells[a2];
              if (u2 !== null) {
                const t3 = this.bboxes;
                for (const e3 of u2)
                  if (!c2.box[e3]) {
                    c2.box[e3] = true;
                    const i3 = 4 * e3, o3 = this.boxKeys[e3];
                    if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(o3)) && !nt(h2, o3.overlapMode))
                      return s2.push(true), true;
                  }
              }
              const d2 = this.circleCells[a2];
              if (d2 !== null) {
                const t3 = this.circles;
                for (const e3 of d2)
                  if (!c2.circle[e3]) {
                    c2.circle[e3] = true;
                    const i3 = 3 * e3, o3 = this.circleKeys[e3];
                    if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(o3)) && !nt(h2, o3.overlapMode))
                      return s2.push(true), true;
                  }
              }
            }
            _forEachCell(t2, e2, i2, o2, a2, s2, r2, n2) {
              const l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
              for (let d2 = l2; d2 <= h2; d2++)
                for (let l3 = c2; l3 <= u2; l3++)
                  if (a2.call(this, t2, e2, i2, o2, this.xCellCount * l3 + d2, s2, r2, n2))
                    return;
            }
            _convertToXCellCoord(t2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
            }
            _convertToYCellCoord(t2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
            }
            _circlesCollide(t2, e2, i2, o2, a2, s2) {
              const r2 = o2 - t2, n2 = a2 - e2, l2 = i2 + s2;
              return l2 * l2 > r2 * r2 + n2 * n2;
            }
            _circleAndRectCollide(t2, e2, i2, o2, a2, s2, r2) {
              const n2 = (s2 - o2) / 2, l2 = Math.abs(t2 - (o2 + n2));
              if (l2 > n2 + i2)
                return false;
              const c2 = (r2 - a2) / 2, h2 = Math.abs(e2 - (a2 + c2));
              if (h2 > c2 + i2)
                return false;
              if (l2 <= n2 || h2 <= c2)
                return true;
              const u2 = l2 - n2, d2 = h2 - c2;
              return u2 * u2 + d2 * d2 <= i2 * i2;
            }
          }
          function ct(e2, i2, o2, a2, s2) {
            const r2 = t.create();
            return i2 ? (t.scale(r2, r2, [1 / s2, 1 / s2, 1]), o2 || t.rotateZ(r2, r2, a2.angle)) : t.multiply(r2, a2.labelPlaneMatrix, e2), r2;
          }
          function ht(e2, i2, o2, a2, s2) {
            if (i2) {
              const i3 = t.clone(e2);
              return t.scale(i3, i3, [s2, s2, 1]), o2 || t.rotateZ(i3, i3, -a2.angle), i3;
            }
            return a2.glCoordMatrix;
          }
          function ut(e2, i2, o2) {
            let a2;
            o2 ? (a2 = [e2.x, e2.y, o2(e2.x, e2.y), 1], t.transformMat4(a2, a2, i2)) : (a2 = [e2.x, e2.y, 0, 1], wt(a2, a2, i2));
            const s2 = a2[3];
            return { point: new t.pointGeometry(a2[0] / s2, a2[1] / s2), signedDistanceFromCamera: s2 };
          }
          function dt(t2, e2) {
            return 0.5 + t2 / e2 * 0.5;
          }
          function _t(t2, e2) {
            const i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
            return i2 >= -e2[0] && i2 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
          }
          function mt(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2) {
            const u2 = a2 ? e2.textSizeData : e2.iconSizeData, d2 = t.evaluateSizeForZoom(u2, o2.transform.zoom), _2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], m2 = a2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
            m2.clear();
            const p2 = e2.lineVertexArray, f2 = a2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, g2 = o2.transform.width / o2.transform.height;
            let x2 = false;
            for (let a3 = 0; a3 < f2.length; a3++) {
              const v2 = f2.get(a3);
              if (v2.hidden || v2.writingMode === t.WritingMode.vertical && !x2) {
                bt(v2.numGlyphs, m2);
                continue;
              }
              let y2;
              if (x2 = false, h2 ? (y2 = [v2.anchorX, v2.anchorY, h2(v2.anchorX, v2.anchorY), 1], t.transformMat4(y2, y2, i2)) : (y2 = [v2.anchorX, v2.anchorY, 0, 1], wt(y2, y2, i2)), !_t(y2, _2)) {
                bt(v2.numGlyphs, m2);
                continue;
              }
              const b2 = dt(o2.transform.cameraToCenterDistance, y2[3]), w2 = t.evaluateSizeForFeature(u2, d2, v2), T2 = n2 ? w2 / b2 : w2 * b2, E2 = new t.pointGeometry(v2.anchorX, v2.anchorY), I2 = ut(E2, s2, h2).point, S2 = {}, C2 = gt(v2, T2, false, l2, i2, s2, r2, e2.glyphOffsetArray, p2, m2, I2, E2, S2, g2, c2, h2);
              x2 = C2.useVertical, (C2.notEnoughRoom || x2 || C2.needsFlipping && gt(v2, T2, true, l2, i2, s2, r2, e2.glyphOffsetArray, p2, m2, I2, E2, S2, g2, c2, h2).notEnoughRoom) && bt(v2.numGlyphs, m2);
            }
            a2 ? e2.text.dynamicLayoutVertexBuffer.updateData(m2) : e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
          }
          function pt(t2, e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2) {
            const _2 = n2.glyphStartIndex + n2.numGlyphs, m2 = n2.lineStartIndex, p2 = n2.lineStartIndex + n2.lineLength, f2 = e2.getoffsetX(n2.glyphStartIndex), g2 = e2.getoffsetX(_2 - 1), x2 = vt(t2 * f2, i2, o2, a2, s2, r2, n2.segment, m2, p2, l2, c2, h2, u2, d2);
            if (!x2)
              return null;
            const v2 = vt(t2 * g2, i2, o2, a2, s2, r2, n2.segment, m2, p2, l2, c2, h2, u2, d2);
            return v2 ? { first: x2, last: v2 } : null;
          }
          function ft(e2, i2, o2, a2) {
            return e2 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * a2 ? { useVertical: true } : (e2 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: true } : null;
          }
          function gt(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, _2, m2, p2, f2) {
            const g2 = i2 / 24, x2 = e2.lineOffsetX * g2, v2 = e2.lineOffsetY * g2;
            let y2;
            if (e2.numGlyphs > 1) {
              const t2 = e2.glyphStartIndex + e2.numGlyphs, i3 = e2.lineStartIndex, s3 = e2.lineStartIndex + e2.lineLength, h3 = pt(g2, l2, x2, v2, o2, u2, d2, e2, c2, r2, _2, p2, f2);
              if (!h3)
                return { notEnoughRoom: true };
              const b2 = ut(h3.first.point, n2, f2).point, w2 = ut(h3.last.point, n2, f2).point;
              if (a2 && !o2) {
                const t3 = ft(e2.writingMode, b2, w2, m2);
                if (t3)
                  return t3;
              }
              y2 = [h3.first];
              for (let a3 = e2.glyphStartIndex + 1; a3 < t2 - 1; a3++)
                y2.push(vt(g2 * l2.getoffsetX(a3), x2, v2, o2, u2, d2, e2.segment, i3, s3, c2, r2, _2, p2, f2));
              y2.push(h3.last);
            } else {
              if (a2 && !o2) {
                const i4 = ut(d2, s2, f2).point, o3 = e2.lineStartIndex + e2.segment + 1, a3 = new t.pointGeometry(c2.getx(o3), c2.gety(o3)), r3 = ut(a3, s2, f2), n3 = r3.signedDistanceFromCamera > 0 ? r3.point : xt(d2, a3, i4, 1, s2, f2), l3 = ft(e2.writingMode, i4, n3, m2);
                if (l3)
                  return l3;
              }
              const i3 = vt(g2 * l2.getoffsetX(e2.glyphStartIndex), x2, v2, o2, u2, d2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c2, r2, _2, p2, f2);
              if (!i3)
                return { notEnoughRoom: true };
              y2 = [i3];
            }
            for (const e3 of y2)
              t.addDynamicAttributes(h2, e3.point, e3.angle);
            return {};
          }
          function xt(t2, e2, i2, o2, a2, s2) {
            const r2 = ut(t2.add(t2.sub(e2)._unit()), a2, s2).point, n2 = i2.sub(r2);
            return i2.add(n2._mult(o2 / n2.mag()));
          }
          function vt(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, _2, m2) {
            const p2 = a2 ? e2 - i2 : e2 + i2;
            let f2 = p2 > 0 ? 1 : -1, g2 = 0;
            a2 && (f2 *= -1, g2 = Math.PI), f2 < 0 && (g2 += Math.PI);
            let x2 = f2 > 0 ? l2 + n2 : l2 + n2 + 1, v2 = s2, y2 = s2, b2 = 0, w2 = 0;
            const T2 = Math.abs(p2), E2 = [];
            for (; b2 + w2 <= T2; ) {
              if (x2 += f2, x2 < l2 || x2 >= c2)
                return null;
              if (y2 = v2, E2.push(v2), v2 = d2[x2], v2 === void 0) {
                const e3 = new t.pointGeometry(h2.getx(x2), h2.gety(x2)), i3 = ut(e3, u2, m2);
                if (i3.signedDistanceFromCamera > 0)
                  v2 = d2[x2] = i3.point;
                else {
                  const i4 = x2 - f2;
                  v2 = xt(b2 === 0 ? r2 : new t.pointGeometry(h2.getx(i4), h2.gety(i4)), e3, y2, T2 - b2 + 1, u2, m2);
                }
              }
              b2 += w2, w2 = y2.dist(v2);
            }
            const I2 = (T2 - b2) / w2, S2 = v2.sub(y2), C2 = S2.mult(I2)._add(y2);
            C2._add(S2._unit()._perp()._mult(o2 * f2));
            const D2 = g2 + Math.atan2(v2.y - y2.y, v2.x - y2.x);
            return E2.push(C2), { point: C2, angle: _2 ? D2 : 0, path: E2 };
          }
          const yt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function bt(t2, e2) {
            for (let i2 = 0; i2 < t2; i2++) {
              const t3 = e2.length;
              e2.resize(t3 + 4), e2.float32.set(yt, 3 * t3);
            }
          }
          function wt(t2, e2, i2) {
            const o2 = e2[0], a2 = e2[1];
            return t2[0] = i2[0] * o2 + i2[4] * a2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * a2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * a2 + i2[15], t2;
          }
          const Tt = 100;
          class Et {
            constructor(t2, e2 = new lt(t2.width + 200, t2.height + 200, 25), i2 = new lt(t2.width + 200, t2.height + 200, 25)) {
              this.transform = t2, this.grid = e2, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + Tt, this.screenBottomBoundary = t2.height + Tt, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
            }
            placeCollisionBox(t2, e2, i2, o2, a2, s2) {
              const r2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY, s2), n2 = i2 * r2.perspectiveRatio, l2 = t2.x1 * n2 + r2.point.x, c2 = t2.y1 * n2 + r2.point.y, h2 = t2.x2 * n2 + r2.point.x, u2 = t2.y2 * n2 + r2.point.y;
              return !this.isInsideGrid(l2, c2, h2, u2) || e2 !== "always" && this.grid.hitTest(l2, c2, h2, u2, e2, a2) || r2.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l2, c2, h2, u2], offscreen: this.isOffscreen(l2, c2, h2, u2) };
            }
            placeCollisionCircles(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, _2, m2) {
              const p2 = [], f2 = new t.pointGeometry(i2.anchorX, i2.anchorY), g2 = ut(f2, r2, m2), x2 = dt(this.transform.cameraToCenterDistance, g2.signedDistanceFromCamera), v2 = (h2 ? s2 / x2 : s2 * x2) / t.ONE_EM, y2 = ut(f2, n2, m2).point, b2 = pt(v2, a2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, y2, f2, i2, o2, n2, {}, false, m2);
              let w2 = false, T2 = false, E2 = true;
              if (b2) {
                const i3 = 0.5 * d2 * x2 + _2, o3 = new t.pointGeometry(-100, -100), a3 = new t.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), s3 = new rt(), r3 = b2.first, n3 = b2.last;
                let h3 = [];
                for (let t2 = r3.path.length - 1; t2 >= 1; t2--)
                  h3.push(r3.path[t2]);
                for (let t2 = 1; t2 < n3.path.length; t2++)
                  h3.push(n3.path[t2]);
                const f3 = 2.5 * i3;
                if (l2) {
                  const t2 = h3.map((t3) => ut(t3, l2, m2));
                  h3 = t2.some((t3) => t3.signedDistanceFromCamera <= 0) ? [] : t2.map((t3) => t3.point);
                }
                let g3 = [];
                if (h3.length > 0) {
                  const e3 = h3[0].clone(), i4 = h3[0].clone();
                  for (let t2 = 1; t2 < h3.length; t2++)
                    e3.x = Math.min(e3.x, h3[t2].x), e3.y = Math.min(e3.y, h3[t2].y), i4.x = Math.max(i4.x, h3[t2].x), i4.y = Math.max(i4.y, h3[t2].y);
                  g3 = e3.x >= o3.x && i4.x <= a3.x && e3.y >= o3.y && i4.y <= a3.y ? [h3] : i4.x < o3.x || e3.x > a3.x || i4.y < o3.y || e3.y > a3.y ? [] : t.clipLine([h3], o3.x, o3.y, a3.x, a3.y);
                }
                for (const t2 of g3) {
                  s3.reset(t2, 0.25 * i3);
                  let o4 = 0;
                  o4 = s3.length <= 0.5 * i3 ? 1 : Math.ceil(s3.paddedLength / f3) + 1;
                  for (let t3 = 0; t3 < o4; t3++) {
                    const a4 = t3 / Math.max(o4 - 1, 1), r4 = s3.lerp(a4), n4 = r4.x + Tt, l3 = r4.y + Tt;
                    p2.push(n4, l3, i3, 0);
                    const h4 = n4 - i3, d3 = l3 - i3, _3 = n4 + i3, m3 = l3 + i3;
                    if (E2 = E2 && this.isOffscreen(h4, d3, _3, m3), T2 = T2 || this.isInsideGrid(h4, d3, _3, m3), e2 !== "always" && this.grid.hitTestCircle(n4, l3, i3, e2, u2) && (w2 = true, !c2))
                      return { circles: [], offscreen: false, collisionDetected: w2 };
                  }
                }
              }
              return { circles: !c2 && w2 || !T2 || x2 < this.perspectiveRatioCutoff ? [] : p2, offscreen: E2, collisionDetected: w2 };
            }
            queryRenderedSymbols(e2) {
              if (e2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                return {};
              const i2 = [];
              let o2 = 1 / 0, a2 = 1 / 0, s2 = -1 / 0, r2 = -1 / 0;
              for (const n3 of e2) {
                const e3 = new t.pointGeometry(n3.x + Tt, n3.y + Tt);
                o2 = Math.min(o2, e3.x), a2 = Math.min(a2, e3.y), s2 = Math.max(s2, e3.x), r2 = Math.max(r2, e3.y), i2.push(e3);
              }
              const n2 = this.grid.query(o2, a2, s2, r2).concat(this.ignoredGrid.query(o2, a2, s2, r2)), l2 = {}, c2 = {};
              for (const e3 of n2) {
                const o3 = e3.key;
                if (l2[o3.bucketInstanceId] === void 0 && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                  continue;
                const a3 = [new t.pointGeometry(e3.x1, e3.y1), new t.pointGeometry(e3.x2, e3.y1), new t.pointGeometry(e3.x2, e3.y2), new t.pointGeometry(e3.x1, e3.y2)];
                t.polygonIntersectsPolygon(i2, a3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, c2[o3.bucketInstanceId] === void 0 && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(t2, e2, i2, o2, a2, s2) {
              (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: o2, featureIndex: a2, collisionGroupID: s2, overlapMode: e2 }, t2[0], t2[1], t2[2], t2[3]);
            }
            insertCollisionCircles(t2, e2, i2, o2, a2, s2) {
              const r2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: o2, featureIndex: a2, collisionGroupID: s2, overlapMode: e2 };
              for (let e3 = 0; e3 < t2.length; e3 += 4)
                r2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
            }
            projectAndGetPerspectiveRatio(e2, i2, o2, a2) {
              let s2;
              return a2 ? (s2 = [i2, o2, a2(i2, o2), 1], t.transformMat4(s2, s2, e2)) : (s2 = [i2, o2, 0, 1], wt(s2, s2, e2)), { point: new t.pointGeometry((s2[0] / s2[3] + 1) / 2 * this.transform.width + Tt, (-s2[1] / s2[3] + 1) / 2 * this.transform.height + Tt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s2[3] * 0.5 };
            }
            isOffscreen(t2, e2, i2, o2) {
              return i2 < Tt || t2 >= this.screenRightBoundary || o2 < Tt || e2 > this.screenBottomBoundary;
            }
            isInsideGrid(t2, e2, i2, o2) {
              return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e2 = t.identity([]);
              return t.translate(e2, e2, [-100, -100, 0]), e2;
            }
          }
          function It(e2, i2, o2) {
            return i2 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
          }
          class St {
            constructor(t2, e2, i2, o2) {
              this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : o2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return this.opacity === 0 && !this.placed;
            }
          }
          class Ct {
            constructor(t2, e2, i2, o2, a2) {
              this.text = new St(t2 ? t2.text : null, e2, i2, a2), this.icon = new St(t2 ? t2.icon : null, e2, o2, a2);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class Dt {
            constructor(t2, e2, i2) {
              this.text = t2, this.icon = e2, this.skipFade = i2;
            }
          }
          class zt {
            constructor() {
              this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
            }
          }
          class Pt {
            constructor(t2, e2, i2, o2, a2) {
              this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = a2;
            }
          }
          class At {
            constructor(t2) {
              this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(t2) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[t2]) {
                const e2 = ++this.maxGroupID;
                this.collisionGroups[t2] = { ID: e2, predicate: (t3) => t3.collisionGroupID === e2 };
              }
              return this.collisionGroups[t2];
            }
          }
          function Mt(e2, i2, o2, a2, s2) {
            const { horizontalAlign: r2, verticalAlign: n2 } = t.getAnchorAlignment(e2), l2 = -(r2 - 0.5) * i2, c2 = -(n2 - 0.5) * o2, h2 = t.evaluateVariableOffset(e2, a2);
            return new t.pointGeometry(l2 + h2[0] * s2, c2 + h2[1] * s2);
          }
          function Rt(e2, i2, o2, a2, s2, r2) {
            const { x1: n2, x2: l2, y1: c2, y2: h2, anchorPointX: u2, anchorPointY: d2 } = e2, _2 = new t.pointGeometry(i2, o2);
            return a2 && _2._rotate(s2 ? r2 : -r2), { x1: n2 + _2.x, y1: c2 + _2.y, x2: l2 + _2.x, y2: h2 + _2.y, anchorPointX: u2, anchorPointY: d2 };
          }
          class Lt {
            constructor(t2, e2, i2, o2, a2) {
              this.transform = t2.clone(), this.terrain = e2, this.collisionIndex = new Et(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new At(o2), this.collisionCircleArrays = {}, this.prevPlacement = a2, a2 && (a2.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(e2, i2, o2, a2) {
              const s2 = o2.getBucket(i2), r2 = o2.latestFeatureIndex;
              if (!s2 || !r2 || i2.id !== s2.layerIds[0])
                return;
              const n2 = o2.collisionBoxArray, l2 = s2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / t.EXTENT, u2 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), d2 = l2.get("text-pitch-alignment") === "map", _2 = l2.get("text-rotation-alignment") === "map", m2 = It(o2, 1, this.transform.zoom), p2 = ct(u2, d2, _2, this.transform, m2);
              let f2 = null;
              if (d2) {
                const e3 = ht(u2, d2, _2, this.transform, m2);
                f2 = t.multiply([], this.transform.labelPlaneMatrix, e3);
              }
              this.retainedQueryData[s2.bucketInstanceId] = new Pt(s2.bucketInstanceId, r2, s2.sourceLayerIndex, s2.index, o2.tileID);
              const g2 = { bucket: s2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: p2, labelToScreenMatrix: f2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(s2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s2.sourceID) };
              if (a2)
                for (const t2 of s2.sortKeyRanges) {
                  const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3 } = t2;
                  e2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3, parameters: g2 });
                }
              else
                e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: s2.symbolInstances.length, parameters: g2 });
            }
            attemptAnchorPlacement(t2, e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, _2, m2, p2) {
              const f2 = [u2.textOffset0, u2.textOffset1], g2 = Mt(t2, i2, o2, f2, a2), x2 = this.collisionIndex.placeCollisionBox(Rt(e2, g2.x, g2.y, s2, r2, this.transform.angle), h2, n2, l2, c2.predicate, p2);
              if ((!m2 || this.collisionIndex.placeCollisionBox(Rt(m2, g2.x, g2.y, s2, r2, this.transform.angle), h2, n2, l2, c2.predicate, p2).box.length !== 0) && x2.box.length > 0) {
                let e3;
                return this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), this.variableOffsets[u2.crossTileID] = { textOffset: f2, width: i2, height: o2, anchor: t2, textBoxScale: a2, prevAnchor: e3 }, this.markUsedJustification(d2, t2, u2, _2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, _2, u2), this.placedOrientations[u2.crossTileID] = _2), { shift: g2, placedGlyphBoxes: x2 };
              }
            }
            placeLayerBucketPart(e2, i2, o2) {
              const { bucket: a2, layout: s2, posMatrix: r2, textLabelPlaneMatrix: n2, labelToScreenMatrix: l2, textPixelRatio: c2, holdingForFade: h2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d2, collisionGroup: _2 } = e2.parameters, m2 = s2.get("text-optional"), p2 = s2.get("icon-optional"), f2 = t.getOverlapMode(s2, "text-overlap", "text-allow-overlap"), g2 = f2 === "always", x2 = t.getOverlapMode(s2, "icon-overlap", "icon-allow-overlap"), v2 = x2 === "always", y2 = s2.get("text-rotation-alignment") === "map", b2 = s2.get("text-pitch-alignment") === "map", w2 = s2.get("icon-text-fit") !== "none", T2 = s2.get("symbol-z-order") === "viewport-y", E2 = g2 && (v2 || !a2.hasIconData() || p2), I2 = v2 && (g2 || !a2.hasTextData() || m2);
              !a2.collisionArrays && u2 && a2.deserializeCollisionBoxes(u2);
              const S2 = (e3, u3) => {
                if (i2[e3.crossTileID])
                  return;
                if (h2)
                  return void (this.placements[e3.crossTileID] = new Dt(false, false, false));
                let v3 = false, T3 = false, S3 = true, C2 = null, D2 = { box: null, offscreen: null }, z2 = { box: null, offscreen: null }, P2 = null, A2 = null, M2 = null, R2 = 0, L2 = 0, k2 = 0;
                u3.textFeatureIndex ? R2 = u3.textFeatureIndex : e3.useRuntimeCollisionCircles && (R2 = e3.featureIndex), u3.verticalTextFeatureIndex && (L2 = u3.verticalTextFeatureIndex);
                const B2 = this.retainedQueryData[a2.bucketInstanceId].tileID, F2 = this.terrain ? (t2, e4) => this.terrain.getElevation(B2, t2, e4) : null;
                for (const t2 of ["textBox", "verticalTextBox", "iconBox", "verticalIconBox"]) {
                  const e4 = u3[t2];
                  e4 && (e4.elevation = F2 ? F2(e4.anchorPointX, e4.anchorPointY) : 0);
                }
                const O2 = u3.textBox;
                if (O2) {
                  const i3 = (i4) => {
                    let o4 = t.WritingMode.horizontal;
                    if (a2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
                      t2 && (this.placedOrientations[e3.crossTileID] = t2, o4 = t2, this.markUsedOrientation(a2, o4, e3));
                    }
                    return o4;
                  }, o3 = (i4, o4) => {
                    if (a2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                      for (const e4 of a2.writingModes)
                        if (e4 === t.WritingMode.vertical ? (D2 = o4(), z2 = D2) : D2 = i4(), D2 && D2.box && D2.box.length)
                          break;
                    } else
                      D2 = i4();
                  };
                  if (s2.get("text-variable-anchor")) {
                    let n3 = s2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[e3.crossTileID]) {
                      const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                      n3.indexOf(t2.anchor) > 0 && (n3 = n3.filter((e4) => e4 !== t2.anchor), n3.unshift(t2.anchor));
                    }
                    const l3 = (t2, i4, o4) => {
                      const s3 = t2.x2 - t2.x1, l4 = t2.y2 - t2.y1, h4 = e3.textBoxScale, u4 = w2 && x2 === "never" ? i4 : null;
                      let d3 = { box: [], offscreen: false };
                      const m3 = f2 !== "never" ? 2 * n3.length : n3.length;
                      for (let i5 = 0; i5 < m3; ++i5) {
                        const m4 = this.attemptAnchorPlacement(n3[i5 % n3.length], t2, s3, l4, h4, y2, b2, c2, r2, _2, i5 >= n3.length ? f2 : "never", e3, a2, o4, u4, F2);
                        if (m4 && (d3 = m4.placedGlyphBoxes, d3 && d3.box && d3.box.length)) {
                          v3 = true, C2 = m4.shift;
                          break;
                        }
                      }
                      return d3;
                    };
                    o3(() => l3(O2, u3.iconBox, t.WritingMode.horizontal), () => {
                      const i4 = u3.verticalTextBox;
                      return a2.allowVerticalPlacement && !(D2 && D2.box && D2.box.length) && e3.numVerticalGlyphVertices > 0 && i4 ? l3(i4, u3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), D2 && (v3 = D2.box, S3 = D2.offscreen);
                    const h3 = i3(D2 && D2.box);
                    if (!v3 && this.prevPlacement) {
                      const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                      t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(a2, t2.anchor, e3, h3));
                    }
                  } else {
                    const s3 = (t2, i4) => {
                      const o4 = this.collisionIndex.placeCollisionBox(t2, f2, c2, r2, _2.predicate, F2);
                      return o4 && o4.box && o4.box.length && (this.markUsedOrientation(a2, i4, e3), this.placedOrientations[e3.crossTileID] = i4), o4;
                    };
                    o3(() => s3(O2, t.WritingMode.horizontal), () => {
                      const i4 = u3.verticalTextBox;
                      return a2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? s3(i4, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), i3(D2 && D2.box && D2.box.length);
                  }
                }
                if (P2 = D2, v3 = P2 && P2.box && P2.box.length > 0, S3 = P2 && P2.offscreen, e3.useRuntimeCollisionCircles) {
                  const i3 = a2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), c3 = t.evaluateSizeForFeature(a2.textSizeData, d2, i3), h3 = s2.get("text-padding");
                  A2 = this.collisionIndex.placeCollisionCircles(f2, i3, a2.lineVertexArray, a2.glyphOffsetArray, c3, r2, n2, l2, o2, b2, _2.predicate, e3.collisionCircleDiameter, h3, F2), v3 = g2 || A2.circles.length > 0 && !A2.collisionDetected, S3 = S3 && A2.offscreen;
                }
                if (u3.iconFeatureIndex && (k2 = u3.iconFeatureIndex), u3.iconBox) {
                  const t2 = (t3) => {
                    const e4 = w2 && C2 ? Rt(t3, C2.x, C2.y, y2, b2, this.transform.angle) : t3;
                    return this.collisionIndex.placeCollisionBox(e4, x2, c2, r2, _2.predicate, F2);
                  };
                  z2 && z2.box && z2.box.length && u3.verticalIconBox ? (M2 = t2(u3.verticalIconBox), T3 = M2.box.length > 0) : (M2 = t2(u3.iconBox), T3 = M2.box.length > 0), S3 = S3 && M2.offscreen;
                }
                const U2 = m2 || e3.numHorizontalGlyphVertices === 0 && e3.numVerticalGlyphVertices === 0, N2 = p2 || e3.numIconVertices === 0;
                if (U2 || N2 ? N2 ? U2 || (T3 = T3 && v3) : v3 = T3 && v3 : T3 = v3 = T3 && v3, v3 && P2 && P2.box && this.collisionIndex.insertCollisionBox(P2.box, f2, s2.get("text-ignore-placement"), a2.bucketInstanceId, z2 && z2.box && L2 ? L2 : R2, _2.ID), T3 && M2 && this.collisionIndex.insertCollisionBox(M2.box, x2, s2.get("icon-ignore-placement"), a2.bucketInstanceId, k2, _2.ID), A2 && (v3 && this.collisionIndex.insertCollisionCircles(A2.circles, f2, s2.get("text-ignore-placement"), a2.bucketInstanceId, R2, _2.ID), o2)) {
                  const t2 = a2.bucketInstanceId;
                  let e4 = this.collisionCircleArrays[t2];
                  e4 === void 0 && (e4 = this.collisionCircleArrays[t2] = new zt());
                  for (let t3 = 0; t3 < A2.circles.length; t3 += 4)
                    e4.circles.push(A2.circles[t3 + 0]), e4.circles.push(A2.circles[t3 + 1]), e4.circles.push(A2.circles[t3 + 2]), e4.circles.push(A2.collisionDetected ? 1 : 0);
                }
                this.placements[e3.crossTileID] = new Dt(v3 || E2, T3 || I2, S3 || a2.justReloaded), i2[e3.crossTileID] = true;
              };
              if (T2) {
                const t2 = a2.getSortedSymbolIndexes(this.transform.angle);
                for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                  const i3 = t2[e3];
                  S2(a2.symbolInstances.get(i3), a2.collisionArrays[i3]);
                }
              } else
                for (let t2 = e2.symbolInstanceStart; t2 < e2.symbolInstanceEnd; t2++)
                  S2(a2.symbolInstances.get(t2), a2.collisionArrays[t2]);
              if (o2 && a2.bucketInstanceId in this.collisionCircleArrays) {
                const e3 = this.collisionCircleArrays[a2.bucketInstanceId];
                t.invert(e3.invProjMatrix, r2), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              a2.justReloaded = false;
            }
            markUsedJustification(e2, i2, o2, a2) {
              let s2;
              s2 = a2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
              const r2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
              for (const t2 of r2)
                t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = s2 >= 0 && t2 !== s2 ? 0 : o2.crossTileID);
            }
            markUsedOrientation(e2, i2, o2) {
              const a2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, s2 = i2 === t.WritingMode.vertical ? i2 : 0, r2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
              for (const t2 of r2)
                e2.text.placedSymbolArray.get(t2).placedOrientation = a2;
              o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = s2);
            }
            commit(t2) {
              this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const e2 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
              const o2 = e2 ? e2.symbolFadeChange(t2) : 1, a2 = e2 ? e2.opacities : {}, s2 = e2 ? e2.variableOffsets : {}, r2 = e2 ? e2.placedOrientations : {};
              for (const t3 in this.placements) {
                const e3 = this.placements[t3], s3 = a2[t3];
                s3 ? (this.opacities[t3] = new Ct(s3, o2, e3.text, e3.icon), i2 = i2 || e3.text !== s3.text.placed || e3.icon !== s3.icon.placed) : (this.opacities[t3] = new Ct(null, o2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
              }
              for (const t3 in a2) {
                const e3 = a2[t3];
                if (!this.opacities[t3]) {
                  const a3 = new Ct(e3, o2, false, false);
                  a3.isHidden() || (this.opacities[t3] = a3, i2 = i2 || e3.text.placed || e3.icon.placed);
                }
              }
              for (const t3 in s2)
                this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = s2[t3]);
              for (const t3 in r2)
                this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = r2[t3]);
              i2 ? this.lastPlacementChangeTime = t2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
            }
            updateLayerOpacities(t2, e2) {
              const i2 = {};
              for (const o2 of e2) {
                const e3 = o2.getBucket(t2);
                e3 && o2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i2, o2.collisionBoxArray);
              }
            }
            updateBucketOpacities(e2, i2, o2) {
              e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
              const a2 = e2.layers[0].layout, s2 = new Ct(null, 0, false, false, true), r2 = a2.get("text-allow-overlap"), n2 = a2.get("icon-allow-overlap"), l2 = a2.get("text-variable-anchor"), c2 = a2.get("text-rotation-alignment") === "map", h2 = a2.get("text-pitch-alignment") === "map", u2 = a2.get("icon-text-fit") !== "none", d2 = new Ct(null, 0, r2 && (n2 || !e2.hasIconData() || a2.get("icon-optional")), n2 && (r2 || !e2.hasTextData() || a2.get("text-optional")), true);
              !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
              const _2 = (t2, e3, i3) => {
                for (let o3 = 0; o3 < e3 / 4; o3++)
                  t2.opacityVertexArray.emplaceBack(i3);
              };
              for (let o3 = 0; o3 < e2.symbolInstances.length; o3++) {
                const a3 = e2.symbolInstances.get(o3), { numHorizontalGlyphVertices: r3, numVerticalGlyphVertices: n3, crossTileID: m2 } = a3;
                let p2 = this.opacities[m2];
                i2[m2] ? p2 = s2 : p2 || (p2 = d2, this.opacities[m2] = p2), i2[m2] = true;
                const f2 = a3.numIconVertices > 0, g2 = this.placedOrientations[a3.crossTileID], x2 = g2 === t.WritingMode.vertical, v2 = g2 === t.WritingMode.horizontal || g2 === t.WritingMode.horizontalOnly;
                if (r3 > 0 || n3 > 0) {
                  const t2 = qt(p2.text);
                  _2(e2.text, r3, x2 ? Vt : t2), _2(e2.text, n3, v2 ? Vt : t2);
                  const i3 = p2.text.isHidden();
                  [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach((t3) => {
                    t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i3 || x2 ? 1 : 0);
                  }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = i3 || v2 ? 1 : 0);
                  const o4 = this.variableOffsets[a3.crossTileID];
                  o4 && this.markUsedJustification(e2, o4.anchor, a3, g2);
                  const s3 = this.placedOrientations[a3.crossTileID];
                  s3 && (this.markUsedJustification(e2, "left", a3, s3), this.markUsedOrientation(e2, s3, a3));
                }
                if (f2) {
                  const t2 = qt(p2.icon), i3 = !(u2 && a3.verticalPlacedIconSymbolIndex && x2);
                  a3.placedIconSymbolIndex >= 0 && (_2(e2.icon, a3.numIconVertices, i3 ? t2 : Vt), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = p2.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (_2(e2.icon, a3.numVerticalIconVertices, i3 ? Vt : t2), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = p2.icon.isHidden());
                }
                if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                  const i3 = e2.collisionArrays[o3];
                  if (i3) {
                    let o4 = new t.pointGeometry(0, 0);
                    if (i3.textBox || i3.verticalTextBox) {
                      let t2 = true;
                      if (l2) {
                        const e3 = this.variableOffsets[m2];
                        e3 ? (o4 = Mt(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), c2 && o4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : t2 = false;
                      }
                      i3.textBox && kt(e2.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || x2, o4.x, o4.y), i3.verticalTextBox && kt(e2.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || v2, o4.x, o4.y);
                    }
                    const a4 = Boolean(!v2 && i3.verticalIconBox);
                    i3.iconBox && kt(e2.iconCollisionBox.collisionVertexArray, p2.icon.placed, a4, u2 ? o4.x : 0, u2 ? o4.y : 0), i3.verticalIconBox && kt(e2.iconCollisionBox.collisionVertexArray, p2.icon.placed, !a4, u2 ? o4.x : 0, u2 ? o4.y : 0);
                  }
                }
              }
              if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.bucketInstanceId in this.collisionCircleArrays) {
                const t2 = this.collisionCircleArrays[e2.bucketInstanceId];
                e2.placementInvProjMatrix = t2.invProjMatrix, e2.placementViewportMatrix = t2.viewportMatrix, e2.collisionCircleArray = t2.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
              }
            }
            symbolFadeChange(t2) {
              return this.fadeDuration === 0 ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(t2) {
              return Math.max(0, (this.transform.zoom - t2) / 1.5);
            }
            hasTransitions(t2) {
              return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(t2, e2) {
              const i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
              return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function kt(t2, e2, i2, o2, a2) {
            t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0);
          }
          const Bt = Math.pow(2, 25), Ft = Math.pow(2, 24), Ot = Math.pow(2, 17), Ut = Math.pow(2, 16), Nt = Math.pow(2, 9), Gt = Math.pow(2, 8), Zt = Math.pow(2, 1);
          function qt(t2) {
            if (t2.opacity === 0 && !t2.placed)
              return 0;
            if (t2.opacity === 1 && t2.placed)
              return 4294967295;
            const e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
            return i2 * Bt + e2 * Ft + i2 * Ot + e2 * Ut + i2 * Nt + e2 * Gt + i2 * Zt + e2;
          }
          const Vt = 0;
          class jt {
            constructor(t2) {
              this._sortAcrossTiles = t2.layout.get("symbol-z-order") !== "viewport-y" && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(t2, e2, i2, o2, a2) {
              const s2 = this._bucketParts;
              for (; this._currentTileIndex < t2.length; )
                if (e2.getBucketParts(s2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a2())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s2.sort((t3, e3) => t3.sortKey - e3.sortKey)); this._currentPartIndex < s2.length; )
                if (e2.placeLayerBucketPart(s2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, a2())
                  return true;
              return false;
            }
          }
          class Xt {
            constructor(t2, e2, i2, o2, a2, s2, r2, n2) {
              this.placement = new Lt(t2, e2, s2, r2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = o2, this._showCollisionBoxes = a2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e2, i2, o2) {
              const a2 = t.exported.now(), s2 = () => {
                const e3 = t.exported.now() - a2;
                return !this._forceFullPlacement && e3 > 2;
              };
              for (; this._currentPlacementIndex >= 0; ) {
                const t2 = i2[e2[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
                if (t2.type === "symbol" && (!t2.minzoom || t2.minzoom <= a3) && (!t2.maxzoom || t2.maxzoom > a3)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new jt(t2)), this._inProgressLayer.continuePlacement(o2[t2.source], this.placement, this._showCollisionBoxes, t2, s2))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(t2) {
              return this.placement.commit(t2), this.placement;
            }
          }
          const $t = 512 / t.EXTENT / 2;
          class Wt {
            constructor(t2, e2, i2) {
              this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
              for (let i3 = 0; i3 < e2.length; i3++) {
                const o2 = e2.get(i3), a2 = o2.key;
                this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, t2) });
              }
            }
            getScaledCoordinates(e2, i2) {
              const o2 = $t / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
              return { x: Math.floor((i2.canonical.x * t.EXTENT + e2.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e2.anchorY) * o2) };
            }
            findMatches(t2, e2, i2) {
              const o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
              for (let a2 = 0; a2 < t2.length; a2++) {
                const s2 = t2.get(a2);
                if (s2.crossTileID)
                  continue;
                const r2 = this.indexedSymbolInstances[s2.key];
                if (!r2)
                  continue;
                const n2 = this.getScaledCoordinates(s2, e2);
                for (const t3 of r2)
                  if (Math.abs(t3.coord.x - n2.x) <= o2 && Math.abs(t3.coord.y - n2.y) <= o2 && !i2[t3.crossTileID]) {
                    i2[t3.crossTileID] = true, s2.crossTileID = t3.crossTileID;
                    break;
                  }
              }
            }
          }
          class Ht {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class Kt {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(t2) {
              const e2 = Math.round((t2 - this.lng) / 360);
              if (e2 !== 0)
                for (const t3 in this.indexes) {
                  const i2 = this.indexes[t3], o2 = {};
                  for (const t4 in i2) {
                    const a2 = i2[t4];
                    a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), o2[a2.tileID.key] = a2;
                  }
                  this.indexes[t3] = o2;
                }
              this.lng = t2;
            }
            addBucket(t2, e2, i2) {
              if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
                if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
              }
              for (let t3 = 0; t3 < e2.symbolInstances.length; t3++)
                e2.symbolInstances.get(t3).crossTileID = 0;
              this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
              const o2 = this.usedCrossTileIDs[t2.overscaledZ];
              for (const i3 in this.indexes) {
                const a2 = this.indexes[i3];
                if (Number(i3) > t2.overscaledZ)
                  for (const i4 in a2) {
                    const s2 = a2[i4];
                    s2.tileID.isChildOf(t2) && s2.findMatches(e2.symbolInstances, t2, o2);
                  }
                else {
                  const s2 = a2[t2.scaledTo(Number(i3)).key];
                  s2 && s2.findMatches(e2.symbolInstances, t2, o2);
                }
              }
              for (let t3 = 0; t3 < e2.symbolInstances.length; t3++) {
                const a2 = e2.symbolInstances.get(t3);
                a2.crossTileID || (a2.crossTileID = i2.generate(), o2[a2.crossTileID] = true);
              }
              return this.indexes[t2.overscaledZ] === void 0 && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new Wt(t2, e2.symbolInstances, e2.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(t2, e2) {
              for (const i2 in e2.indexedSymbolInstances)
                for (const o2 of e2.indexedSymbolInstances[i2])
                  delete this.usedCrossTileIDs[t2][o2.crossTileID];
            }
            removeStaleBuckets(t2) {
              let e2 = false;
              for (const i2 in this.indexes) {
                const o2 = this.indexes[i2];
                for (const a2 in o2)
                  t2[o2[a2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[a2]), delete o2[a2], e2 = true);
              }
              return e2;
            }
          }
          class Yt {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Ht(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(t2, e2, i2) {
              let o2 = this.layerIndexes[t2.id];
              o2 === void 0 && (o2 = this.layerIndexes[t2.id] = new Kt());
              let a2 = false;
              const s2 = {};
              o2.handleWrapJump(i2);
              for (const i3 of e2) {
                const e3 = i3.getBucket(t2);
                e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(i3.tileID, e3, this.crossTileIDs) && (a2 = true), s2[e3.bucketInstanceId] = true);
              }
              return o2.removeStaleBuckets(s2) && (a2 = true), a2;
            }
            pruneUnusedLayers(t2) {
              const e2 = {};
              t2.forEach((t3) => {
                e2[t3] = true;
              });
              for (const t3 in this.layerIndexes)
                e2[t3] || delete this.layerIndexes[t3];
            }
          }
          var Jt = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]);
          class Qt extends t.Evented {
            constructor(t2) {
              super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.renderHistory = [], this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, this.renderHistorySize = 150, t2.usedForTerrain = true, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
            }
            destruct() {
              this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
              for (const t2 in this._tiles) {
                const e2 = this._tiles[t2];
                e2.textures.forEach((t3) => t3.destroy()), e2.textures = [];
              }
            }
            update(e2, i2) {
              this.sourceCache.update(e2, i2), this._renderableTilesKeys = [];
              for (const o2 of e2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2 }))
                this._renderableTilesKeys.push(o2.key), this._tiles[o2.key] || (o2.posMatrix = new Float64Array(16), t.ortho(o2.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), this._tiles[o2.key] = new U(o2, this.tileSize));
            }
            removeOutdated(t2) {
              const e2 = {};
              for (const t3 of this._renderableTilesKeys)
                e2[t3] = true;
              for (this.renderHistory = this.renderHistory.filter((t3, e3) => this.renderHistory.indexOf(t3) === e3); this.renderHistory.length > this.renderHistorySize; ) {
                const i2 = this.sourceCache._tiles[this.renderHistory.shift()];
                i2 && !e2[i2.tileID.key] && (i2.clearTextures(t2), delete this.sourceCache._tiles[i2.tileID.key]);
              }
            }
            getRenderableTiles() {
              return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
            }
            getTileByID(t2) {
              return this._tiles[t2];
            }
            getTerrainCoords(e2) {
              const i2 = {};
              for (const o2 of this._renderableTilesKeys) {
                const a2 = this._tiles[o2].tileID;
                if (a2.canonical.equals(e2.canonical)) {
                  const a3 = e2.clone();
                  a3.posMatrix = new Float64Array(16), t.ortho(a3.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), i2[o2] = a3;
                } else if (a2.canonical.isChildOf(e2.canonical)) {
                  const s2 = e2.clone();
                  s2.posMatrix = new Float64Array(16);
                  const r2 = a2.canonical.z - e2.canonical.z, n2 = a2.canonical.x - (a2.canonical.x >> r2 << r2), l2 = a2.canonical.y - (a2.canonical.y >> r2 << r2), c2 = t.EXTENT >> r2;
                  t.ortho(s2.posMatrix, 0, c2, 0, c2, 0, 1), t.translate(s2.posMatrix, s2.posMatrix, [-n2 * c2, -l2 * c2, 0]), i2[o2] = s2;
                } else if (e2.canonical.isChildOf(a2.canonical)) {
                  const s2 = e2.clone();
                  s2.posMatrix = new Float64Array(16);
                  const r2 = e2.canonical.z - a2.canonical.z, n2 = e2.canonical.x - (e2.canonical.x >> r2 << r2), l2 = e2.canonical.y - (e2.canonical.y >> r2 << r2), c2 = t.EXTENT >> r2;
                  t.ortho(s2.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), t.translate(s2.posMatrix, s2.posMatrix, [n2 * c2, l2 * c2, 0]), t.scale(s2.posMatrix, s2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i2[o2] = s2;
                }
              }
              return i2;
            }
            getSourceTile(t2, e2) {
              const i2 = this.sourceCache._source;
              let o2 = t2.overscaledZ - this.deltaZoom;
              if (o2 > i2.maxzoom && (o2 = i2.maxzoom), o2 < i2.minzoom)
                return null;
              this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(o2).key);
              let a2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
              if ((!a2 || !a2.dem) && e2)
                for (; o2 > i2.minzoom && (!a2 || !a2.dem); )
                  a2 = this.sourceCache.getTileByID(t2.scaledTo(o2--).key);
              return a2;
            }
            tilesAfterTime(t2 = Date.now()) {
              return Object.values(this._tiles).filter((e2) => e2.timeLoaded >= t2);
            }
          }
          class te {
            constructor(t2, e2, i2) {
              this.style = t2, this.sourceCache = new Qt(e2), this.options = i2, this.exaggeration = typeof i2.exaggeration == "number" ? i2.exaggeration : 1, this.elevationOffset = typeof i2.elevationOffset == "number" ? i2.elevationOffset : 450, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024, this.clearRerenderCache();
            }
            getDEMElevation(e2, i2, o2, a2 = t.EXTENT) {
              if (!(i2 >= 0 && i2 < a2 && o2 >= 0 && o2 < a2))
                return this.elevationOffset;
              let s2 = 0;
              const r2 = this.getTerrainData(e2);
              if (r2.tile && r2.tile.dem) {
                const e3 = function(t2, e4, i3) {
                  var o3 = e4[0], a3 = e4[1];
                  return t2[0] = i3[0] * o3 + i3[4] * a3 + i3[12], t2[1] = i3[1] * o3 + i3[5] * a3 + i3[13], t2;
                }([], [i2 / a2 * t.EXTENT, o2 / a2 * t.EXTENT], r2.u_terrain_matrix), n2 = [e3[0] * r2.tile.dem.dim, e3[1] * r2.tile.dem.dim], l2 = [Math.floor(n2[0]), Math.floor(n2[1])], c2 = r2.tile.dem.get(l2[0], l2[1]), h2 = r2.tile.dem.get(l2[0], l2[1] + 1), u2 = r2.tile.dem.get(l2[0] + 1, l2[1]), d2 = r2.tile.dem.get(l2[0] + 1, l2[1] + 1);
                s2 = t.number(t.number(c2, h2, n2[0] - l2[0]), t.number(u2, d2, n2[0] - l2[0]), n2[1] - l2[1]);
              }
              return s2;
            }
            rememberForRerender(t2, e2) {
              for (const i2 in this.sourceCache._tiles) {
                const o2 = this.sourceCache._tiles[i2];
                (o2.tileID.equals(e2) || o2.tileID.isChildOf(e2)) && (t2 === this.sourceCache.sourceCache.id && (o2.timeLoaded = Date.now()), this._rerender[t2] = this._rerender[t2] || {}, this._rerender[t2][o2.tileID.key] = true);
              }
            }
            needsRerender(t2, e2) {
              return this._rerender[t2] && this._rerender[t2][e2.key];
            }
            clearRerenderCache() {
              this._rerender = {};
            }
            getElevation(e2, i2, o2, a2 = t.EXTENT) {
              return (this.getDEMElevation(e2, i2, o2, a2) + this.elevationOffset) * this.exaggeration;
            }
            getTerrainData(e2) {
              if (!this._emptyDemTexture) {
                const e3 = this.style.map.painter.context, i3 = new t.RGBAImage({ width: 1, height: 1 }, new Uint8Array(4));
                this._emptyDepthTexture = new d(e3, i3, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new d(e3, new t.RGBAImage({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.identity([]);
              }
              const i2 = this.sourceCache.getSourceTile(e2, true);
              if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
                const t2 = this.style.map.painter.context;
                i2.demTexture = this.style.map.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new d(t2, i2.dem.getPixels(), t2.gl.RGBA, { premultiply: false }), i2.demTexture.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
              }
              const o2 = i2 && i2 + i2.tileID.key + e2.key;
              if (o2 && !this._demMatrixCache[o2]) {
                const o3 = this.sourceCache.sourceCache._source.maxzoom;
                let a2 = e2.canonical.z - i2.tileID.canonical.z;
                e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= o3 ? a2 = e2.canonical.z - o3 : t.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                const s2 = e2.canonical.x - (e2.canonical.x >> a2 << a2), r2 = e2.canonical.y - (e2.canonical.y >> a2 << a2), n2 = t.fromScaling(new Float64Array(16), [1 / (t.EXTENT << a2), 1 / (t.EXTENT << a2), 0]);
                t.translate(n2, n2, [s2 * t.EXTENT, r2 * t.EXTENT, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
              }
              return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: o2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_offset: this.elevationOffset, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
            }
            getRTTFramebuffer() {
              const t2 = this.style.map.painter;
              if (!this._rttFramebuffer) {
                const e2 = this.sourceCache.tileSize * this.qualityFactor;
                this._rttFramebuffer = t2.context.createFramebuffer(e2, e2, true), this._rttFramebuffer.depthAttachment.set(t2.context.createRenderbuffer(t2.context.gl.DEPTH_COMPONENT16, e2, e2));
              }
              return this._rttFramebuffer;
            }
            getFramebuffer(t2) {
              const e2 = this.style.map.painter, i2 = e2.width / devicePixelRatio, o2 = e2.height / devicePixelRatio;
              return !this._fbo || this._fbo.width === i2 && this._fbo.height === o2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new d(e2.context, { width: i2, height: o2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new d(e2.context, { width: i2, height: o2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i2, o2, true), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i2, o2))), this._fbo.colorAttachment.set(t2 === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
              const e2 = this.style.map.painter.context;
              if (this._coordsTexture)
                return this._coordsTexture;
              const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
              for (let t2 = 0, e3 = 0; t2 < this._coordsTextureSize; t2++)
                for (let o3 = 0; o3 < this._coordsTextureSize; o3++, e3 += 4)
                  i2[e3 + 0] = 255 & o3, i2[e3 + 1] = 255 & t2, i2[e3 + 2] = o3 >> 8 << 4 | t2 >> 8, i2[e3 + 3] = 0;
              const o2 = new t.RGBAImage({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), a2 = new d(e2, o2, e2.gl.RGBA, { premultiply: false });
              return a2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = a2, a2;
            }
            pointCoordinate(e2) {
              const i2 = new Uint8Array(4), o2 = this.style.map.painter, a2 = o2.context, s2 = a2.gl;
              a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), s2.readPixels(e2.x, o2.height / devicePixelRatio - e2.y - 1, 1, 1, s2.RGBA, s2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
              const r2 = i2[0] + (i2[2] >> 4 << 8), n2 = i2[1] + ((15 & i2[2]) << 8), l2 = this.coordsIndex[255 - i2[3]], c2 = l2 && this.sourceCache.getTileByID(l2);
              if (!c2)
                return null;
              const h2 = this._coordsTextureSize, u2 = (1 << c2.tileID.canonical.z) * h2;
              return new t.MercatorCoordinate((c2.tileID.canonical.x * h2 + r2) / u2, (c2.tileID.canonical.y * h2 + n2) / u2, this.getElevation(c2.tileID, r2, n2, h2));
            }
            getTerrainMesh() {
              if (this._mesh)
                return this._mesh;
              const e2 = this.style.map.painter.context, i2 = new t.PosArray(), o2 = new t.TriangleIndexArray(), a2 = this.meshSize, s2 = t.EXTENT / a2, r2 = a2 * a2;
              for (let t2 = 0; t2 <= a2; t2++)
                for (let e3 = 0; e3 <= a2; e3++)
                  i2.emplaceBack(e3 * s2, t2 * s2);
              for (let t2 = 0; t2 < r2; t2 += a2 + 1)
                for (let e3 = 0; e3 < a2; e3++)
                  o2.emplaceBack(e3 + t2, a2 + e3 + t2 + 1, a2 + e3 + t2 + 2), o2.emplaceBack(e3 + t2, a2 + e3 + t2 + 2, e3 + t2 + 1);
              return this._mesh = { indexBuffer: e2.createIndexBuffer(o2), vertexBuffer: e2.createVertexBuffer(i2, Jt.members), segments: t.SegmentVector.simpleSegment(0, 0, i2.length, o2.length) }, this._mesh;
            }
          }
          const ee = (e2, i2) => t.emitValidationErrors(e2, i2 && i2.filter((t2) => t2.identifier !== "source.canvas")), ie = t.pick(J, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), oe = t.pick(J, ["setCenter", "setZoom", "setBearing", "setPitch"]), ae = function() {
            const e2 = {}, i2 = t.spec.$version;
            for (const o2 in t.spec.$root) {
              const a2 = t.spec.$root[o2];
              if (a2.required) {
                let t2 = null;
                t2 = o2 === "version" ? i2 : a2.type === "array" ? [] : {}, t2 != null && (e2[o2] = t2);
              }
            }
            return e2;
          }();
          class se extends t.Evented {
            constructor(e2, i2 = {}) {
              super(), this.map = e2, this.dispatcher = new T(H(), this), this.imageManager = new m(), this.imageManager.setEventedParent(this), this.glyphManager = new x(e2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new w(256, 512), this.crossTileSymbolIndex = new Yt(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
              const o2 = this;
              this._rtlTextPluginCallback = se.registerForPluginStateChange((e3) => {
                o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, i3) => {
                  if (t.triggerPluginCompletionEvent(e4), i3 && i3.every((t2) => t2))
                    for (const t2 in o2.sourceCaches)
                      o2.sourceCaches[t2].reload();
                });
              }), this.on("data", (t2) => {
                if (t2.dataType !== "source" || t2.sourceDataType !== "metadata")
                  return;
                const e3 = this.sourceCaches[t2.sourceId];
                if (!e3)
                  return;
                const i3 = e3.getSource();
                if (i3 && i3.vectorLayerIds)
                  for (const t3 in this._layers) {
                    const e4 = this._layers[t3];
                    e4.source === i3.id && this._validateLayer(e4);
                  }
              });
            }
            loadURL(e2, i2 = {}) {
              this.fire(new t.Event("dataloading", { dataType: "style" }));
              const o2 = typeof i2.validate != "boolean" || i2.validate, a2 = this.map._requestManager.transformRequest(e2, t.ResourceType.Style);
              this._request = t.getJSON(a2, (e3, i3) => {
                this._request = null, e3 ? this.fire(new t.ErrorEvent(e3)) : i3 && this._load(i3, o2);
              });
            }
            loadJSON(e2, i2 = {}) {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.exported.frame(() => {
                this._request = null, this._load(e2, i2.validate !== false);
              });
            }
            loadEmpty() {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(ae, false);
            }
            _load(e2, i2) {
              if (i2 && ee(this, t.validateStyle(e2)))
                return;
              this._loaded = true, this.stylesheet = e2;
              for (const t2 in e2.sources)
                this.addSource(t2, e2.sources[t2], { validate: false });
              e2.sprite ? this._loadSprite(e2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e2.glyphs);
              const o2 = Y(this.stylesheet.layers);
              this._order = o2.map((t2) => t2.id), this._layers = {}, this._serializedLayers = {};
              for (let e3 of o2)
                e3 = t.createStyleLayer(e3), e3.setEventedParent(this, { layer: { id: e3.id } }), this._layers[e3.id] = e3, this._serializedLayers[e3.id] = e3.serialize();
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new b(this.stylesheet.light), this.setTerrain(this.stylesheet.terrain), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
            }
            _loadSprite(e2) {
              this._spriteRequest = function(e3, i2, o2, a2) {
                let s2, r2, n2;
                const l2 = o2 > 1 ? "@2x" : "";
                let c2 = t.getJSON(i2.transformRequest(i2.normalizeSpriteURL(e3, l2, ".json"), t.ResourceType.SpriteJSON), (t2, e4) => {
                  c2 = null, n2 || (n2 = t2, s2 = e4, u2());
                }), h2 = t.getImage(i2.transformRequest(i2.normalizeSpriteURL(e3, l2, ".png"), t.ResourceType.SpriteImage), (t2, e4) => {
                  h2 = null, n2 || (n2 = t2, r2 = e4, u2());
                });
                function u2() {
                  if (n2)
                    a2(n2);
                  else if (s2 && r2) {
                    const e4 = t.exported.getImageData(r2), i3 = {};
                    for (const o3 in s2) {
                      const { width: a3, height: r3, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u3, stretchY: d2, content: _2 } = s2[o3], m2 = new t.RGBAImage({ width: a3, height: r3 });
                      t.RGBAImage.copy(e4, m2, { x: n3, y: l3 }, { x: 0, y: 0 }, { width: a3, height: r3 }), i3[o3] = { data: m2, pixelRatio: h3, sdf: c3, stretchX: u3, stretchY: d2, content: _2 };
                    }
                    a2(null, i3);
                  }
                }
                return { cancel() {
                  c2 && (c2.cancel(), c2 = null), h2 && (h2.cancel(), h2 = null);
                } };
              }(e2, this.map._requestManager, this.map.getPixelRatio(), (e3, i2) => {
                if (this._spriteRequest = null, e3)
                  this.fire(new t.ErrorEvent(e3));
                else if (i2)
                  for (const t2 in i2)
                    this.imageManager.addImage(t2, i2[t2]);
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
              });
            }
            _validateLayer(e2) {
              const i2 = this.sourceCaches[e2.source];
              if (!i2)
                return;
              const o2 = e2.sourceLayer;
              if (!o2)
                return;
              const a2 = i2.getSource();
              (a2.type === "geojson" || a2.vectorLayerIds && a2.vectorLayerIds.indexOf(o2) === -1) && this.fire(new t.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${a2.id}" as specified by style layer "${e2.id}".`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (const t2 in this.sourceCaches)
                if (!this.sourceCaches[t2].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeLayers(t2) {
              const e2 = [];
              for (const i2 of t2) {
                const t3 = this._layers[i2];
                t3.type !== "custom" && e2.push(t3.serialize());
              }
              return e2;
            }
            hasTransitions() {
              if (this.light && this.light.hasTransition())
                return true;
              for (const t2 in this.sourceCaches)
                if (this.sourceCaches[t2].hasTransition())
                  return true;
              for (const t2 in this._layers)
                if (this._layers[t2].hasTransition())
                  return true;
              return false;
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading.");
            }
            update(e2) {
              if (!this._loaded)
                return;
              const i2 = this._changed;
              if (this._changed) {
                const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
                (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
                for (const t3 in this._updatedSources) {
                  const e3 = this._updatedSources[t3];
                  e3 === "reload" ? this._reloadSource(t3) : e3 === "clear" && this._clearSource(t3);
                }
                this._updateTilesForChangedImages();
                for (const t3 in this._updatedPaintProps)
                  this._layers[t3].updateTransitions(e2);
                this.light.updateTransitions(e2), this._resetUpdates();
              }
              const o2 = {};
              for (const t2 in this.sourceCaches) {
                const e3 = this.sourceCaches[t2];
                o2[t2] = e3.used, e3.used = false;
              }
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
              }
              for (const e3 in o2) {
                const i3 = this.sourceCaches[e3];
                o2[e3] !== i3.used && i3.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
              }
              this.light.recalculate(e2), this.z = e2.zoom, i2 && this.fire(new t.Event("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const t2 = Object.keys(this._changedImages);
              if (t2.length) {
                for (const e2 in this.sourceCaches)
                  this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
                this._changedImages = {};
              }
            }
            _updateWorkerLayers(t2, e2) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e2 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setTerrain(e2) {
              if (this._checkLoaded(), this._terrainDataCallback && this.off("data", this._terrainDataCallback), this._terrainfreezeElevationCallback && this.map.off("freezeElevation", this._terrainfreezeElevationCallback), e2) {
                const t2 = this.sourceCaches[e2.source];
                if (!t2)
                  throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
                this.terrain = new te(this, t2, e2), this.map.transform.updateElevation(this.terrain), this._terrainfreezeElevationCallback = (t3) => {
                  t3.freeze ? this.map.transform.freezeElevation = true : (this.map.transform.freezeElevation = false, this.map.transform.recalculateZoom(this.terrain));
                }, this._terrainDataCallback = (t3) => {
                  t3.tile && (t3.sourceId === e2.source ? (this.map.transform.updateElevation(this.terrain), this.terrain.rememberForRerender(t3.sourceId, t3.tile.tileID)) : t3.source.type === "geojson" && this.terrain.rememberForRerender(t3.sourceId, t3.tile.tileID));
                }, this.on("data", this._terrainDataCallback), this.map.on("freezeElevation", this._terrainfreezeElevationCallback);
              } else
                this.terrain = null, this.map.transform.updateElevation(this.terrain);
              this.map.fire(new t.Event("terrain", { terrain: e2 }));
            }
            setState(e2) {
              if (this._checkLoaded(), ee(this, t.validateStyle(e2)))
                return false;
              (e2 = t.clone$1(e2)).layers = Y(e2.layers);
              const i2 = function(t2, e3) {
                if (!t2)
                  return [{ command: J.setStyle, args: [e3] }];
                let i3 = [];
                try {
                  if (!a(t2.version, e3.version))
                    return [{ command: J.setStyle, args: [e3] }];
                  a(t2.center, e3.center) || i3.push({ command: J.setCenter, args: [e3.center] }), a(t2.zoom, e3.zoom) || i3.push({ command: J.setZoom, args: [e3.zoom] }), a(t2.bearing, e3.bearing) || i3.push({ command: J.setBearing, args: [e3.bearing] }), a(t2.pitch, e3.pitch) || i3.push({ command: J.setPitch, args: [e3.pitch] }), a(t2.sprite, e3.sprite) || i3.push({ command: J.setSprite, args: [e3.sprite] }), a(t2.glyphs, e3.glyphs) || i3.push({ command: J.setGlyphs, args: [e3.glyphs] }), a(t2.transition, e3.transition) || i3.push({ command: J.setTransition, args: [e3.transition] }), a(t2.light, e3.light) || i3.push({ command: J.setLight, args: [e3.light] });
                  const o3 = {}, s2 = [];
                  !function(t3, e4, i4, o4) {
                    let s3;
                    for (s3 in e4 = e4 || {}, t3 = t3 || {})
                      Object.prototype.hasOwnProperty.call(t3, s3) && (Object.prototype.hasOwnProperty.call(e4, s3) || tt(s3, i4, o4));
                    for (s3 in e4)
                      Object.prototype.hasOwnProperty.call(e4, s3) && (Object.prototype.hasOwnProperty.call(t3, s3) ? a(t3[s3], e4[s3]) || (t3[s3].type === "geojson" && e4[s3].type === "geojson" && it(t3, e4, s3) ? i4.push({ command: J.setGeoJSONSourceData, args: [s3, e4[s3].data] }) : et(s3, e4, i4, o4)) : Q(s3, e4, i4));
                  }(t2.sources, e3.sources, s2, o3);
                  const r2 = [];
                  t2.layers && t2.layers.forEach((t3) => {
                    o3[t3.source] ? i3.push({ command: J.removeLayer, args: [t3.id] }) : r2.push(t3);
                  }), i3 = i3.concat(s2), function(t3, e4, i4) {
                    e4 = e4 || [];
                    const o4 = (t3 = t3 || []).map(at), s3 = e4.map(at), r3 = t3.reduce(st, {}), n2 = e4.reduce(st, {}), l2 = o4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                    let h2, u2, d2, _2, m2, p2, f2;
                    for (h2 = 0, u2 = 0; h2 < o4.length; h2++)
                      d2 = o4[h2], Object.prototype.hasOwnProperty.call(n2, d2) ? u2++ : (i4.push({ command: J.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, u2), 1));
                    for (h2 = 0, u2 = 0; h2 < s3.length; h2++)
                      d2 = s3[s3.length - 1 - h2], l2[l2.length - 1 - h2] !== d2 && (Object.prototype.hasOwnProperty.call(r3, d2) ? (i4.push({ command: J.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - u2), 1)) : u2++, p2 = l2[l2.length - h2], i4.push({ command: J.addLayer, args: [n2[d2], p2] }), l2.splice(l2.length - h2, 0, d2), c2[d2] = true);
                    for (h2 = 0; h2 < s3.length; h2++)
                      if (d2 = s3[h2], _2 = r3[d2], m2 = n2[d2], !c2[d2] && !a(_2, m2))
                        if (a(_2.source, m2.source) && a(_2["source-layer"], m2["source-layer"]) && a(_2.type, m2.type)) {
                          for (f2 in ot(_2.layout, m2.layout, i4, d2, null, J.setLayoutProperty), ot(_2.paint, m2.paint, i4, d2, null, J.setPaintProperty), a(_2.filter, m2.filter) || i4.push({ command: J.setFilter, args: [d2, m2.filter] }), a(_2.minzoom, m2.minzoom) && a(_2.maxzoom, m2.maxzoom) || i4.push({ command: J.setLayerZoomRange, args: [d2, m2.minzoom, m2.maxzoom] }), _2)
                            Object.prototype.hasOwnProperty.call(_2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? ot(_2[f2], m2[f2], i4, d2, f2.slice(6), J.setPaintProperty) : a(_2[f2], m2[f2]) || i4.push({ command: J.setLayerProperty, args: [d2, f2, m2[f2]] }));
                          for (f2 in m2)
                            Object.prototype.hasOwnProperty.call(m2, f2) && !Object.prototype.hasOwnProperty.call(_2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? ot(_2[f2], m2[f2], i4, d2, f2.slice(6), J.setPaintProperty) : a(_2[f2], m2[f2]) || i4.push({ command: J.setLayerProperty, args: [d2, f2, m2[f2]] }));
                        } else
                          i4.push({ command: J.removeLayer, args: [d2] }), p2 = l2[l2.lastIndexOf(d2) + 1], i4.push({ command: J.addLayer, args: [m2, p2] });
                  }(r2, e3.layers, i3);
                } catch (t3) {
                  console.warn("Unable to compute style diff:", t3), i3 = [{ command: J.setStyle, args: [e3] }];
                }
                return i3;
              }(this.serialize(), e2).filter((t2) => !(t2.command in oe));
              if (i2.length === 0)
                return false;
              const o2 = i2.filter((t2) => !(t2.command in ie));
              if (o2.length > 0)
                throw new Error(`Unimplemented: ${o2.map((t2) => t2.command).join(", ")}.`);
              return i2.forEach((t2) => {
                t2.command !== "setTransition" && this[t2.command].apply(this, t2.args);
              }), this.stylesheet = e2, true;
            }
            addImage(e2, i2) {
              if (this.getImage(e2))
                return this.fire(new t.ErrorEvent(new Error(`An image named "${e2}" already exists.`)));
              this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
            }
            updateImage(t2, e2) {
              this.imageManager.updateImage(t2, e2);
            }
            getImage(t2) {
              return this.imageManager.getImage(t2);
            }
            removeImage(e2) {
              if (!this.getImage(e2))
                return this.fire(new t.ErrorEvent(new Error(`An image named "${e2}" does not exist.`)));
              this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
            }
            _afterImageUpdated(e2) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e2, i2, o2 = {}) {
              if (this._checkLoaded(), this.sourceCaches[e2] !== void 0)
                throw new Error(`Source "${e2}" already exists.`);
              if (!i2.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.validateStyle.source, `sources.${e2}`, i2, null, o2))
                return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const a2 = this.sourceCaches[e2] = new Z(e2, i2, this.dispatcher);
              a2.style = this, a2.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: a2.serialize(), sourceId: e2 })), a2.onAdd(this.map), this._changed = true;
            }
            removeSource(e2) {
              if (this._checkLoaded(), this.sourceCaches[e2] === void 0)
                throw new Error("There is no source with this ID");
              for (const i3 in this._layers)
                if (this._layers[i3].source === e2)
                  return this.fire(new t.ErrorEvent(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
              const i2 = this.sourceCaches[e2];
              delete this.sourceCaches[e2], delete this._updatedSources[e2], i2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(t2, e2) {
              this._checkLoaded(), this.sourceCaches[t2].getSource().setData(e2), this._changed = true;
            }
            getSource(t2) {
              return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
            }
            addLayer(e2, i2, o2 = {}) {
              this._checkLoaded();
              const a2 = e2.id;
              if (this.getLayer(a2))
                return void this.fire(new t.ErrorEvent(new Error(`Layer "${a2}" already exists on this map.`)));
              let s2;
              if (e2.type === "custom") {
                if (ee(this, t.validateCustomStyleLayer(e2)))
                  return;
                s2 = t.createStyleLayer(e2);
              } else {
                if (typeof e2.source == "object" && (this.addSource(a2, e2.source), e2 = t.clone$1(e2), e2 = t.extend(e2, { source: a2 })), this._validate(t.validateStyle.layer, `layers.${a2}`, e2, { arrayIndex: -1 }, o2))
                  return;
                s2 = t.createStyleLayer(e2), this._validateLayer(s2), s2.setEventedParent(this, { layer: { id: a2 } }), this._serializedLayers[s2.id] = s2.serialize();
              }
              const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
              if (i2 && r2 === -1)
                this.fire(new t.ErrorEvent(new Error(`Cannot add layer "${a2}" before non-existing layer "${i2}".`)));
              else {
                if (this._order.splice(r2, 0, a2), this._layerOrderChanged = true, this._layers[a2] = s2, this._removedLayers[a2] && s2.source && s2.type !== "custom") {
                  const t2 = this._removedLayers[a2];
                  delete this._removedLayers[a2], t2.type !== s2.type ? this._updatedSources[s2.source] = "clear" : (this._updatedSources[s2.source] = "reload", this.sourceCaches[s2.source].pause());
                }
                this._updateLayer(s2), s2.onAdd && s2.onAdd(this.map);
              }
            }
            moveLayer(e2, i2) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e2])
                return void this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
              if (e2 === i2)
                return;
              const o2 = this._order.indexOf(e2);
              this._order.splice(o2, 1);
              const a2 = i2 ? this._order.indexOf(i2) : this._order.length;
              i2 && a2 === -1 ? this.fire(new t.ErrorEvent(new Error(`Cannot move layer "${e2}" before non-existing layer "${i2}".`))) : (this._order.splice(a2, 0, e2), this._layerOrderChanged = true);
            }
            removeLayer(e2) {
              this._checkLoaded();
              const i2 = this._layers[e2];
              if (!i2)
                return void this.fire(new t.ErrorEvent(new Error(`Cannot remove non-existing layer "${e2}".`)));
              i2.setEventedParent(null);
              const o2 = this._order.indexOf(e2);
              this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i2, delete this._layers[e2], delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map);
            }
            getLayer(t2) {
              return this._layers[t2];
            }
            hasLayer(t2) {
              return t2 in this._layers;
            }
            setLayerZoomRange(e2, i2, o2) {
              this._checkLoaded();
              const a2 = this.getLayer(e2);
              a2 ? a2.minzoom === i2 && a2.maxzoom === o2 || (i2 != null && (a2.minzoom = i2), o2 != null && (a2.maxzoom = o2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
            }
            setFilter(e2, i2, o2 = {}) {
              this._checkLoaded();
              const s2 = this.getLayer(e2);
              if (s2) {
                if (!a(s2.filter, i2))
                  return i2 == null ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(t.validateStyle.filter, `layers.${s2.id}.filter`, i2, null, o2) || (s2.filter = t.clone$1(i2), this._updateLayer(s2)));
              } else
                this.fire(new t.ErrorEvent(new Error(`Cannot filter non-existing layer "${e2}".`)));
            }
            getFilter(e2) {
              return t.clone$1(this.getLayer(e2).filter);
            }
            setLayoutProperty(e2, i2, o2, s2 = {}) {
              this._checkLoaded();
              const r2 = this.getLayer(e2);
              r2 ? a(r2.getLayoutProperty(i2), o2) || (r2.setLayoutProperty(i2, o2, s2), this._updateLayer(r2)) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e2}".`)));
            }
            getLayoutProperty(e2, i2) {
              const o2 = this.getLayer(e2);
              if (o2)
                return o2.getLayoutProperty(i2);
              this.fire(new t.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e2}".`)));
            }
            setPaintProperty(e2, i2, o2, s2 = {}) {
              this._checkLoaded();
              const r2 = this.getLayer(e2);
              r2 ? a(r2.getPaintProperty(i2), o2) || (r2.setPaintProperty(i2, o2, s2) && this._updateLayer(r2), this._changed = true, this._updatedPaintProps[e2] = true) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e2}".`)));
            }
            getPaintProperty(t2, e2) {
              return this.getLayer(t2).getPaintProperty(e2);
            }
            setFeatureState(e2, i2) {
              this._checkLoaded();
              const o2 = e2.source, a2 = e2.sourceLayer, s2 = this.sourceCaches[o2];
              if (s2 === void 0)
                return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const r2 = s2.getSource().type;
              r2 === "geojson" && a2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : r2 !== "vector" || a2 ? (e2.id === void 0 && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), s2.setFeatureState(a2, e2.id, i2)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e2, i2) {
              this._checkLoaded();
              const o2 = e2.source, a2 = this.sourceCaches[o2];
              if (a2 === void 0)
                return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const s2 = a2.getSource().type, r2 = s2 === "vector" ? e2.sourceLayer : void 0;
              s2 !== "vector" || r2 ? i2 && typeof e2.id != "string" && typeof e2.id != "number" ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a2.removeFeatureState(r2, e2.id, i2) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e2) {
              this._checkLoaded();
              const i2 = e2.source, o2 = e2.sourceLayer, a2 = this.sourceCaches[i2];
              if (a2 !== void 0)
                return a2.getSource().type !== "vector" || o2 ? (e2.id === void 0 && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.getFeatureState(o2, e2.id)) : void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              this.fire(new t.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, (t2) => t2.serialize()), layers: this._serializeLayers(this._order) }, (t2) => t2 !== void 0);
            }
            _updateLayer(t2) {
              this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && this.sourceCaches[t2.source].getSource().type !== "raster" && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = true;
            }
            _flattenAndSortRenderedFeatures(t2) {
              const e2 = (t3) => this._layers[t3].type === "fill-extrusion", i2 = {}, o2 = [];
              for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
                const s2 = this._order[a3];
                if (e2(s2)) {
                  i2[s2] = a3;
                  for (const e3 of t2) {
                    const t3 = e3[s2];
                    if (t3)
                      for (const e4 of t3)
                        o2.push(e4);
                  }
                }
              }
              o2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
              const a2 = [];
              for (let s2 = this._order.length - 1; s2 >= 0; s2--) {
                const r2 = this._order[s2];
                if (e2(r2))
                  for (let t3 = o2.length - 1; t3 >= 0; t3--) {
                    const e3 = o2[t3].feature;
                    if (i2[e3.layer.id] < s2)
                      break;
                    a2.push(e3), o2.pop();
                  }
                else
                  for (const e3 of t2) {
                    const t3 = e3[r2];
                    if (t3)
                      for (const e4 of t3)
                        a2.push(e4.feature);
                  }
              }
              return a2;
            }
            queryRenderedFeatures(e2, i2, o2) {
              i2 && i2.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
              const a2 = {};
              if (i2 && i2.layers) {
                if (!Array.isArray(i2.layers))
                  return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (const e3 of i2.layers) {
                  const i3 = this._layers[e3];
                  if (!i3)
                    return this.fire(new t.ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                  a2[i3.source] = true;
                }
              }
              const s2 = [];
              i2.availableImages = this._availableImages;
              for (const t2 in this.sourceCaches)
                i2.layers && !a2[t2] || s2.push(F(this.sourceCaches[t2], this._layers, this._serializedLayers, e2, i2, o2));
              return this.placement && s2.push(function(t2, e3, i3, o3, a3, s3, r2) {
                const n2 = {}, l2 = s3.queryRenderedSymbols(o3), c2 = [];
                for (const t3 of Object.keys(l2).map(Number))
                  c2.push(r2[t3]);
                c2.sort(O);
                for (const i4 of c2) {
                  const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e3, i4.bucketIndex, i4.sourceLayerIndex, a3.filter, a3.layers, a3.availableImages, t2);
                  for (const t3 in o4) {
                    const e4 = n2[t3] = n2[t3] || [], a4 = o4[t3];
                    a4.sort((t4, e5) => {
                      const o5 = i4.featureSortOrder;
                      if (o5) {
                        const i5 = o5.indexOf(t4.featureIndex);
                        return o5.indexOf(e5.featureIndex) - i5;
                      }
                      return e5.featureIndex - t4.featureIndex;
                    });
                    for (const t4 of a4)
                      e4.push(t4);
                  }
                }
                for (const e4 in n2)
                  n2[e4].forEach((o4) => {
                    const a4 = o4.feature, s4 = i3[t2[e4].source].getFeatureState(a4.layer["source-layer"], a4.id);
                    a4.source = a4.layer.source, a4.layer["source-layer"] && (a4.sourceLayer = a4.layer["source-layer"]), a4.state = s4;
                  });
                return n2;
              }(this._layers, this._serializedLayers, this.sourceCaches, e2, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s2);
            }
            querySourceFeatures(e2, i2) {
              i2 && i2.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i2.filter, null, i2);
              const o2 = this.sourceCaches[e2];
              return o2 ? function(t2, e3) {
                const i3 = t2.getRenderableIds().map((e4) => t2.getTileByID(e4)), o3 = [], a2 = {};
                for (let t3 = 0; t3 < i3.length; t3++) {
                  const s2 = i3[t3], r2 = s2.tileID.canonical.key;
                  a2[r2] || (a2[r2] = true, s2.querySourceFeatures(o3, e3));
                }
                return o3;
              }(o2, i2) : [];
            }
            addSourceType(t2, e2, i2) {
              return se.getSourceType(t2) ? i2(new Error(`A source type called "${t2}" already exists.`)) : (se.setSourceType(t2, e2), e2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e2.workerSourceURL }, i2) : i2(null, null));
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e2, i2 = {}) {
              this._checkLoaded();
              const o2 = this.light.getLight();
              let s2 = false;
              for (const t2 in e2)
                if (!a(e2[t2], o2[t2])) {
                  s2 = true;
                  break;
                }
              if (!s2)
                return;
              const r2 = { now: t.exported.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e2, i2), this.light.updateTransitions(r2);
            }
            _validate(e2, i2, o2, a2, s2 = {}) {
              return (!s2 || s2.validate !== false) && ee(this, e2.call(t.validateStyle, t.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: t.spec }, a2)));
            }
            _remove() {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const t2 in this._layers)
                this._layers[t2].setEventedParent(null);
              for (const t2 in this.sourceCaches) {
                const e2 = this.sourceCaches[t2];
                e2.setEventedParent(null), e2.onRemove(this.map);
              }
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(t2) {
              this.sourceCaches[t2].clearTiles();
            }
            _reloadSource(t2) {
              this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
            }
            _updateSources(t2) {
              for (const e2 in this.sourceCaches)
                this.sourceCaches[e2].update(t2, this.terrain);
            }
            _generateCollisionBoxes() {
              for (const t2 in this.sourceCaches)
                this._reloadSource(t2);
            }
            _updatePlacement(e2, i2, o2, a2, s2 = false) {
              let r2 = false, n2 = false;
              const l2 = {};
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                if (i3.type !== "symbol")
                  continue;
                if (!l2[i3.source]) {
                  const t3 = this.sourceCaches[i3.source];
                  l2[i3.source] = t3.getRenderableIds(true).map((e3) => t3.getTileByID(e3)).sort((t4, e3) => e3.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e3.tileID) ? -1 : 1));
                }
                const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], e2.center.lng);
                r2 = r2 || o3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((s2 = s2 || this._layerOrderChanged || o2 === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e2.zoom)) && (this.pauseablePlacement = new Xt(e2, this.terrain, this._order, s2, i2, o2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2)
                for (const t2 of this._order) {
                  const e3 = this._layers[t2];
                  e3.type === "symbol" && this.placement.updateLayerOpacities(e3, l2[e3.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now());
            }
            _releaseSymbolFadeTiles() {
              for (const t2 in this.sourceCaches)
                this.sourceCaches[t2].releaseSymbolFadeTiles();
            }
            getImages(t2, e2, i2) {
              this.imageManager.getImages(e2.icons, i2), this._updateTilesForChangedImages();
              const o2 = this.sourceCaches[e2.source];
              o2 && o2.setDependencies(e2.tileID.key, e2.type, e2.icons);
            }
            getGlyphs(t2, e2, i2) {
              this.glyphManager.getGlyphs(e2.stacks, i2);
            }
            getResource(e2, i2, o2) {
              return t.makeRequest(i2, o2);
            }
          }
          se.getSourceType = function(t2) {
            return k[t2];
          }, se.setSourceType = function(t2, e2) {
            k[t2] = e2;
          }, se.registerForPluginStateChange = t.registerForPluginStateChange;
          var re = "attribute vec2 a_pos;uniform mat4 u_matrix;varying vec2 v_texture_pos;varying float v_depth;void main() {v_texture_pos=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);v_depth=gl_Position.z/gl_Position.w;}", ne = { prelude: le("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_offset;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return (elevation+u_terrain_offset)*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: le("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: le("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: le("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: le("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: le("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: le("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: le("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: le("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: le("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: le("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: le("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: le("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: le("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: le("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat baseDelta=10.0;float ele=get_elevation(a_centroid);\n#else\nfloat baseDelta=0.0;float ele=0.0;\n#endif\nbase=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: le("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat baseDelta=10.0;float ele=get_elevation(a_centroid);\n#else\nfloat baseDelta=0.0;float ele=0.0;\n#endif\nbase=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: le("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: le("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: le("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: le("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: le("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: le("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: le("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: le("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: le("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: le("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: le("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", re), terrainDepth: le("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", re), terrainCoords: le("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", re) };
          function le(t2, e2) {
            const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e2.match(/attribute ([\w]+) ([\w]+)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = s2 ? s2.concat(a2) : a2, n2 = {};
            return { fragmentSource: t2 = t2.replace(i2, (t3, e3, i3, o3, a3) => (n2[a3] = true, e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${a3}
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`)), vertexSource: e2 = e2.replace(i2, (t3, e3, i3, o3, a3) => {
              const s3 = o3 === "float" ? "vec2" : "vec4", r3 = a3.match(/color/) ? "color" : s3;
              return n2[a3] ? e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${s3} a_${a3};
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : r3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${s3} a_${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : r3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`;
            }), staticAttributes: o2, staticUniforms: r2 };
          }
          class ce {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(t2, e2, i2, o2, a2, s2, r2, n2, l2) {
              this.context = t2;
              let c2 = this.boundPaintVertexBuffers.length !== o2.length;
              for (let t3 = 0; !c2 && t3 < o2.length; t3++)
                this.boundPaintVertexBuffers[t3] !== o2[t3] && (c2 = true);
              t2.extVertexArrayObject && this.vao && this.boundProgram === e2 && this.boundLayoutVertexBuffer === i2 && !c2 && this.boundIndexBuffer === a2 && this.boundVertexOffset === s2 && this.boundDynamicVertexBuffer === r2 && this.boundDynamicVertexBuffer2 === n2 && this.boundDynamicVertexBuffer3 === l2 ? (t2.bindVertexArrayOES.set(this.vao), r2 && r2.bind(), a2 && a2.dynamicDraw && a2.bind(), n2 && n2.bind(), l2 && l2.bind()) : this.freshBind(e2, i2, o2, a2, s2, r2, n2, l2);
            }
            freshBind(t2, e2, i2, o2, a2, s2, r2, n2) {
              let l2;
              const c2 = t2.numAttributes, h2 = this.context, u2 = h2.gl;
              if (h2.extVertexArrayObject)
                this.vao && this.destroy(), this.vao = h2.extVertexArrayObject.createVertexArrayOES(), h2.bindVertexArrayOES.set(this.vao), l2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = a2, this.boundDynamicVertexBuffer = s2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n2;
              else {
                l2 = h2.currentNumAttributes || 0;
                for (let t3 = c2; t3 < l2; t3++)
                  u2.disableVertexAttribArray(t3);
              }
              e2.enableAttributes(u2, t2);
              for (const e3 of i2)
                e3.enableAttributes(u2, t2);
              s2 && s2.enableAttributes(u2, t2), r2 && r2.enableAttributes(u2, t2), n2 && n2.enableAttributes(u2, t2), e2.bind(), e2.setVertexAttribPointers(u2, t2, a2);
              for (const e3 of i2)
                e3.bind(), e3.setVertexAttribPointers(u2, t2, a2);
              s2 && (s2.bind(), s2.setVertexAttribPointers(u2, t2, a2)), o2 && o2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(u2, t2, a2)), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t2, a2)), h2.currentNumAttributes = c2;
            }
            destroy() {
              this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
          }
          function he(t2) {
            const e2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              if (t2[i2] === null)
                continue;
              const o2 = t2[i2].split(" ");
              e2.push(o2.pop());
            }
            return e2;
          }
          class ue {
            constructor(e2, i2, o2, a2, s2, r2, n2) {
              const l2 = e2.gl;
              this.program = l2.createProgram();
              const c2 = he(o2.staticAttributes), h2 = a2 ? a2.getBinderAttributes() : [], u2 = c2.concat(h2), d2 = ne.prelude.staticUniforms ? he(ne.prelude.staticUniforms) : [], _2 = o2.staticUniforms ? he(o2.staticUniforms) : [], m2 = a2 ? a2.getBinderUniforms() : [], p2 = d2.concat(_2).concat(m2), f2 = [];
              for (const t2 of p2)
                f2.indexOf(t2) < 0 && f2.push(t2);
              const g2 = a2 ? a2.defines() : [];
              r2 && g2.push("#define OVERDRAW_INSPECTOR;"), n2 && g2.push("#define TERRAIN3D;");
              const x2 = g2.concat(ne.prelude.fragmentSource, o2.fragmentSource).join("\n"), v2 = g2.concat(ne.prelude.vertexSource, o2.vertexSource).join("\n"), y2 = l2.createShader(l2.FRAGMENT_SHADER);
              if (l2.isContextLost())
                return void (this.failedToCreate = true);
              l2.shaderSource(y2, x2), l2.compileShader(y2), l2.attachShader(this.program, y2);
              const b2 = l2.createShader(l2.VERTEX_SHADER);
              if (l2.isContextLost())
                return void (this.failedToCreate = true);
              l2.shaderSource(b2, v2), l2.compileShader(b2), l2.attachShader(this.program, b2), this.attributes = {};
              const w2 = {};
              this.numAttributes = u2.length;
              for (let t2 = 0; t2 < this.numAttributes; t2++)
                u2[t2] && (l2.bindAttribLocation(this.program, t2, u2[t2]), this.attributes[u2[t2]] = t2);
              l2.linkProgram(this.program), l2.deleteShader(b2), l2.deleteShader(y2);
              for (let t2 = 0; t2 < f2.length; t2++) {
                const e3 = f2[t2];
                if (e3 && !w2[e3]) {
                  const t3 = l2.getUniformLocation(this.program, e3);
                  t3 && (w2[e3] = t3);
                }
              }
              this.fixedUniforms = s2(e2, w2), this.terrainUniforms = ((e3, i3) => ({ u_depth: new t.Uniform1i(e3, i3.u_depth), u_terrain: new t.Uniform1i(e3, i3.u_terrain), u_terrain_dim: new t.Uniform1f(e3, i3.u_terrain_dim), u_terrain_matrix: new t.UniformMatrix4f(e3, i3.u_terrain_matrix), u_terrain_unpack: new t.Uniform4f(e3, i3.u_terrain_unpack), u_terrain_offset: new t.Uniform1f(e3, i3.u_terrain_offset), u_terrain_exaggeration: new t.Uniform1f(e3, i3.u_terrain_exaggeration) }))(e2, w2), this.binderUniforms = a2 ? a2.getUniforms(e2, w2) : [];
            }
            draw(t2, e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2, _2, m2, p2, f2, g2) {
              const x2 = t2.gl;
              if (this.failedToCreate)
                return;
              if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(a2), t2.setCullFace(s2), n2) {
                t2.activeTexture.set(x2.TEXTURE2), x2.bindTexture(x2.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(x2.TEXTURE3), x2.bindTexture(x2.TEXTURE_2D, n2.texture);
                for (const t3 in this.terrainUniforms)
                  this.terrainUniforms[t3].set(n2[t3]);
              }
              for (const t3 in this.fixedUniforms)
                this.fixedUniforms[t3].set(r2[t3]);
              m2 && m2.setUniforms(t2, this.binderUniforms, d2, { zoom: _2 });
              const v2 = { [x2.LINES]: 2, [x2.TRIANGLES]: 3, [x2.LINE_STRIP]: 1 }[e2];
              for (const i3 of u2.get()) {
                const o3 = i3.vaos || (i3.vaos = {});
                (o3[l2] || (o3[l2] = new ce())).bind(t2, this, c2, m2 ? m2.getPaintVertexBuffers() : [], h2, i3.vertexOffset, p2, f2, g2), x2.drawElements(e2, i3.primitiveLength * v2, x2.UNSIGNED_SHORT, i3.primitiveOffset * v2 * 2);
              }
            }
          }
          function de(t2, e2, i2) {
            const o2 = 1 / It(i2, 1, e2.transform.tileZoom), a2 = Math.pow(2, i2.tileID.overscaledZ), s2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / a2, r2 = s2 * (i2.tileID.canonical.x + i2.tileID.wrap * a2), n2 = s2 * i2.tileID.canonical.y;
            return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
          }
          const _e = (e2, i2, o2, a2) => {
            const s2 = i2.style.light, r2 = s2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l2 = function() {
              var e3 = new t.ARRAY_TYPE(9);
              return t.ARRAY_TYPE != Float32Array && (e3[1] = 0, e3[2] = 0, e3[3] = 0, e3[5] = 0, e3[6] = 0, e3[7] = 0), e3[0] = 1, e3[4] = 1, e3[8] = 1, e3;
            }();
            s2.properties.get("anchor") === "viewport" && function(t2, e3) {
              var i3 = Math.sin(e3), o3 = Math.cos(e3);
              t2[0] = o3, t2[1] = i3, t2[2] = 0, t2[3] = -i3, t2[4] = o3, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1;
            }(l2, -i2.transform.angle), function(t2, e3, i3) {
              var o3 = e3[0], a3 = e3[1], s3 = e3[2];
              t2[0] = o3 * i3[0] + a3 * i3[3] + s3 * i3[6], t2[1] = o3 * i3[1] + a3 * i3[4] + s3 * i3[7], t2[2] = o3 * i3[2] + a3 * i3[5] + s3 * i3[8];
            }(n2, n2, l2);
            const c2 = s2.properties.get("color");
            return { u_matrix: e2, u_lightpos: n2, u_lightintensity: s2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: a2 };
          }, me = (e2, i2, o2, a2, s2, r2, n2) => t.extend(_e(e2, i2, o2, a2), de(r2, i2, n2), { u_height_factor: -Math.pow(2, s2.overscaledZ) / n2.tileSize / 8 }), pe = (t2) => ({ u_matrix: t2 }), fe = (e2, i2, o2, a2) => t.extend(pe(e2), de(o2, i2, a2)), ge = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), xe = (e2, i2, o2, a2, s2) => t.extend(fe(e2, i2, o2, a2), { u_world: s2 }), ve = (t2, e2, i2, o2) => {
            const a2 = t2.transform;
            let s2, r2;
            if (o2.paint.get("circle-pitch-alignment") === "map") {
              const t3 = It(i2, 1, a2.zoom);
              s2 = true, r2 = [t3, t3];
            } else
              s2 = false, r2 = a2.pixelsToGLUnits;
            return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_scale_with_map: +(o2.paint.get("circle-pitch-scale") === "map"), u_matrix: t2.translatePosMatrix(e2.posMatrix, i2, o2.paint.get("circle-translate"), o2.paint.get("circle-translate-anchor")), u_pitch_with_map: +s2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: r2 };
          }, ye = (t2, e2, i2) => {
            const o2 = It(i2, 1, e2.zoom), a2 = Math.pow(2, e2.zoom - i2.tileID.overscaledZ), s2 = i2.tileID.overscaleFactor();
            return { u_matrix: t2, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (o2 * a2), e2.pixelsToGLUnits[1] / (o2 * a2)], u_overscale_factor: s2 };
          }, be = (t2, e2, i2 = 1) => ({ u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 }), we = (t2) => ({ u_matrix: t2 }), Te = (t2, e2, i2, o2) => ({ u_matrix: t2, u_extrude_scale: It(e2, 1, i2), u_intensity: o2 });
          function Ee(e2, i2) {
            const o2 = Math.pow(2, i2.canonical.z), a2 = i2.canonical.y;
            return [new t.MercatorCoordinate(0, a2 / o2).toLngLat().lat, new t.MercatorCoordinate(0, (a2 + 1) / o2).toLngLat().lat];
          }
          const Ie = (t2, e2, i2, o2) => {
            const a2 = t2.transform;
            return { u_matrix: Pe(t2, e2, i2, o2), u_ratio: 1 / It(e2, 1, a2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
          }, Se = (e2, i2, o2, a2, s2) => t.extend(Ie(e2, i2, o2, s2), { u_image: 0, u_image_height: a2 }), Ce = (t2, e2, i2, o2, a2) => {
            const s2 = t2.transform, r2 = ze(e2, s2);
            return { u_matrix: Pe(t2, e2, i2, a2), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / It(e2, 1, s2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [r2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
          }, De = (e2, i2, o2, a2, s2, r2) => {
            const n2 = e2.lineAtlas, l2 = ze(i2, e2.transform), c2 = o2.layout.get("line-cap") === "round", h2 = n2.getDash(a2.from, c2), u2 = n2.getDash(a2.to, c2), d2 = h2.width * s2.fromScale, _2 = u2.width * s2.toScale;
            return t.extend(Ie(e2, i2, o2, r2), { u_patternscale_a: [l2 / d2, -h2.height / 2], u_patternscale_b: [l2 / _2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: h2.y, u_tex_y_b: u2.y, u_mix: s2.t });
          };
          function ze(t2, e2) {
            return 1 / It(t2, 1, e2.tileZoom);
          }
          function Pe(t2, e2, i2, o2) {
            return t2.translatePosMatrix(o2 ? o2.posMatrix : e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
          }
          const Ae = (t2, e2, i2, o2, a2) => {
            return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = a2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (s2 = a2.paint.get("raster-contrast"), s2 > 0 ? 1 / (1 - s2) : 1 + s2), u_spin_weights: Me(a2.paint.get("raster-hue-rotate")) };
            var s2, r2;
          };
          function Me(t2) {
            t2 *= Math.PI / 180;
            const e2 = Math.sin(t2), i2 = Math.cos(t2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
          }
          const Re = (t2, e2, i2, o2, a2, s2, r2, n2, l2, c2) => {
            const h2 = a2.transform;
            return { u_is_size_zoom_constant: +(t2 === "constant" || t2 === "source"), u_is_size_feature_constant: +(t2 === "constant" || t2 === "camera"), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: h2.width / h2.height, u_fade_change: a2.options.fadeDuration ? a2.symbolFadeChange : 1, u_matrix: s2, u_label_plane_matrix: r2, u_coord_matrix: n2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
          }, Le = (e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2) => {
            const d2 = s2.transform;
            return t.extend(Re(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2), { u_gamma_scale: a2 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: s2.pixelRatio, u_is_halo: +u2 });
          }, ke = (e2, i2, o2, a2, s2, r2, n2, l2, c2, h2) => t.extend(Le(e2, i2, o2, a2, s2, r2, n2, l2, true, c2, true), { u_texsize_icon: h2, u_texture_icon: 1 }), Be = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), Fe = (e2, i2, o2, a2, s2, r2) => t.extend(function(t2, e3, i3, o3) {
            const a3 = i3.imageManager.getPattern(t2.from.toString()), s3 = i3.imageManager.getPattern(t2.to.toString()), { width: r3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, h2 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), u2 = c2 * o3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: s3.tl, u_pattern_br_b: s3.br, u_texsize: [r3, n2], u_mix: e3.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: s3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / It(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u2] };
          }(a2, r2, o2, s2), { u_matrix: e2, u_opacity: i2 }), Oe = { fillExtrusion: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), fillExtrusionPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i2.u_height_factor), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), fill: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), fillPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), fillOutline: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world) }), fillOutlinePattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e2, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), collisionBox: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e2, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e2, i2.u_overscale_factor) }), collisionCircle: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e2, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.UniformColor(e2, i2.u_color), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_overlay: new t.Uniform1i(e2, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e2, i2.u_overlay_scale) }), clippingMask: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), heatmap: (e2, i2) => ({ u_extrude_scale: new t.Uniform1f(e2, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), heatmapTexture: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_latrange: new t.Uniform2f(e2, i2.u_latrange), u_light: new t.Uniform2f(e2, i2.u_light), u_shadow: new t.UniformColor(e2, i2.u_shadow), u_highlight: new t.UniformColor(e2, i2.u_highlight), u_accent: new t.UniformColor(e2, i2.u_accent) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_dimension: new t.Uniform2f(e2, i2.u_dimension), u_zoom: new t.Uniform1f(e2, i2.u_zoom), u_unpack: new t.Uniform4f(e2, i2.u_unpack) }), line: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image), u_image_height: new t.Uniform1f(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i2.u_image), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e2, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e2, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e2, i2.u_sdfgamma), u_image: new t.Uniform1i(e2, i2.u_image), u_tex_y_a: new t.Uniform1f(e2, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e2, i2.u_tex_y_b), u_mix: new t.Uniform1f(e2, i2.u_mix) }), raster: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_tl_parent: new t.Uniform2f(e2, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i2.u_fade_t), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image0: new t.Uniform1i(e2, i2.u_image0), u_image1: new t.Uniform1i(e2, i2.u_image1), u_brightness_low: new t.Uniform1f(e2, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i2.u_spin_weights) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i2.u_texsize_icon), u_texture: new t.Uniform1i(e2, i2.u_texture), u_texture_icon: new t.Uniform1i(e2, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) }), background: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_color: new t.UniformColor(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image: new t.Uniform1i(e2, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_mix: new t.Uniform1f(e2, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i2.u_scale_a), u_scale_b: new t.Uniform1f(e2, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i2.u_tile_units_to_pixels) }), terrain: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texture: new t.Uniform1i(e2, i2.u_texture) }), terrainDepth: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), terrainCoords: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texture: new t.Uniform1i(e2, i2.u_texture), u_terrain_coords_id: new t.Uniform1f(e2, i2.u_terrain_coords_id) }) };
          class Ue {
            constructor(t2, e2, i2) {
              this.context = t2;
              const o2 = t2.gl;
              this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t2) {
              const e2 = this.context.gl;
              this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const Ne = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class Ge {
            constructor(t2, e2, i2, o2) {
              this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
              const a2 = t2.gl;
              this.buffer = a2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t2) {
              const e2 = this.context.gl;
              this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
            }
            enableAttributes(t2, e2) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const o2 = e2.attributes[this.attributes[i2].name];
                o2 !== void 0 && t2.enableVertexAttribArray(o2);
              }
            }
            setVertexAttribPointers(t2, e2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const a2 = this.attributes[o2], s2 = e2.attributes[a2.name];
                s2 !== void 0 && t2.vertexAttribPointer(s2, a2.components, t2[Ne[a2.type]], false, this.itemSize, a2.offset + this.itemSize * (i2 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class Ze {
            constructor(t2) {
              this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(t2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class qe extends Ze {
            getDefault() {
              return t.Color.transparent;
            }
            set(t2) {
              const e2 = this.current;
              (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }
          }
          class Ve extends Ze {
            getDefault() {
              return 1;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
            }
          }
          class je extends Ze {
            getDefault() {
              return 0;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
            }
          }
          class Xe extends Ze {
            getDefault() {
              return [true, true, true, true];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
            }
          }
          class $e extends Ze {
            getDefault() {
              return true;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
            }
          }
          class We extends Ze {
            getDefault() {
              return 255;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
            }
          }
          class He extends Ze {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(t2) {
              const e2 = this.current;
              (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
            }
          }
          class Ke extends Ze {
            getDefault() {
              const t2 = this.gl;
              return [t2.KEEP, t2.KEEP, t2.KEEP];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
            }
          }
          class Ye extends Ze {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = false;
            }
          }
          class Je extends Ze {
            getDefault() {
              return [0, 1];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
            }
          }
          class Qe extends Ze {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = false;
            }
          }
          class ti extends Ze {
            getDefault() {
              return this.gl.LESS;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
            }
          }
          class ei extends Ze {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = false;
            }
          }
          class ii extends Ze {
            getDefault() {
              const t2 = this.gl;
              return [t2.ONE, t2.ZERO];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
            }
          }
          class oi extends Ze {
            getDefault() {
              return t.Color.transparent;
            }
            set(t2) {
              const e2 = this.current;
              (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }
          }
          class ai extends Ze {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
            }
          }
          class si extends Ze {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = false;
            }
          }
          class ri extends Ze {
            getDefault() {
              return this.gl.BACK;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
            }
          }
          class ni extends Ze {
            getDefault() {
              return this.gl.CCW;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
            }
          }
          class li extends Ze {
            getDefault() {
              return null;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
            }
          }
          class ci extends Ze {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
            }
          }
          class hi extends Ze {
            getDefault() {
              const t2 = this.gl;
              return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
            }
          }
          class ui extends Ze {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class di extends Ze {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class _i extends Ze {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
            }
          }
          class mi extends Ze {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class pi extends Ze {
            getDefault() {
              return null;
            }
            set(t2) {
              const e2 = this.gl;
              e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class fi extends Ze {
            constructor(t2) {
              super(t2), this.vao = t2.extVertexArrayObject;
            }
            getDefault() {
              return null;
            }
            set(t2) {
              this.vao && (t2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t2), this.current = t2, this.dirty = false);
            }
          }
          class gi extends Ze {
            getDefault() {
              return 4;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
            }
          }
          class xi extends Ze {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
            }
          }
          class vi extends Ze {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
            }
          }
          class yi extends Ze {
            constructor(t2, e2) {
              super(t2), this.context = t2, this.parent = e2;
            }
            getDefault() {
              return null;
            }
          }
          class bi extends yi {
            setDirty() {
              this.dirty = true;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e2 = this.gl;
              e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
            }
          }
          class wi extends yi {
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e2 = this.gl;
              e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class Ti {
            constructor(t2, e2, i2, o2) {
              this.context = t2, this.width = e2, this.height = i2;
              const a2 = this.framebuffer = t2.gl.createFramebuffer();
              this.colorAttachment = new bi(t2, a2), o2 && (this.depthAttachment = new wi(t2, a2));
            }
            destroy() {
              const t2 = this.context.gl, e2 = this.colorAttachment.get();
              if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
                const e3 = this.depthAttachment.get();
                e3 && t2.deleteRenderbuffer(e3);
              }
              t2.deleteFramebuffer(this.framebuffer);
            }
          }
          class Ei {
            constructor(t2, e2, i2) {
              this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
            }
          }
          Ei.Replace = [1, 0], Ei.disabled = new Ei(Ei.Replace, t.Color.transparent, [false, false, false, false]), Ei.unblended = new Ei(Ei.Replace, t.Color.transparent, [true, true, true, true]), Ei.alphaBlended = new Ei([1, 771], t.Color.transparent, [true, true, true, true]);
          class Ii {
            constructor(t2) {
              this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new qe(this), this.clearDepth = new Ve(this), this.clearStencil = new je(this), this.colorMask = new Xe(this), this.depthMask = new $e(this), this.stencilMask = new We(this), this.stencilFunc = new He(this), this.stencilOp = new Ke(this), this.stencilTest = new Ye(this), this.depthRange = new Je(this), this.depthTest = new Qe(this), this.depthFunc = new ti(this), this.blend = new ei(this), this.blendFunc = new ii(this), this.blendColor = new oi(this), this.blendEquation = new ai(this), this.cullFace = new si(this), this.cullFaceSide = new ri(this), this.frontFace = new ni(this), this.program = new li(this), this.activeTexture = new ci(this), this.viewport = new hi(this), this.bindFramebuffer = new ui(this), this.bindRenderbuffer = new di(this), this.bindTexture = new _i(this), this.bindVertexBuffer = new mi(this), this.bindElementBuffer = new pi(this), this.bindVertexArrayOES = this.extVertexArrayObject && new fi(this), this.pixelStoreUnpack = new gi(this), this.pixelStoreUnpackPremultiplyAlpha = new xi(this), this.pixelStoreUnpackFlipY = new vi(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(t2, e2) {
              return new Ue(this, t2, e2);
            }
            createVertexBuffer(t2, e2, i2) {
              return new Ge(this, t2, e2, i2);
            }
            createRenderbuffer(t2, e2, i2) {
              const o2 = this.gl, a2 = o2.createRenderbuffer();
              return this.bindRenderbuffer.set(a2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), a2;
            }
            createFramebuffer(t2, e2, i2) {
              return new Ti(this, t2, e2, i2);
            }
            clear({ color: t2, depth: e2 }) {
              const i2 = this.gl;
              let o2 = 0;
              t2 && (o2 |= i2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), e2 !== void 0 && (o2 |= i2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), i2.clear(o2);
            }
            setCullFace(t2) {
              t2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
            }
            setDepthMode(t2) {
              t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
            }
            setStencilMode(t2) {
              t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(t2) {
              a(t2.blendFunction, Ei.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
            }
            unbindVAO() {
              this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
          }
          class Si {
            constructor(t2, e2, i2) {
              this.func = t2, this.mask = e2, this.range = i2;
            }
          }
          Si.ReadOnly = false, Si.ReadWrite = true, Si.disabled = new Si(519, Si.ReadOnly, [0, 1]);
          const Ci = 7680;
          class Di {
            constructor(t2, e2, i2, o2, a2, s2) {
              this.test = t2, this.ref = e2, this.mask = i2, this.fail = o2, this.depthFail = a2, this.pass = s2;
            }
          }
          Di.disabled = new Di({ func: 519, mask: 0 }, 0, 0, Ci, Ci, Ci);
          class zi {
            constructor(t2, e2, i2) {
              this.enable = t2, this.mode = e2, this.frontFace = i2;
            }
          }
          let Pi;
          function Ai(e2, i2, o2, a2, s2, r2, n2) {
            const l2 = e2.context, c2 = l2.gl, h2 = e2.useProgram("collisionBox"), u2 = [];
            let d2 = 0, _2 = 0;
            for (let m3 = 0; m3 < a2.length; m3++) {
              const p3 = a2[m3], f3 = i2.getTile(p3), g3 = f3.getBucket(o2);
              if (!g3)
                continue;
              let x3 = p3.posMatrix;
              s2[0] === 0 && s2[1] === 0 || (x3 = e2.translatePosMatrix(p3.posMatrix, f3, s2, r2));
              const v3 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
              if (y2.length > 0) {
                const i3 = t.create(), o3 = x3;
                t.mul(i3, g3.placementInvProjMatrix, e2.transform.glCoordMatrix), t.mul(i3, i3, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: _2, transform: o3, invTransform: i3, coord: p3 }), d2 += y2.length / 4, _2 = d2;
              }
              v3 && h2.draw(l2, c2.LINES, Si.disabled, Di.disabled, e2.colorModeForRenderPass(), zi.disabled, ye(x3, e2.transform, f3), e2.style.terrain && e2.style.terrain.getTerrainData(p3), o2.id, v3.layoutVertexBuffer, v3.indexBuffer, v3.segments, null, e2.transform.zoom, null, null, v3.collisionVertexBuffer);
            }
            if (!n2 || !u2.length)
              return;
            const m2 = e2.useProgram("collisionCircle"), p2 = new t.CollisionCircleLayoutArray();
            p2.resize(4 * d2), p2._trim();
            let f2 = 0;
            for (const t2 of u2)
              for (let e3 = 0; e3 < t2.circleArray.length / 4; e3++) {
                const i3 = 4 * e3, o3 = t2.circleArray[i3 + 0], a3 = t2.circleArray[i3 + 1], s3 = t2.circleArray[i3 + 2], r3 = t2.circleArray[i3 + 3];
                p2.emplace(f2++, o3, a3, s3, r3, 0), p2.emplace(f2++, o3, a3, s3, r3, 1), p2.emplace(f2++, o3, a3, s3, r3, 2), p2.emplace(f2++, o3, a3, s3, r3, 3);
              }
            (!Pi || Pi.length < 2 * d2) && (Pi = function(e3) {
              const i3 = 2 * e3, o3 = new t.QuadTriangleArray();
              o3.resize(i3), o3._trim();
              for (let t2 = 0; t2 < i3; t2++) {
                const e4 = 6 * t2;
                o3.uint16[e4 + 0] = 4 * t2 + 0, o3.uint16[e4 + 1] = 4 * t2 + 1, o3.uint16[e4 + 2] = 4 * t2 + 2, o3.uint16[e4 + 3] = 4 * t2 + 2, o3.uint16[e4 + 4] = 4 * t2 + 3, o3.uint16[e4 + 5] = 4 * t2 + 0;
              }
              return o3;
            }(d2));
            const g2 = l2.createIndexBuffer(Pi, true), x2 = l2.createVertexBuffer(p2, t.collisionCircleLayout.members, true);
            for (const i3 of u2) {
              const a3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (v2 = e2.transform).cameraToCenterDistance, u_viewport_size: [v2.width, v2.height] };
              m2.draw(l2, c2.TRIANGLES, Si.disabled, Di.disabled, e2.colorModeForRenderPass(), zi.disabled, a3, e2.style.terrain && e2.style.terrain.getTerrainData(i3.coord), o2.id, x2, g2, t.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
            }
            var v2;
            x2.destroy(), g2.destroy();
          }
          zi.disabled = new zi(false, 1029, 2305), zi.backCCW = new zi(true, 1029, 2305);
          const Mi = t.identity(new Float32Array(16));
          function Ri(e2, i2, o2, a2, s2, r2) {
            const { horizontalAlign: n2, verticalAlign: l2 } = t.getAnchorAlignment(e2), c2 = -(n2 - 0.5) * i2, h2 = -(l2 - 0.5) * o2, u2 = t.evaluateVariableOffset(e2, a2);
            return new t.pointGeometry((c2 / s2 + u2[0]) * r2, (h2 / s2 + u2[1]) * r2);
          }
          function Li(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2) {
            const d2 = e2.text.placedSymbolArray, _2 = e2.text.dynamicLayoutVertexArray, m2 = e2.icon.dynamicLayoutVertexArray, p2 = {};
            _2.clear();
            for (let m3 = 0; m3 < d2.length; m3++) {
              const f2 = d2.get(m3), g2 = e2.allowVerticalPlacement && !f2.placedOrientation, x2 = f2.hidden || !f2.crossTileID || g2 ? null : a2[f2.crossTileID];
              if (x2) {
                const a3 = new t.pointGeometry(f2.anchorX, f2.anchorY), d3 = ut(a3, o2 ? n2 : r2, u2), m4 = dt(s2.cameraToCenterDistance, d3.signedDistanceFromCamera);
                let g3 = t.evaluateSizeForFeature(e2.textSizeData, c2, f2) * m4 / t.ONE_EM;
                o2 && (g3 *= e2.tilePixelRatio / l2);
                const { width: v2, height: y2, anchor: b2, textOffset: w2, textBoxScale: T2 } = x2, E2 = Ri(b2, v2, y2, w2, T2, g3), I2 = o2 ? ut(a3.add(E2), r2, u2).point : d3.point.add(i2 ? E2.rotate(-s2.angle) : E2), S2 = e2.allowVerticalPlacement && f2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
                for (let e3 = 0; e3 < f2.numGlyphs; e3++)
                  t.addDynamicAttributes(_2, I2, S2);
                h2 && f2.associatedIconIndex >= 0 && (p2[f2.associatedIconIndex] = { shiftedAnchor: I2, angle: S2 });
              } else
                bt(f2.numGlyphs, _2);
            }
            if (h2) {
              m2.clear();
              const i3 = e2.icon.placedSymbolArray;
              for (let e3 = 0; e3 < i3.length; e3++) {
                const o3 = i3.get(e3);
                if (o3.hidden)
                  bt(o3.numGlyphs, m2);
                else {
                  const i4 = p2[e3];
                  if (i4)
                    for (let e4 = 0; e4 < o3.numGlyphs; e4++)
                      t.addDynamicAttributes(m2, i4.shiftedAnchor, i4.angle);
                  else
                    bt(o3.numGlyphs, m2);
                }
              }
              e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
            }
            e2.text.dynamicLayoutVertexBuffer.updateData(_2);
          }
          function ki(t2, e2, i2) {
            return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
          }
          function Bi(e2, i2, o2, a2, s2, r2, n2, l2, c2, h2, u2, d2) {
            const _2 = e2.context, m2 = _2.gl, p2 = e2.transform, f2 = l2 === "map", g2 = c2 === "map", x2 = l2 !== "viewport" && o2.layout.get("symbol-placement") !== "point", v2 = f2 && !g2 && !x2, y2 = !o2.layout.get("symbol-sort-key").isConstant();
            let b2 = false;
            const w2 = e2.depthModeForSublayer(0, Si.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [];
            for (const l3 of a2) {
              const a3 = i2.getTile(l3), c3 = a3.getBucket(o2);
              if (!c3)
                continue;
              const u3 = s2 ? c3.text : c3.icon;
              if (!u3 || !u3.segments.get().length)
                continue;
              const d3 = u3.programConfigurations.get(o2.id), _3 = s2 || c3.sdfIcons, w3 = s2 ? c3.textSizeData : c3.iconSizeData, I2 = g2 || p2.pitch !== 0, S2 = e2.useProgram(ki(_3, s2, c3), d3), C2 = t.evaluateSizeForZoom(w3, p2.zoom), D2 = e2.style.terrain && e2.style.terrain.getTerrainData(l3);
              let z2, P2, A2, M2, R2 = [0, 0], L2 = null;
              if (s2) {
                if (P2 = a3.glyphAtlasTexture, A2 = m2.LINEAR, z2 = a3.glyphAtlasTexture.size, c3.iconsInText) {
                  R2 = a3.imageAtlasTexture.size, L2 = a3.imageAtlasTexture;
                  const t2 = w3.kind === "composite" || w3.kind === "camera";
                  M2 = I2 || e2.options.rotating || e2.options.zooming || t2 ? m2.LINEAR : m2.NEAREST;
                }
              } else {
                const t2 = o2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
                P2 = a3.imageAtlasTexture, A2 = _3 || e2.options.rotating || e2.options.zooming || t2 || I2 ? m2.LINEAR : m2.NEAREST, z2 = a3.imageAtlasTexture.size;
              }
              const k2 = It(a3, 1, e2.transform.zoom), B2 = ct(l3.posMatrix, g2, f2, e2.transform, k2), F2 = ht(l3.posMatrix, g2, f2, e2.transform, k2), O2 = T2 && c3.hasTextData(), U2 = o2.layout.get("icon-text-fit") !== "none" && O2 && c3.hasIconData();
              if (x2) {
                const t2 = e2.style.terrain ? (t3, i4) => e2.style.terrain.getElevation(l3, t3, i4) : null, i3 = o2.layout.get("text-rotation-alignment") === "map";
                mt(c3, l3.posMatrix, e2, s2, B2, F2, g2, h2, i3, t2);
              }
              const N2 = e2.translatePosMatrix(l3.posMatrix, a3, r2, n2), G2 = x2 || s2 && T2 || U2 ? Mi : B2, Z2 = e2.translatePosMatrix(F2, a3, r2, n2, true), q2 = _3 && o2.paint.get(s2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
              let V2;
              V2 = _3 ? c3.iconsInText ? ke(w3.kind, C2, v2, g2, e2, N2, G2, Z2, z2, R2) : Le(w3.kind, C2, v2, g2, e2, N2, G2, Z2, s2, z2, true) : Re(w3.kind, C2, v2, g2, e2, N2, G2, Z2, s2, z2);
              const j2 = { program: S2, buffers: u3, uniformValues: V2, atlasTexture: P2, atlasTextureIcon: L2, atlasInterpolation: A2, atlasInterpolationIcon: M2, isSDF: _3, hasHalo: q2 };
              if (y2 && c3.canOverlap) {
                b2 = true;
                const e3 = u3.segments.get();
                for (const i3 of e3)
                  E2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: j2, terrainData: D2 });
              } else
                E2.push({ segments: u3.segments, sortKey: 0, state: j2, terrainData: D2 });
            }
            b2 && E2.sort((t2, e3) => t2.sortKey - e3.sortKey);
            for (const t2 of E2) {
              const i3 = t2.state;
              if (_2.activeTexture.set(m2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, m2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(m2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, m2.CLAMP_TO_EDGE)), i3.isSDF) {
                const a3 = i3.uniformValues;
                i3.hasHalo && (a3.u_is_halo = 1, Fi(i3.buffers, t2.segments, o2, e2, i3.program, w2, u2, d2, a3, t2.terrainData)), a3.u_is_halo = 0;
              }
              Fi(i3.buffers, t2.segments, o2, e2, i3.program, w2, u2, d2, i3.uniformValues, t2.terrainData);
            }
          }
          function Fi(t2, e2, i2, o2, a2, s2, r2, n2, l2, c2) {
            const h2 = o2.context;
            a2.draw(h2, h2.gl.TRIANGLES, s2, r2, n2, zi.disabled, l2, c2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
          }
          function Oi(t2, e2, i2, o2, a2, s2, r2) {
            const n2 = t2.context.gl, l2 = i2.paint.get("fill-pattern"), c2 = l2 && l2.constantOr(1), h2 = i2.getCrossfadeParameters();
            let u2, d2, _2, m2, p2;
            r2 ? (d2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = n2.LINES) : (d2 = c2 ? "fillPattern" : "fill", u2 = n2.TRIANGLES);
            for (const f2 of o2) {
              const o3 = e2.getTile(f2);
              if (c2 && !o3.patternsLoaded())
                continue;
              const g2 = o3.getBucket(i2);
              if (!g2)
                continue;
              const x2 = g2.programConfigurations.get(i2.id), v2 = t2.useProgram(d2, x2), y2 = t2.style.terrain && t2.style.terrain.getTerrainData(f2);
              c2 && (t2.context.activeTexture.set(n2.TEXTURE0), o3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(h2));
              const b2 = l2.constantOr(null);
              if (b2 && o3.imageAtlas) {
                const t3 = o3.imageAtlas, e3 = t3.patternPositions[b2.to.toString()], i3 = t3.patternPositions[b2.from.toString()];
                e3 && i3 && x2.setConstantPatternPositions(e3, i3);
              }
              const w2 = y2 ? f2 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : f2.posMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
              if (r2) {
                m2 = g2.indexBuffer2, p2 = g2.segments2;
                const e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
                _2 = d2 === "fillOutlinePattern" && c2 ? xe(T2, t2, h2, o3, e3) : ge(T2, e3);
              } else
                m2 = g2.indexBuffer, p2 = g2.segments, _2 = c2 ? fe(T2, t2, h2, o3) : pe(T2);
              v2.draw(t2.context, u2, a2, t2.stencilModeForClipping(f2), s2, zi.disabled, _2, y2, i2.id, g2.layoutVertexBuffer, m2, p2, i2.paint, t2.transform.zoom, x2);
            }
          }
          function Ui(t2, e2, i2, o2, a2, s2, r2) {
            const n2 = t2.context, l2 = n2.gl, c2 = i2.paint.get("fill-extrusion-pattern"), h2 = c2.constantOr(1), u2 = i2.getCrossfadeParameters(), d2 = i2.paint.get("fill-extrusion-opacity");
            for (const _2 of o2) {
              const o3 = e2.getTile(_2), m2 = o3.getBucket(i2);
              if (!m2)
                continue;
              const p2 = t2.style.terrain && t2.style.terrain.getTerrainData(_2), f2 = m2.programConfigurations.get(i2.id), g2 = t2.useProgram(h2 ? "fillExtrusionPattern" : "fillExtrusion", f2);
              h2 && (t2.context.activeTexture.set(l2.TEXTURE0), o3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), f2.updatePaintBuffers(u2));
              const x2 = c2.constantOr(null);
              if (x2 && o3.imageAtlas) {
                const t3 = o3.imageAtlas, e3 = t3.patternPositions[x2.to.toString()], i3 = t3.patternPositions[x2.from.toString()];
                e3 && i3 && f2.setConstantPatternPositions(e3, i3);
              }
              const v2 = t2.translatePosMatrix(_2.posMatrix, o3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y2 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = h2 ? me(v2, t2, y2, d2, _2, u2, o3) : _e(v2, t2, y2, d2);
              g2.draw(n2, n2.gl.TRIANGLES, a2, s2, r2, zi.backCCW, b2, p2, i2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i2.paint, t2.transform.zoom, f2, t2.style.terrain && m2.centroidVertexBuffer);
            }
          }
          function Ni(t2, e2, i2, o2, a2, s2, r2) {
            const n2 = t2.context, l2 = n2.gl, c2 = i2.fbo;
            if (!c2)
              return;
            const h2 = t2.useProgram("hillshade"), u2 = t2.style.terrain && t2.style.terrain.getTerrainData(e2);
            n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c2.colorAttachment.get()), h2.draw(n2, l2.TRIANGLES, a2, s2, r2, zi.disabled, ((t3, e3, i3, o3) => {
              const a3 = i3.paint.get("hillshade-shadow-color"), s3 = i3.paint.get("hillshade-highlight-color"), r3 = i3.paint.get("hillshade-accent-color");
              let n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              i3.paint.get("hillshade-illumination-anchor") === "viewport" && (n3 -= t3.transform.angle);
              const l3 = !t3.options.moving;
              return { u_matrix: o3 ? o3.posMatrix : t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Ee(0, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: a3, u_highlight: s3, u_accent: r3 };
            })(t2, i2, o2, u2 ? e2 : null), u2, o2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
          }
          function Gi(e2, i2, o2, a2, s2, r2) {
            const n2 = e2.context, l2 = n2.gl, c2 = i2.dem;
            if (c2 && c2.data) {
              const h2 = c2.dim, u2 = c2.stride, _2 = c2.getPixels();
              if (n2.activeTexture.set(l2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e2.getTileTexture(u2), i2.demTexture) {
                const t2 = i2.demTexture;
                t2.update(_2, { premultiply: false }), t2.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
              } else
                i2.demTexture = new d(n2, _2, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
              n2.activeTexture.set(l2.TEXTURE0);
              let m2 = i2.fbo;
              if (!m2) {
                const t2 = new d(n2, { width: h2, height: h2, data: null }, l2.RGBA);
                t2.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), m2 = i2.fbo = n2.createFramebuffer(h2, h2, true), m2.colorAttachment.set(t2.texture);
              }
              n2.bindFramebuffer.set(m2.framebuffer), n2.viewport.set([0, 0, h2, h2]), e2.useProgram("hillshadePrepare").draw(n2, l2.TRIANGLES, a2, s2, r2, zi.disabled, ((e3, i3) => {
                const o3 = i3.stride, a3 = t.create();
                return t.ortho(a3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(a3, a3, [0, -t.EXTENT, 0]), { u_matrix: a3, u_image: 1, u_dimension: [o3, o3], u_zoom: e3.overscaledZ, u_unpack: i3.getUnpackVector() };
              })(i2.tileID, c2), null, o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
            }
          }
          function Zi(e2, i2, o2, a2, s2, r2) {
            const n2 = a2.paint.get("raster-fade-duration");
            if (!r2 && n2 > 0) {
              const a3 = t.exported.now(), r3 = (a3 - e2.timeAdded) / n2, l2 = i2 ? (a3 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h2 = s2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e2.tileID.overscaledZ - h2), d2 = u2 && e2.refreshedUponExpiration ? 1 : t.clamp(u2 ? r3 : 1 - l2, 0, 1);
              return e2.refreshedUponExpiration && r3 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          const qi = new t.Color(1, 0, 0, 1), Vi = new t.Color(0, 1, 0, 1), ji = new t.Color(0, 0, 1, 1), Xi = new t.Color(1, 0, 1, 1), $i = new t.Color(0, 1, 1, 1);
          function Wi(t2, e2, i2, o2) {
            Ki(t2, 0, e2 + i2 / 2, t2.transform.width, i2, o2);
          }
          function Hi(t2, e2, i2, o2) {
            Ki(t2, e2 - i2 / 2, 0, i2, t2.transform.height, o2);
          }
          function Ki(t2, e2, i2, o2, a2, s2) {
            const r2 = t2.context, n2 = r2.gl;
            n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t2.pixelRatio, i2 * t2.pixelRatio, o2 * t2.pixelRatio, a2 * t2.pixelRatio), r2.clear({ color: s2 }), n2.disable(n2.SCISSOR_TEST);
          }
          function Yi(e2, i2, o2) {
            const a2 = e2.context, s2 = a2.gl, r2 = o2.posMatrix, n2 = e2.useProgram("debug"), l2 = Si.disabled, c2 = Di.disabled, h2 = e2.colorModeForRenderPass(), u2 = "$debug", d2 = e2.style.terrain && e2.style.terrain.getTerrainData(o2);
            a2.activeTexture.set(s2.TEXTURE0), e2.emptyTexture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
            const _2 = i2.getTileByID(o2.key).latestRawTileData, m2 = Math.floor((_2 && _2.byteLength || 0) / 1024), p2 = i2.getTile(o2).tileSize, f2 = 512 / Math.min(p2, 512) * (o2.overscaledZ / e2.transform.zoom) * 0.5;
            let g2 = o2.canonical.toString();
            o2.overscaledZ !== o2.canonical.z && (g2 += ` => ${o2.overscaledZ}`), function(t2, e3) {
              t2.initDebugOverlayCanvas();
              const i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, a3 = t2.debugOverlayCanvas.getContext("2d");
              a3.clearRect(0, 0, i3.width, i3.height), a3.shadowColor = "white", a3.shadowBlur = 2, a3.lineWidth = 1.5, a3.strokeStyle = "white", a3.textBaseline = "top", a3.font = "bold 36px Open Sans, sans-serif", a3.fillText(e3, 5, 5), a3.strokeText(e3, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
            }(e2, `${g2} ${m2}kb`), n2.draw(a2, s2.TRIANGLES, l2, c2, Ei.alphaBlended, zi.disabled, be(r2, t.Color.transparent, f2), null, u2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), n2.draw(a2, s2.LINE_STRIP, l2, c2, h2, zi.disabled, be(r2, t.Color.red), d2, u2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
          }
          function Ji(t2, e2, i2) {
            const o2 = t2.context, a2 = o2.gl, s2 = t2.colorModeForRenderPass(), r2 = new Si(a2.LEQUAL, Si.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l2 = e2.getTerrainMesh(), c2 = e2.getTerrainData(i2.tileID);
            o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, t2.width, t2.height]), o2.activeTexture.set(a2.TEXTURE0), a2.bindTexture(a2.TEXTURE_2D, e2.getRTTFramebuffer().colorAttachment.get());
            const h2 = t2.transform.calculatePosMatrix(i2.tileID.toUnwrapped());
            n2.draw(o2, a2.TRIANGLES, r2, Di.disabled, s2, zi.backCCW, { u_matrix: h2, u_texture: 0 }, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
          }
          function Qi(t2, e2, i2, o2) {
            const a2 = t2.context, s2 = i2.tileSize * e2.qualityFactor;
            i2.textures[o2] || (i2.textures[o2] = t2.getTileTexture(s2) || new d(a2, { width: s2, height: s2, data: null }, a2.gl.RGBA), i2.textures[o2].bind(a2.gl.LINEAR, a2.gl.CLAMP_TO_EDGE), o2 === 0 && e2.sourceCache.renderHistory.push(i2.tileID.key));
            const r2 = e2.getRTTFramebuffer();
            r2.colorAttachment.set(i2.textures[o2].texture), a2.bindFramebuffer.set(r2.framebuffer), a2.viewport.set([0, 0, s2, s2]);
          }
          class to {
            constructor(t2) {
              this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this.painter = t2, this._renderToTexture = { background: true, fill: true, line: true, raster: true }, this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this._stacks = [], this._prevType = null, this._rerender = {}, this._renderableTiles = t2.style.terrain.sourceCache.getRenderableTiles(), this._init();
            }
            _init() {
              const t2 = this.painter.style, e2 = t2.terrain;
              for (const i2 in t2.sourceCaches) {
                this._coordsDescendingInv[i2] = {};
                const o2 = t2.sourceCaches[i2].getVisibleCoordinates();
                for (const t3 of o2) {
                  const o3 = e2.sourceCache.getTerrainCoords(t3);
                  for (const t4 in o3)
                    this._coordsDescendingInv[i2][t4] || (this._coordsDescendingInv[i2][t4] = []), this._coordsDescendingInv[i2][t4].push(o3[t4]);
                }
              }
              for (const e3 of t2._order) {
                const i2 = t2._layers[e3], o2 = i2.source;
                if (this._renderToTexture[i2.type] && !this._coordsDescendingInvStr[o2]) {
                  this._coordsDescendingInvStr[o2] = {};
                  for (const t3 in this._coordsDescendingInv[o2])
                    this._coordsDescendingInvStr[o2][t3] = this._coordsDescendingInv[o2][t3].map((t4) => t4.key).sort().join();
                }
              }
              return this._renderableTiles.forEach((t3) => {
                for (const i2 in this._coordsDescendingInvStr) {
                  const o2 = this._coordsDescendingInvStr[i2][t3.tileID.key];
                  o2 && o2 !== t3.textureCoords[i2] && t3.clearTextures(this.painter), e2.needsRerender(i2, t3.tileID) && t3.clearTextures(this.painter);
                }
                this._rerender[t3.tileID.key] = !t3.textures.length;
              }), e2.clearRerenderCache(), e2.sourceCache.removeOutdated(this.painter), this;
            }
            renderLayer(e2) {
              const i2 = e2.type, o2 = this.painter, a2 = o2.style._order, s2 = o2.currentLayer, r2 = s2 + 1 === a2.length;
              if (this._renderToTexture[i2] && (this._prevType && this._renderToTexture[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(a2[s2]), !r2))
                return true;
              if (this._renderToTexture[this._prevType] || i2 === "hillshade" || this._renderToTexture[i2] && r2) {
                this._prevType = i2;
                const r3 = this._stacks.length - 1, n2 = this._stacks[r3] || [];
                for (const e3 of this._renderableTiles) {
                  if (Qi(o2, o2.style.terrain, e3, r3), this._rerender[e3.tileID.key]) {
                    o2.context.clear({ color: t.Color.transparent });
                    for (let t2 = 0; t2 < n2.length; t2++) {
                      const i3 = o2.style._layers[n2[t2]], a3 = i3.source ? this._coordsDescendingInv[i3.source][e3.tileID.key] : [e3.tileID];
                      o2._renderTileClippingMasks(i3, a3), o2.renderLayer(o2, o2.style.sourceCaches[i3.source], i3, a3), i3.source && (e3.textureCoords[i3.source] = this._coordsDescendingInvStr[i3.source][e3.tileID.key]);
                    }
                  }
                  Ji(o2, o2.style.terrain, e3);
                }
                if (i2 === "hillshade") {
                  this._stacks.push([a2[s2]]);
                  for (const i3 of this._renderableTiles) {
                    const a3 = this._coordsDescendingInv[e2.source][i3.tileID.key];
                    Qi(o2, o2.style.terrain, i3, this._stacks.length - 1), o2.context.clear({ color: t.Color.transparent }), o2._renderTileClippingMasks(e2, a3), o2.renderLayer(o2, o2.style.sourceCaches[e2.source], e2, a3), Ji(o2, o2.style.terrain, i3);
                  }
                  return true;
                }
                return this._renderToTexture[i2];
              }
              return false;
            }
          }
          const eo = { symbol: function(e2, i2, o2, a2, s2) {
            if (e2.renderPass !== "translucent")
              return;
            const r2 = Di.disabled, n2 = e2.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(e3, i3, o3, a3, s3, r3, n3) {
              const l2 = i3.transform, c2 = s3 === "map", h2 = r3 === "map";
              for (const s4 of e3) {
                const e4 = a3.getTile(s4), r4 = e4.getBucket(o3);
                if (!r4 || !r4.text || !r4.text.segments.get().length)
                  continue;
                const u2 = t.evaluateSizeForZoom(r4.textSizeData, l2.zoom), d2 = It(e4, 1, i3.transform.zoom), _2 = ct(s4.posMatrix, h2, c2, i3.transform, d2), m2 = o3.layout.get("icon-text-fit") !== "none" && r4.hasIconData();
                if (u2) {
                  const t2 = Math.pow(2, l2.zoom - e4.tileID.overscaledZ);
                  Li(r4, c2, h2, n3, l2, _2, s4.posMatrix, t2, u2, m2, i3.style.terrain ? (t3, e5) => i3.style.terrain.getElevation(s4, t3, e5) : null);
                }
              }
            }(a2, e2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), s2), o2.paint.get("icon-opacity").constantOr(1) !== 0 && Bi(e2, i2, o2, a2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), r2, n2), o2.paint.get("text-opacity").constantOr(1) !== 0 && Bi(e2, i2, o2, a2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), r2, n2), i2.map.showCollisionBoxes && (Ai(e2, i2, o2, a2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Ai(e2, i2, o2, a2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }, circle: function(e2, i2, o2, a2) {
            if (e2.renderPass !== "translucent")
              return;
            const s2 = o2.paint.get("circle-opacity"), r2 = o2.paint.get("circle-stroke-width"), n2 = o2.paint.get("circle-stroke-opacity"), l2 = !o2.layout.get("circle-sort-key").isConstant();
            if (s2.constantOr(1) === 0 && (r2.constantOr(1) === 0 || n2.constantOr(1) === 0))
              return;
            const c2 = e2.context, h2 = c2.gl, u2 = e2.depthModeForSublayer(0, Si.ReadOnly), d2 = Di.disabled, _2 = e2.colorModeForRenderPass(), m2 = [];
            for (let s3 = 0; s3 < a2.length; s3++) {
              const r3 = a2[s3], n3 = i2.getTile(r3), c3 = n3.getBucket(o2);
              if (!c3)
                continue;
              const h3 = c3.programConfigurations.get(o2.id), u3 = e2.useProgram("circle", h3), d3 = c3.layoutVertexBuffer, _3 = c3.indexBuffer, p2 = e2.style.terrain && e2.style.terrain.getTerrainData(r3), f2 = { programConfiguration: h3, program: u3, layoutVertexBuffer: d3, indexBuffer: _3, uniformValues: ve(e2, r3, n3, o2), terrainData: p2 };
              if (l2) {
                const e3 = c3.segments.get();
                for (const i3 of e3)
                  m2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: f2 });
              } else
                m2.push({ segments: c3.segments, sortKey: 0, state: f2 });
            }
            l2 && m2.sort((t2, e3) => t2.sortKey - e3.sortKey);
            for (const t2 of m2) {
              const { programConfiguration: i3, program: a3, layoutVertexBuffer: s3, indexBuffer: r3, uniformValues: n3, terrainData: l3 } = t2.state;
              a3.draw(c2, h2.TRIANGLES, u2, d2, _2, zi.disabled, n3, l3, o2.id, s3, r3, t2.segments, o2.paint, e2.transform.zoom, i3);
            }
          }, heatmap: function(e2, i2, o2, a2) {
            if (o2.paint.get("heatmap-opacity") !== 0)
              if (e2.renderPass === "offscreen") {
                const s2 = e2.context, r2 = s2.gl, n2 = Di.disabled, l2 = new Ei([r2.ONE, r2.ONE], t.Color.transparent, [true, true, true, true]);
                !function(t2, e3, i3) {
                  const o3 = t2.gl;
                  t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
                  let a3 = i3.heatmapFbo;
                  if (a3)
                    o3.bindTexture(o3.TEXTURE_2D, a3.colorAttachment.get()), t2.bindFramebuffer.set(a3.framebuffer);
                  else {
                    const s3 = o3.createTexture();
                    o3.bindTexture(o3.TEXTURE_2D, s3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), a3 = i3.heatmapFbo = t2.createFramebuffer(e3.width / 4, e3.height / 4, false), function(t3, e4, i4, o4) {
                      const a4 = t3.gl;
                      a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, e4.width / 4, e4.height / 4, 0, a4.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                    }(t2, e3, s3, a3);
                  }
                }(s2, e2, o2), s2.clear({ color: t.Color.transparent });
                for (let t2 = 0; t2 < a2.length; t2++) {
                  const c2 = a2[t2];
                  if (i2.hasRenderableParent(c2))
                    continue;
                  const h2 = i2.getTile(c2), u2 = h2.getBucket(o2);
                  if (!u2)
                    continue;
                  const d2 = u2.programConfigurations.get(o2.id), _2 = e2.useProgram("heatmap", d2), { zoom: m2 } = e2.transform;
                  _2.draw(s2, r2.TRIANGLES, Si.disabled, n2, l2, zi.disabled, Te(c2.posMatrix, h2, m2, o2.paint.get("heatmap-intensity")), null, o2.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, o2.paint, e2.transform.zoom, d2);
                }
                s2.viewport.set([0, 0, e2.width, e2.height]);
              } else
                e2.renderPass === "translucent" && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i3) {
                  const o3 = e3.context, a3 = o3.gl, s2 = i3.heatmapFbo;
                  if (!s2)
                    return;
                  o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, s2.colorAttachment.get()), o3.activeTexture.set(a3.TEXTURE1);
                  let r2 = i3.colorRampTexture;
                  r2 || (r2 = i3.colorRampTexture = new d(o3, i3.colorRamp, a3.RGBA)), r2.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, a3.TRIANGLES, Si.disabled, Di.disabled, e3.colorModeForRenderPass(), zi.disabled, ((e4, i4, o4, a4) => {
                    const s3 = t.create();
                    t.ortho(s3, 0, e4.width, e4.height, 0, 0, 1);
                    const r3 = e4.context.gl;
                    return { u_matrix: s3, u_world: [r3.drawingBufferWidth, r3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i4.paint.get("heatmap-opacity") };
                  })(e3, i3), null, i3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i3.paint, e3.transform.zoom);
                }(e2, o2));
          }, line: function(e2, i2, o2, a2) {
            if (e2.renderPass !== "translucent")
              return;
            const s2 = o2.paint.get("line-opacity"), r2 = o2.paint.get("line-width");
            if (s2.constantOr(1) === 0 || r2.constantOr(1) === 0)
              return;
            const n2 = e2.depthModeForSublayer(0, Si.ReadOnly), l2 = e2.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), h2 = o2.paint.get("line-pattern"), u2 = h2.constantOr(1), _2 = o2.paint.get("line-gradient"), m2 = o2.getCrossfadeParameters(), p2 = u2 ? "linePattern" : c2 ? "lineSDF" : _2 ? "lineGradient" : "line", f2 = e2.context, g2 = f2.gl;
            let x2 = true;
            for (const s3 of a2) {
              const a3 = i2.getTile(s3);
              if (u2 && !a3.patternsLoaded())
                continue;
              const r3 = a3.getBucket(o2);
              if (!r3)
                continue;
              const v2 = r3.programConfigurations.get(o2.id), y2 = e2.context.program.get(), b2 = e2.useProgram(p2, v2), w2 = x2 || b2.program !== y2, T2 = e2.style.terrain && e2.style.terrain.getTerrainData(s3), E2 = h2.constantOr(null);
              if (E2 && a3.imageAtlas) {
                const t2 = a3.imageAtlas, e3 = t2.patternPositions[E2.to.toString()], i3 = t2.patternPositions[E2.from.toString()];
                e3 && i3 && v2.setConstantPatternPositions(e3, i3);
              }
              const I2 = T2 ? s3 : null, S2 = u2 ? Ce(e2, a3, o2, m2, I2) : c2 ? De(e2, a3, o2, c2, m2, I2) : _2 ? Se(e2, a3, o2, r3.lineClipsArray.length, I2) : Ie(e2, a3, o2, I2);
              if (u2)
                f2.activeTexture.set(g2.TEXTURE0), a3.imageAtlasTexture.bind(g2.LINEAR, g2.CLAMP_TO_EDGE), v2.updatePaintBuffers(m2);
              else if (c2 && (w2 || e2.lineAtlas.dirty))
                f2.activeTexture.set(g2.TEXTURE0), e2.lineAtlas.bind(f2);
              else if (_2) {
                const a4 = r3.gradients[o2.id];
                let n3 = a4.texture;
                if (o2.gradientVersion !== a4.version) {
                  let l3 = 256;
                  if (o2.stepInterpolant) {
                    const o3 = i2.getSource().maxzoom, a5 = s3.canonical.z === o3 ? Math.ceil(1 << e2.transform.maxZoom - s3.canonical.z) : 1;
                    l3 = t.clamp(t.nextPowerOfTwo(r3.maxLineLength / t.EXTENT * 1024 * a5), 256, f2.maxTextureSize);
                  }
                  a4.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: a4.gradient || void 0, clips: r3.lineClipsArray }), a4.texture ? a4.texture.update(a4.gradient) : a4.texture = new d(f2, a4.gradient, g2.RGBA), a4.version = o2.gradientVersion, n3 = a4.texture;
                }
                f2.activeTexture.set(g2.TEXTURE0), n3.bind(o2.stepInterpolant ? g2.NEAREST : g2.LINEAR, g2.CLAMP_TO_EDGE);
              }
              b2.draw(f2, g2.TRIANGLES, n2, e2.stencilModeForClipping(s3), l2, zi.disabled, S2, T2, o2.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, o2.paint, e2.transform.zoom, v2, r3.layoutVertexBuffer2), x2 = false;
            }
          }, fill: function(e2, i2, o2, a2) {
            const s2 = o2.paint.get("fill-color"), r2 = o2.paint.get("fill-opacity");
            if (r2.constantOr(1) === 0)
              return;
            const n2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && s2.constantOr(t.Color.transparent).a === 1 && r2.constantOr(0) === 1 ? "opaque" : "translucent";
            if (e2.renderPass === c2) {
              const t2 = e2.depthModeForSublayer(1, e2.renderPass === "opaque" ? Si.ReadWrite : Si.ReadOnly);
              Oi(e2, i2, o2, a2, t2, n2, false);
            }
            if (e2.renderPass === "translucent" && o2.paint.get("fill-antialias")) {
              const t2 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, Si.ReadOnly);
              Oi(e2, i2, o2, a2, t2, n2, true);
            }
          }, "fill-extrusion": function(t2, e2, i2, o2) {
            const a2 = i2.paint.get("fill-extrusion-opacity");
            if (a2 !== 0 && t2.renderPass === "translucent") {
              const s2 = new Si(t2.context.gl.LEQUAL, Si.ReadWrite, t2.depthRangeFor3D);
              if (a2 !== 1 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
                Ui(t2, e2, i2, o2, s2, Di.disabled, Ei.disabled), Ui(t2, e2, i2, o2, s2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
              else {
                const a3 = t2.colorModeForRenderPass();
                Ui(t2, e2, i2, o2, s2, Di.disabled, a3);
              }
            }
          }, hillshade: function(t2, e2, i2, o2) {
            if (t2.renderPass !== "offscreen" && t2.renderPass !== "translucent")
              return;
            const a2 = t2.context, s2 = t2.depthModeForSublayer(0, Si.ReadOnly), r2 = t2.colorModeForRenderPass(), [n2, l2] = t2.renderPass === "translucent" ? t2.stencilConfigForOverlap(o2) : [{}, o2];
            for (const o3 of l2) {
              const a3 = e2.getTile(o3);
              a3.needsHillshadePrepare !== void 0 && a3.needsHillshadePrepare && t2.renderPass === "offscreen" ? Gi(t2, a3, i2, s2, Di.disabled, r2) : t2.renderPass === "translucent" && Ni(t2, o3, a3, i2, s2, n2[o3.overscaledZ], r2);
            }
            a2.viewport.set([0, 0, t2.width, t2.height]);
          }, raster: function(t2, e2, i2, o2) {
            if (t2.renderPass !== "translucent")
              return;
            if (i2.paint.get("raster-opacity") === 0)
              return;
            if (!o2.length)
              return;
            const a2 = t2.context, s2 = a2.gl, r2 = e2.getSource(), n2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), [c2, h2] = r2 instanceof M ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = h2[h2.length - 1].overscaledZ, d2 = !t2.options.moving;
            for (const o3 of h2) {
              const h3 = t2.depthModeForSublayer(o3.overscaledZ - u2, i2.paint.get("raster-opacity") === 1 ? Si.ReadWrite : Si.ReadOnly, s2.LESS), _2 = e2.getTile(o3);
              _2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
              const m2 = e2.findLoadedParent(o3, 0), p2 = Zi(_2, m2, e2, i2, t2.transform, t2.style.terrain);
              let f2, g2;
              const x2 = i2.paint.get("raster-resampling") === "nearest" ? s2.NEAREST : s2.LINEAR;
              a2.activeTexture.set(s2.TEXTURE0), _2.texture.bind(x2, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), a2.activeTexture.set(s2.TEXTURE1), m2 ? (m2.texture.bind(x2, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, m2.tileID.overscaledZ - _2.tileID.overscaledZ), g2 = [_2.tileID.canonical.x * f2 % 1, _2.tileID.canonical.y * f2 % 1]) : _2.texture.bind(x2, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST);
              const v2 = t2.style.terrain && t2.style.terrain.getTerrainData(o3), y2 = v2 ? o3 : null, b2 = y2 ? y2.posMatrix : t2.transform.calculatePosMatrix(o3.toUnwrapped(), d2), w2 = Ae(b2, g2 || [0, 0], f2 || 1, p2, i2);
              r2 instanceof M ? n2.draw(a2, s2.TRIANGLES, h3, Di.disabled, l2, zi.disabled, w2, v2, i2.id, r2.boundsBuffer, t2.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(a2, s2.TRIANGLES, h3, c2[o3.overscaledZ], l2, zi.disabled, w2, v2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
            }
          }, background: function(t2, e2, i2, o2) {
            const a2 = i2.paint.get("background-color"), s2 = i2.paint.get("background-opacity");
            if (s2 === 0)
              return;
            const r2 = t2.context, n2 = r2.gl, l2 = t2.transform, c2 = l2.tileSize, h2 = i2.paint.get("background-pattern");
            if (t2.isPatternMissing(h2))
              return;
            const u2 = !h2 && a2.a === 1 && s2 === 1 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (t2.renderPass !== u2)
              return;
            const d2 = Di.disabled, _2 = t2.depthModeForSublayer(0, u2 === "opaque" ? Si.ReadWrite : Si.ReadOnly), m2 = t2.colorModeForRenderPass(), p2 = t2.useProgram(h2 ? "backgroundPattern" : "background"), f2 = o2 || l2.coveringTiles({ tileSize: c2, terrain: t2.style.terrain });
            h2 && (r2.activeTexture.set(n2.TEXTURE0), t2.imageManager.bind(t2.context));
            const g2 = i2.getCrossfadeParameters();
            for (const e3 of f2) {
              const l3 = o2 ? e3.posMatrix : t2.transform.calculatePosMatrix(e3.toUnwrapped()), u3 = h2 ? Fe(l3, s2, t2, h2, { tileID: e3, tileSize: c2 }, g2) : Be(l3, s2, a2), f3 = t2.style.terrain && t2.style.terrain.getTerrainData(e3);
              p2.draw(r2, n2.TRIANGLES, _2, d2, m2, zi.disabled, u3, f3, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
            }
          }, debug: function(t2, e2, i2) {
            for (let o2 = 0; o2 < i2.length; o2++)
              Yi(t2, e2, i2[o2]);
          }, custom: function(t2, e2, i2) {
            const o2 = t2.context, a2 = i2.implementation;
            if (t2.renderPass === "offscreen") {
              const e3 = a2.prerender;
              e3 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), e3.call(a2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
            } else if (t2.renderPass === "translucent") {
              t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(Di.disabled);
              const e3 = a2.renderingMode === "3d" ? new Si(t2.context.gl.LEQUAL, Si.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, Si.ReadOnly);
              o2.setDepthMode(e3), a2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
            }
          } };
          class io {
            constructor(e2, i2) {
              this.context = new Ii(e2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.create(), renderTime: 0 }, this.setup(), this.numSublayers = Z.maxUnderzooming + Z.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Yt(), this.gpuTimers = {};
            }
            resize(t2, e2, i2) {
              if (this.width = t2 * i2, this.height = e2 * i2, this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const t3 of this.style._order)
                  this.style._layers[t3].resize();
            }
            setup() {
              const e2 = this.context, i2 = new t.PosArray();
              i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i2, Jt.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const o2 = new t.PosArray();
              o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, Jt.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
              const a2 = new t.RasterBoundsArray();
              a2.emplaceBack(0, 0, 0, 0), a2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), a2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), a2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(a2, A.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const s2 = new t.PosArray();
              s2.emplaceBack(0, 0), s2.emplaceBack(1, 0), s2.emplaceBack(0, 1), s2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(s2, Jt.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const r2 = new t.LineStripIndexArray();
              r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(r2);
              const n2 = new t.TriangleIndexArray();
              n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(n2), this.emptyTexture = new d(e2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e2.gl.RGBA);
              const l2 = this.context.gl;
              this.stencilClearMode = new Di({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
            }
            clearStencil() {
              const e2 = this.context, i2 = e2.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0;
              const o2 = t.create();
              t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i2.TRIANGLES, Si.disabled, this.stencilClearMode, Ei.disabled, zi.disabled, we(o2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(t2, e2) {
              if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e2 || !e2.length)
                return;
              this.currentStencilSource = t2.source;
              const i2 = this.context, o2 = i2.gl;
              this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(Ei.disabled), i2.setDepthMode(Si.disabled);
              const a2 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const t3 of e2) {
                const e3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, s2 = this.style.terrain && this.style.terrain.getTerrainData(t3);
                a2.draw(i2, o2.TRIANGLES, Si.disabled, new Di({ func: o2.ALWAYS, mask: 0 }, e3, 255, o2.KEEP, o2.KEEP, o2.REPLACE), Ei.disabled, zi.disabled, we(t3.posMatrix), s2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const t2 = this.nextStencilID++, e2 = this.context.gl;
              return new Di({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
            }
            stencilModeForClipping(t2) {
              const e2 = this.context.gl;
              return new Di({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
            }
            stencilConfigForOverlap(t2) {
              const e2 = this.context.gl, i2 = t2.sort((t3, e3) => e3.overscaledZ - t3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, a2 = i2[0].overscaledZ - o2 + 1;
              if (a2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
                const t3 = {};
                for (let i3 = 0; i3 < a2; i3++)
                  t3[i3 + o2] = new Di({ func: e2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
                return this.nextStencilID += a2, [t3, i2];
              }
              return [{ [o2]: Di.disabled }, i2];
            }
            colorModeForRenderPass() {
              const e2 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new Ei([e2.CONSTANT_COLOR, e2.ONE], new t.Color(i2, i2, i2, 0), [true, true, true, true]);
              }
              return this.renderPass === "opaque" ? Ei.unblended : Ei.alphaBlended;
            }
            depthModeForSublayer(t2, e2, i2) {
              if (!this.opaquePassEnabledForLayer())
                return Si.disabled;
              const o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
              return new Si(i2 || this.context.gl.LEQUAL, e2, [o2, o2]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e2, i2) {
              this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.exported.now()), this.imageManager.beginFrame();
              const o2 = this.style._order, a2 = this.style.sourceCaches, s2 = this.style.terrain && new to(this);
              for (const t2 in a2) {
                const e3 = a2[t2];
                e3.used && e3.prepare(this.context);
              }
              const r2 = {}, n2 = {}, l2 = {};
              for (const t2 in a2) {
                const e3 = a2[t2];
                r2[t2] = e3.getVisibleCoordinates(), n2[t2] = r2[t2].slice().reverse(), l2[t2] = e3.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let t2 = 0; t2 < o2.length; t2++)
                if (this.style._layers[o2[t2]].is3D()) {
                  this.opaquePassCutoff = t2;
                  break;
                }
              if (s2) {
                this.opaquePassCutoff = 0;
                const e3 = this.style.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
                (this.terrainFacilitator.dirty || !t.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e3.length) && (t.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e4, i3) {
                  const o3 = e4.context, a3 = o3.gl, s3 = Ei.unblended, r3 = new Si(a3.LEQUAL, Si.ReadWrite, [0, 1]), n3 = i3.getTerrainMesh(), l3 = i3.sourceCache.getRenderableTiles(), c2 = e4.useProgram("terrainDepth");
                  o3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), o3.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), o3.clear({ color: t.Color.transparent, depth: 1 });
                  for (const t2 of l3) {
                    const l4 = i3.getTerrainData(t2.tileID), h2 = e4.transform.calculatePosMatrix(t2.tileID.toUnwrapped());
                    c2.draw(o3, a3.TRIANGLES, r3, Di.disabled, s3, zi.backCCW, { u_matrix: h2 }, l4, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments);
                  }
                  o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, e4.width, e4.height]);
                }(this, this.style.terrain), function(e4, i3) {
                  const o3 = e4.context, a3 = o3.gl, s3 = Ei.unblended, r3 = new Si(a3.LEQUAL, Si.ReadWrite, [0, 1]), n3 = i3.getTerrainMesh(), l3 = i3.getCoordsTexture(), c2 = i3.sourceCache.getRenderableTiles(), h2 = e4.useProgram("terrainCoords");
                  o3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), o3.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), o3.clear({ color: t.Color.transparent, depth: 1 }), i3.coordsIndex = [];
                  for (const t2 of c2) {
                    const c3 = i3.getTerrainData(t2.tileID);
                    o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, l3.texture);
                    const u2 = e4.transform.calculatePosMatrix(t2.tileID.toUnwrapped());
                    h2.draw(o3, a3.TRIANGLES, r3, Di.disabled, s3, zi.backCCW, { u_matrix: u2, u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0 }, c3, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments), i3.coordsIndex.push(t2.tileID.key);
                  }
                  o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, e4.width, e4.height]);
                }(this, this.style.terrain));
              }
              this.renderPass = "offscreen";
              for (const t2 of o2) {
                const e3 = this.style._layers[t2];
                if (!e3.hasOffscreenPass() || e3.isHidden(this.transform.zoom))
                  continue;
                const i3 = n2[e3.source];
                (e3.type === "custom" || i3.length) && this.renderLayer(this, a2[e3.source], e3, i3);
              }
              if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !s2)
                for (this.renderPass = "opaque", this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const t2 = this.style._layers[o2[this.currentLayer]], e3 = a2[t2.source], i3 = r2[t2.source];
                  this._renderTileClippingMasks(t2, i3), this.renderLayer(this, e3, t2, i3);
                }
              for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                const t2 = this.style._layers[o2[this.currentLayer]], e3 = a2[t2.source];
                if (s2 && s2.renderLayer(t2))
                  continue;
                const i3 = (t2.type === "symbol" ? l2 : n2)[t2.source];
                this._renderTileClippingMasks(t2, r2[t2.source]), this.renderLayer(this, e3, t2, i3);
              }
              if (this.options.showTileBoundaries) {
                let t2, e3;
                Object.values(this.style._layers).forEach((i3) => {
                  i3.source && !i3.isHidden(this.transform.zoom) && (i3.source !== (e3 && e3.id) && (e3 = this.style.sourceCaches[i3.source]), (!t2 || t2.getSource().maxzoom < e3.getSource().maxzoom) && (t2 = e3));
                }), t2 && eo.debug(this, t2, t2.getVisibleCoordinates());
              }
              this.options.showPadding && function(t2) {
                const e3 = t2.transform.padding;
                Wi(t2, t2.transform.height - (e3.top || 0), 3, qi), Wi(t2, e3.bottom || 0, 3, Vi), Hi(t2, e3.left || 0, 3, ji), Hi(t2, t2.transform.width - (e3.right || 0), 3, Xi);
                const i3 = t2.transform.centerPoint;
                !function(t3, e4, i4, o3) {
                  Ki(t3, e4 - 1, i4 - 10, 2, 20, o3), Ki(t3, e4 - 10, i4 - 1, 20, 2, o3);
                }(t2, i3.x, t2.transform.height - i3.y, $i);
              }(this), this.context.setDefault();
            }
            renderLayer(t2, e2, i2, o2) {
              i2.isHidden(this.transform.zoom) || (i2.type === "background" || i2.type === "custom" || (o2 || []).length) && (this.id = i2.id, this.gpuTimingStart(i2), eo[i2.type](t2, e2, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
            }
            gpuTimingStart(t2) {
              if (!this.options.gpuTiming)
                return;
              const e2 = this.context.extTimerQuery;
              let i2 = this.gpuTimers[t2.id];
              i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i2.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i2.query);
            }
            gpuTimingEnd() {
              if (!this.options.gpuTiming)
                return;
              const t2 = this.context.extTimerQuery;
              t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
              const t2 = this.gpuTimers;
              return this.gpuTimers = {}, t2;
            }
            queryGpuTimers(t2) {
              const e2 = {};
              for (const i2 in t2) {
                const o2 = t2[i2], a2 = this.context.extTimerQuery, s2 = a2.getQueryObjectEXT(o2.query, a2.QUERY_RESULT_EXT) / 1e6;
                a2.deleteQueryEXT(o2.query), e2[i2] = s2;
              }
              return e2;
            }
            translatePosMatrix(e2, i2, o2, a2, s2) {
              if (!o2[0] && !o2[1])
                return e2;
              const r2 = s2 ? a2 === "map" ? this.transform.angle : 0 : a2 === "viewport" ? -this.transform.angle : 0;
              if (r2) {
                const t2 = Math.sin(r2), e3 = Math.cos(r2);
                o2 = [o2[0] * e3 - o2[1] * t2, o2[0] * t2 + o2[1] * e3];
              }
              const n2 = [s2 ? o2[0] : It(i2, o2[0], this.transform.zoom), s2 ? o2[1] : It(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return t.translate(l2, e2, n2), l2;
            }
            saveTileTexture(t2) {
              const e2 = this._tileTextures[t2.size[0]];
              e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
            }
            getTileTexture(t2) {
              const e2 = this._tileTextures[t2];
              return e2 && e2.length > 0 ? e2.pop() : null;
            }
            isPatternMissing(t2) {
              if (!t2)
                return false;
              if (!t2.from || !t2.to)
                return true;
              const e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
              return !e2 || !i2;
            }
            useProgram(t2, e2) {
              this.cache = this.cache || {};
              const i2 = t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.terrain ? "/terrain" : "");
              return this.cache[i2] || (this.cache[i2] = new ue(this.context, t2, ne[t2], e2, Oe[t2], this._showOverdrawInspector, this.style.terrain)), this.cache[i2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const t2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new d(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
          }
          class oo {
            constructor(t2, e2) {
              this.points = t2, this.planes = e2;
            }
            static fromInvProjectionMatrix(e2, i2, o2) {
              const a2 = Math.pow(2, o2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((o3) => {
                const s3 = 1 / (o3 = t.transformMat4([], o3, e2))[3] / i2 * a2;
                return t.mul$1(o3, o3, [s3, s3, 1 / o3[3], s3]);
              }), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t2) => {
                const e3 = function(t3, e4) {
                  var i4 = e4[0], o4 = e4[1], a4 = e4[2], s3 = i4 * i4 + o4 * o4 + a4 * a4;
                  return s3 > 0 && (s3 = 1 / Math.sqrt(s3)), t3[0] = e4[0] * s3, t3[1] = e4[1] * s3, t3[2] = e4[2] * s3, t3;
                }([], function(t3, e4, i4) {
                  var o4 = e4[0], a4 = e4[1], s3 = e4[2], r3 = i4[0], n2 = i4[1], l2 = i4[2];
                  return t3[0] = a4 * l2 - s3 * n2, t3[1] = s3 * r3 - o4 * l2, t3[2] = o4 * n2 - a4 * r3, t3;
                }([], h([], s2[t2[0]], s2[t2[1]]), h([], s2[t2[2]], s2[t2[1]]))), i3 = -((o3 = e3)[0] * (a3 = s2[t2[1]])[0] + o3[1] * a3[1] + o3[2] * a3[2]);
                var o3, a3;
                return e3.concat(i3);
              });
              return new oo(s2, r2);
            }
          }
          class ao {
            constructor(t2, e2) {
              this.min = t2, this.max = e2, this.center = function(t3, e3, i2) {
                return t3[0] = 0.5 * e3[0], t3[1] = 0.5 * e3[1], t3[2] = 0.5 * e3[2], t3;
              }([], function(t3, e3, i2) {
                return t3[0] = e3[0] + i2[0], t3[1] = e3[1] + i2[1], t3[2] = e3[2] + i2[2], t3;
              }([], this.min, this.max));
            }
            quadrant(t2) {
              const e2 = [t2 % 2 == 0, t2 < 2], i2 = l(this.min), o2 = l(this.max);
              for (let t3 = 0; t3 < e2.length; t3++)
                i2[t3] = e2[t3] ? this.min[t3] : this.center[t3], o2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
              return o2[2] = this.max[2], new ao(i2, o2);
            }
            distanceX(t2) {
              return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
            }
            distanceY(t2) {
              return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
            }
            intersects(e2) {
              const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
              let o2 = true;
              for (let a2 = 0; a2 < e2.planes.length; a2++) {
                const s2 = e2.planes[a2];
                let r2 = 0;
                for (let e3 = 0; e3 < i2.length; e3++)
                  t.dot(s2, i2[e3]) >= 0 && r2++;
                if (r2 === 0)
                  return 0;
                r2 !== i2.length && (o2 = false);
              }
              if (o2)
                return 2;
              for (let t2 = 0; t2 < 3; t2++) {
                let i3 = Number.MAX_VALUE, o3 = -Number.MAX_VALUE;
                for (let a2 = 0; a2 < e2.points.length; a2++) {
                  const s2 = e2.points[a2][t2] - this.min[t2];
                  i3 = Math.min(i3, s2), o3 = Math.max(o3, s2);
                }
                if (o3 < 0 || i3 > this.max[t2] - this.min[t2])
                  return 0;
              }
              return 1;
            }
          }
          class so {
            constructor(t2 = 0, e2 = 0, i2 = 0, o2 = 0) {
              if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = t2, this.bottom = e2, this.left = i2, this.right = o2;
            }
            interpolate(e2, i2, o2) {
              return i2.top != null && e2.top != null && (this.top = t.number(e2.top, i2.top, o2)), i2.bottom != null && e2.bottom != null && (this.bottom = t.number(e2.bottom, i2.bottom, o2)), i2.left != null && e2.left != null && (this.left = t.number(e2.left, i2.left, o2)), i2.right != null && e2.right != null && (this.right = t.number(e2.right, i2.right, o2)), this;
            }
            getCenter(e2, i2) {
              const o2 = t.clamp((this.left + e2 - this.right) / 2, 0, e2), a2 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
              return new t.pointGeometry(o2, a2);
            }
            equals(t2) {
              return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
            }
            clone() {
              return new so(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          class ro {
            constructor(e2, i2, o2, a2, s2) {
              this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = false, this._renderWorldCopies = s2 === void 0 || !!s2, this._minZoom = e2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 == null ? 0 : o2, this._maxPitch = a2 == null ? 60 : a2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new so(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            clone() {
              const t2 = new ro(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
              return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2._elevation = this._elevation, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._calcMatrices(), t2;
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(t2) {
              this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(t2) {
              this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(t2) {
              this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(t2) {
              this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            set renderWorldCopies(t2) {
              t2 === void 0 ? t2 = true : t2 === null && (t2 = false), this._renderWorldCopies = t2;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t.pointGeometry(this.width, this.height);
            }
            get bearing() {
              return -this.angle / Math.PI * 180;
            }
            set bearing(e2) {
              const i2 = -t.wrap(e2, -180, 180) * Math.PI / 180;
              this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = function() {
                var e3 = new t.ARRAY_TYPE(4);
                return t.ARRAY_TYPE != Float32Array && (e3[1] = 0, e3[2] = 0), e3[0] = 1, e3[3] = 1, e3;
              }(), function(t2, e3, i3) {
                var o2 = e3[0], a2 = e3[1], s2 = e3[2], r2 = e3[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
                t2[0] = o2 * l2 + s2 * n2, t2[1] = a2 * l2 + r2 * n2, t2[2] = o2 * -n2 + s2 * l2, t2[3] = a2 * -n2 + r2 * l2;
              }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(e2) {
              const i2 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            set fov(t2) {
              t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(t2) {
              const e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
              this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom, this._constrain(), this._calcMatrices());
            }
            get center() {
              return this._center;
            }
            set center(t2) {
              t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(t2) {
              t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(t2) {
              this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            isPaddingEqual(t2) {
              return this._edgeInsets.equals(t2);
            }
            interpolatePadding(t2, e2, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(t2) {
              const e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
              return Math.max(0, e2);
            }
            getVisibleUnwrappedCoordinates(e2) {
              const i2 = [new t.UnwrappedTileID(0, e2)];
              if (this._renderWorldCopies) {
                const o2 = this.pointCoordinate(new t.pointGeometry(0, 0)), a2 = this.pointCoordinate(new t.pointGeometry(this.width, 0)), s2 = this.pointCoordinate(new t.pointGeometry(this.width, this.height)), r2 = this.pointCoordinate(new t.pointGeometry(0, this.height)), n2 = Math.floor(Math.min(o2.x, a2.x, s2.x, r2.x)), l2 = Math.floor(Math.max(o2.x, a2.x, s2.x, r2.x)), c2 = 1;
                for (let o3 = n2 - c2; o3 <= l2 + c2; o3++)
                  o3 !== 0 && i2.push(new t.UnwrappedTileID(o3, e2));
              }
              return i2;
            }
            coveringTiles(e2) {
              let i2 = this.coveringZoomLevel(e2);
              const o2 = i2;
              if (e2.minzoom !== void 0 && i2 < e2.minzoom)
                return [];
              e2.maxzoom !== void 0 && i2 > e2.maxzoom && (i2 = e2.maxzoom);
              const a2 = this.pointCoordinate(this.getCameraPoint()), s2 = t.MercatorCoordinate.fromLngLat(this.center), r2 = Math.pow(2, i2), n2 = [r2 * a2.x, r2 * a2.y, 0], l2 = [r2 * s2.x, r2 * s2.y, 0], c2 = oo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2);
              let h2 = e2.minzoom || 0;
              !e2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (h2 = i2);
              const d2 = e2.terrain ? 2 / Math.min(this.tileSize, e2.tileSize) * this.tileSize : 3, _2 = (t2) => ({ aabb: new ao([t2 * r2, 0, 0], [(t2 + 1) * r2, r2, 0]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: false }), m2 = [], p2 = [], f2 = i2, g2 = e2.reparseOverscaled ? o2 : i2;
              if (this._renderWorldCopies)
                for (let t2 = 1; t2 <= 3; t2++)
                  m2.push(_2(-t2)), m2.push(_2(t2));
              for (m2.push(_2(0)); m2.length > 0; ) {
                const i3 = m2.pop(), o3 = i3.x, a3 = i3.y;
                let s3 = i3.fullyVisible;
                if (!s3) {
                  const t2 = i3.aabb.intersects(c2);
                  if (t2 === 0)
                    continue;
                  s3 = t2 === 2;
                }
                const r3 = e2.terrain ? n2 : l2, _3 = i3.aabb.distanceX(r3), x2 = i3.aabb.distanceY(r3), v2 = Math.max(Math.abs(_3), Math.abs(x2)), y2 = d2 + (1 << f2 - i3.zoom) - 2;
                if (i3.zoom === f2 || v2 > y2 && i3.zoom >= h2) {
                  const e3 = f2 - i3.zoom, s4 = n2[0] - 0.5 - (o3 << e3), r4 = n2[1] - 0.5 - (a3 << e3);
                  p2.push({ tileID: new t.OverscaledTileID(i3.zoom === f2 ? g2 : i3.zoom, i3.wrap, i3.zoom, o3, a3), distanceSq: u([l2[0] - 0.5 - o3, l2[1] - 0.5 - a3]), tileDistanceToCamera: Math.sqrt(s4 * s4 + r4 * r4) });
                } else
                  for (let r4 = 0; r4 < 4; r4++) {
                    const n3 = (o3 << 1) + r4 % 2, l3 = (a3 << 1) + (r4 >> 1), c3 = i3.zoom + 1;
                    let h3 = i3.aabb.quadrant(r4);
                    if (e2.terrain) {
                      const o4 = new t.OverscaledTileID(c3, i3.wrap, c3, n3, l3), a4 = e2.terrain.getTerrainData(o4).tile;
                      let s4 = this.elevation, r5 = this.elevation;
                      a4 && a4.dem && (s4 = a4.dem.min * e2.terrain.exaggeration, r5 = a4.dem.max * e2.terrain.exaggeration), h3 = new ao([h3.min[0], h3.min[1], s4], [h3.max[0], h3.max[1], r5]);
                    }
                    m2.push({ aabb: h3, zoom: c3, x: n3, y: l3, wrap: i3.wrap, fullyVisible: s3 });
                  }
              }
              return p2.sort((t2, e3) => t2.distanceSq - e3.distanceSq).map((t2) => t2.tileID);
            }
            resize(t2, e2) {
              this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(t2) {
              return Math.pow(2, t2);
            }
            scaleZoom(t2) {
              return Math.log(t2) / Math.LN2;
            }
            project(e2) {
              const i2 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
              return new t.pointGeometry(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
            }
            unproject(e2) {
              return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
            }
            get point() {
              return this.project(this.center);
            }
            updateElevation(t2) {
              this.freezeElevation || (this.elevation = t2 ? this.getElevation(this._center, t2) : 0);
            }
            getElevation(e2, i2) {
              const o2 = t.MercatorCoordinate.fromLngLat(e2), a2 = (1 << this.tileZoom) * t.EXTENT, s2 = o2.x * a2, r2 = o2.y * a2, n2 = Math.floor(s2 / t.EXTENT), l2 = Math.floor(r2 / t.EXTENT), c2 = new t.OverscaledTileID(this.tileZoom, 0, this.tileZoom, n2, l2);
              return i2.getElevation(c2, s2 % t.EXTENT, r2 % t.EXTENT, t.EXTENT);
            }
            getCameraPosition() {
              return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
            }
            recalculateZoom(e2) {
              const i2 = this.pointLocation(this.centerPoint, e2), o2 = this.getElevation(i2, e2);
              if (!(this.elevation - o2))
                return;
              const a2 = this.getCameraPosition(), s2 = t.MercatorCoordinate.fromLngLat(a2.lngLat, a2.altitude), r2 = t.MercatorCoordinate.fromLngLat(i2, o2), n2 = s2.x - r2.x, l2 = s2.y - r2.y, c2 = s2.z - r2.z, h2 = Math.sqrt(n2 * n2 + l2 * l2 + c2 * c2), u2 = this.scaleZoom(this.cameraToCenterDistance / h2 / this.tileSize);
              this._elevation = o2, this._center = i2, this.zoom = u2;
            }
            setLocationAtPoint(e2, i2) {
              const o2 = this.pointCoordinate(i2), a2 = this.pointCoordinate(this.centerPoint), s2 = this.locationCoordinate(e2), r2 = new t.MercatorCoordinate(s2.x - (o2.x - a2.x), s2.y - (o2.y - a2.y));
              this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            locationPoint(t2, e2) {
              return e2 ? this.coordinatePoint(this.locationCoordinate(t2), this.getElevation(t2, e2), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
            }
            pointLocation(t2, e2) {
              return this.coordinateLocation(this.pointCoordinate(t2, e2));
            }
            locationCoordinate(e2) {
              return t.MercatorCoordinate.fromLngLat(e2);
            }
            coordinateLocation(t2) {
              return t2 && t2.toLngLat();
            }
            pointCoordinate(e2, i2) {
              if (i2) {
                const t2 = i2.pointCoordinate(e2);
                if (t2 != null)
                  return t2;
              }
              const o2 = [e2.x, e2.y, 0, 1], a2 = [e2.x, e2.y, 1, 1];
              t.transformMat4(o2, o2, this.pixelMatrixInverse), t.transformMat4(a2, a2, this.pixelMatrixInverse);
              const s2 = o2[3], r2 = a2[3], n2 = o2[1] / s2, l2 = a2[1] / r2, c2 = o2[2] / s2, h2 = a2[2] / r2, u2 = c2 === h2 ? 0 : (0 - c2) / (h2 - c2);
              return new t.MercatorCoordinate(t.number(o2[0] / s2, a2[0] / r2, u2) / this.worldSize, t.number(n2, l2, u2) / this.worldSize);
            }
            coordinatePoint(e2, i2 = 0, o2 = this.pixelMatrix) {
              const a2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2, 1];
              return t.transformMat4(a2, a2, o2), new t.pointGeometry(a2[0] / a2[3], a2[1] / a2[3]);
            }
            getBounds() {
              const e2 = Math.max(0, this.height / 2 - this.getHorizon());
              return new t.LngLatBounds().extend(this.pointLocation(new t.pointGeometry(0, e2))).extend(this.pointLocation(new t.pointGeometry(this.width, e2))).extend(this.pointLocation(new t.pointGeometry(this.width, this.height))).extend(this.pointLocation(new t.pointGeometry(0, this.height)));
            }
            getMaxBounds() {
              return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
            }
            getHorizon() {
              return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
            }
            setMaxBounds(t2) {
              t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
            }
            calculatePosMatrix(e2, i2 = false) {
              const o2 = e2.key, a2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
              if (a2[o2])
                return a2[o2];
              const s2 = e2.canonical, r2 = this.worldSize / this.zoomScale(s2.z), n2 = s2.x + Math.pow(2, s2.z) * e2.wrap, l2 = t.identity(new Float64Array(16));
              return t.translate(l2, l2, [n2 * r2, s2.y * r2, 0]), t.scale(l2, l2, [r2 / t.EXTENT, r2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), a2[o2] = new Float32Array(l2), a2[o2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              let e2, i2, o2, a2, s2 = -90, r2 = 90, n2 = -180, l2 = 180;
              const c2 = this.size, h2 = this._unmodified;
              if (this.latRange) {
                const i3 = this.latRange;
                s2 = t.mercatorYfromLat(i3[1]) * this.worldSize, r2 = t.mercatorYfromLat(i3[0]) * this.worldSize, e2 = r2 - s2 < c2.y ? c2.y / (r2 - s2) : 0;
              }
              if (this.lngRange) {
                const e3 = this.lngRange;
                n2 = t.mercatorXfromLng(e3[0]) * this.worldSize, l2 = t.mercatorXfromLng(e3[1]) * this.worldSize, i2 = l2 - n2 < c2.x ? c2.x / (l2 - n2) : 0;
              }
              const u2 = this.point, d2 = Math.max(i2 || 0, e2 || 0);
              if (d2)
                return this.center = this.unproject(new t.pointGeometry(i2 ? (l2 + n2) / 2 : u2.x, e2 ? (r2 + s2) / 2 : u2.y)), this.zoom += this.scaleZoom(d2), this._unmodified = h2, void (this._constraining = false);
              if (this.latRange) {
                const t2 = u2.y, e3 = c2.y / 2;
                t2 - e3 < s2 && (a2 = s2 + e3), t2 + e3 > r2 && (a2 = r2 - e3);
              }
              if (this.lngRange) {
                const t2 = u2.x, e3 = c2.x / 2;
                t2 - e3 < n2 && (o2 = n2 + e3), t2 + e3 > l2 && (o2 = l2 - e3);
              }
              o2 === void 0 && a2 === void 0 || (this.center = this.unproject(new t.pointGeometry(o2 !== void 0 ? o2 : u2.x, a2 !== void 0 ? a2 : u2.y))), this._unmodified = h2, this._constraining = false;
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const e2 = this.centerOffset, i2 = this.point.x, o2 = this.point.y;
              this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
              let a2 = t.identity(new Float64Array(16));
              t.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), t.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = t.identity(new Float64Array(16)), t.scale(a2, a2, [1, -1, 1]), t.translate(a2, a2, [-1, -1, 0]), t.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
              const s2 = Math.PI / 2 + this._pitch, r2 = this._fov * (0.5 + e2.y / this.height), n2 = Math.sin(r2) * this.cameraToSeaLevelDistance / Math.sin(t.clamp(Math.PI - s2 - r2, 0.01, Math.PI - 0.01)), l2 = this.getHorizon(), c2 = 2 * Math.atan(l2 / this.cameraToCenterDistance) * (0.5 + e2.y / (2 * l2)), h2 = Math.sin(c2) * this.cameraToSeaLevelDistance / Math.sin(t.clamp(Math.PI - s2 - c2, 0.01, Math.PI - 0.01)), u2 = Math.cos(Math.PI / 2 - this._pitch) * n2 + this.cameraToSeaLevelDistance, d2 = Math.cos(Math.PI / 2 - this._pitch) * h2 + this.cameraToSeaLevelDistance, _2 = 1.01 * Math.min(u2, d2), m2 = this.height / 50;
              a2 = new Float64Array(16), t.perspective(a2, this._fov, this.width / this.height, m2, _2), a2[8] = 2 * -e2.x / this.width, a2[9] = 2 * e2.y / this.height, t.scale(a2, a2, [1, -1, 1]), t.translate(a2, a2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(a2, a2, this._pitch), t.rotateZ(a2, a2, this.angle), t.translate(a2, a2, [-i2, -o2, 0]), this.mercatorMatrix = t.scale([], a2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(a2, a2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, a2), t.translate(a2, a2, [0, 0, -this.elevation]), this.projMatrix = a2, this.invProjMatrix = t.invert([], a2), this.pixelMatrix3D = t.multiply(new Float64Array(16), this.labelPlaneMatrix, a2);
              const p2 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x2 = Math.sin(this.angle), v2 = i2 - Math.round(i2) + g2 * p2 + x2 * f2, y2 = o2 - Math.round(o2) + g2 * f2 + x2 * p2, b2 = new Float64Array(a2);
              if (t.translate(b2, b2, [v2 > 0.5 ? v2 - 1 : v2, y2 > 0.5 ? y2 - 1 : y2, 0]), this.alignedProjMatrix = b2, a2 = t.invert(new Float64Array(16), this.pixelMatrix), !a2)
                throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = a2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            maxPitchScaleFactor() {
              if (!this.pixelMatrixInverse)
                return 1;
              const e2 = this.pointCoordinate(new t.pointGeometry(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
              return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
            }
            getCameraPoint() {
              const e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t.pointGeometry(0, e2));
            }
            getCameraQueryGeometry(e2) {
              const i2 = this.getCameraPoint();
              if (e2.length === 1)
                return [e2[0], i2];
              {
                let o2 = i2.x, a2 = i2.y, s2 = i2.x, r2 = i2.y;
                for (const t2 of e2)
                  o2 = Math.min(o2, t2.x), a2 = Math.min(a2, t2.y), s2 = Math.max(s2, t2.x), r2 = Math.max(r2, t2.y);
                return [new t.pointGeometry(o2, a2), new t.pointGeometry(s2, a2), new t.pointGeometry(s2, r2), new t.pointGeometry(o2, r2), new t.pointGeometry(o2, a2)];
              }
            }
          }
          class no {
            constructor(e2) {
              this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = function(t2, e3) {
                let i2 = false, o2 = null;
                const a2 = () => {
                  o2 = null, i2 && (t2(), o2 = setTimeout(a2, 300), i2 = false);
                };
                return () => (i2 = true, o2 || a2(), o2);
              }(this._updateHashUnthrottled.bind(this));
            }
            addTo(t2) {
              return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
            }
            getHashString(t2) {
              const e2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, o2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, o2), s2 = Math.round(e2.lng * a2) / a2, r2 = Math.round(e2.lat * a2) / a2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
              let c2 = "";
              if (c2 += t2 ? `/${s2}/${r2}/${i2}` : `${i2}/${r2}/${s2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
                const t3 = this._hashName;
                let e3 = false;
                const i3 = window.location.hash.slice(1).split("&").map((i4) => {
                  const o3 = i4.split("=")[0];
                  return o3 === t3 ? (e3 = true, `${o3}=${c2}`) : i4;
                }).filter((t4) => t4);
                return e3 || i3.push(`${t3}=${c2}`), `#${i3.join("&")}`;
              }
              return `#${c2}`;
            }
            _getCurrentHash() {
              const t2 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e2;
                return t2.split("&").map((t3) => t3.split("=")).forEach((t3) => {
                  t3[0] === this._hashName && (e2 = t3);
                }), (e2 && e2[1] || "").split("/");
              }
              return t2.split("/");
            }
            _onHashChange() {
              const t2 = this._getCurrentHash();
              if (t2.length >= 3 && !t2.some((t3) => isNaN(t3))) {
                const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e2, pitch: +(t2[4] || 0) }), true;
              }
              return false;
            }
            _updateHashUnthrottled() {
              const t2 = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, t2);
              } catch (t3) {
              }
            }
          }
          const lo = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, co = t.extend({ deceleration: 2500, maxSpeed: 1400 }, lo), ho = t.extend({ deceleration: 20, maxSpeed: 1400 }, lo), uo = t.extend({ deceleration: 1e3, maxSpeed: 360 }, lo), _o = t.extend({ deceleration: 1e3, maxSpeed: 90 }, lo);
          class mo {
            constructor(t2) {
              this._map = t2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e2) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.exported.now(), settings: e2 });
            }
            _drainInertiaBuffer() {
              const e2 = this._inertiaBuffer, i2 = t.exported.now();
              for (; e2.length > 0 && i2 - e2[0].time > 160; )
                e2.shift();
            }
            _onMoveEnd(e2) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: t2 } of this._inertiaBuffer)
                i2.zoom += t2.zoomDelta || 0, i2.bearing += t2.bearingDelta || 0, i2.pitch += t2.pitchDelta || 0, t2.panDelta && i2.pan._add(t2.panDelta), t2.around && (i2.around = t2.around), t2.pinchAround && (i2.pinchAround = t2.pinchAround);
              const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a2 = {};
              if (i2.pan.mag()) {
                const s2 = fo(i2.pan.mag(), o2, t.extend({}, co, e2 || {}));
                a2.offset = i2.pan.mult(s2.amount / i2.pan.mag()), a2.center = this._map.transform.center, po(a2, s2);
              }
              if (i2.zoom) {
                const t2 = fo(i2.zoom, o2, ho);
                a2.zoom = this._map.transform.zoom + t2.amount, po(a2, t2);
              }
              if (i2.bearing) {
                const e3 = fo(i2.bearing, o2, uo);
                a2.bearing = this._map.transform.bearing + t.clamp(e3.amount, -179, 179), po(a2, e3);
              }
              if (i2.pitch) {
                const t2 = fo(i2.pitch, o2, _o);
                a2.pitch = this._map.transform.pitch + t2.amount, po(a2, t2);
              }
              if (a2.zoom || a2.bearing) {
                const t2 = i2.pinchAround === void 0 ? i2.around : i2.pinchAround;
                a2.around = t2 ? this._map.unproject(t2) : this._map.getCenter();
              }
              return this.clear(), t.extend(a2, { noMoveStart: true });
            }
          }
          function po(t2, e2) {
            (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
          }
          function fo(e2, i2, o2) {
            const { maxSpeed: a2, linearity: s2, deceleration: r2 } = o2, n2 = t.clamp(e2 * s2 / (i2 / 1e3), -a2, a2), l2 = Math.abs(n2) / (r2 * s2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
          }
          class go extends t.Event {
            constructor(e2, i2, o2, a2 = {}) {
              const r2 = s.mousePos(i2.getCanvasContainer(), o2), n2 = i2.unproject(r2);
              super(e2, t.extend({ point: r2, lngLat: n2, originalEvent: o2 }, a2)), this._defaultPrevented = false, this.target = i2;
            }
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
          }
          class xo extends t.Event {
            constructor(e2, i2, o2) {
              const a2 = e2 === "touchend" ? o2.changedTouches : o2.touches, r2 = s.touchPos(i2.getCanvasContainer(), a2), n2 = r2.map((t2) => i2.unproject(t2)), l2 = r2.reduce((t2, e3, i3, o3) => t2.add(e3.div(o3.length)), new t.pointGeometry(0, 0));
              super(e2, { points: r2, point: l2, lngLats: n2, lngLat: i2.unproject(l2), originalEvent: o2 }), this._defaultPrevented = false;
            }
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
          }
          class vo extends t.Event {
            constructor(t2, e2, i2) {
              super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
            }
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
          }
          class yo {
            constructor(t2, e2) {
              this._map = t2, this._clickTolerance = e2.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(t2) {
              return this._firePreventable(new vo(t2.type, this._map, t2));
            }
            mousedown(t2, e2) {
              return this._mousedownPos = e2, this._firePreventable(new go(t2.type, this._map, t2));
            }
            mouseup(t2) {
              this._map.fire(new go(t2.type, this._map, t2));
            }
            click(t2, e2) {
              this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new go(t2.type, this._map, t2));
            }
            dblclick(t2) {
              return this._firePreventable(new go(t2.type, this._map, t2));
            }
            mouseover(t2) {
              this._map.fire(new go(t2.type, this._map, t2));
            }
            mouseout(t2) {
              this._map.fire(new go(t2.type, this._map, t2));
            }
            touchstart(t2) {
              return this._firePreventable(new xo(t2.type, this._map, t2));
            }
            touchmove(t2) {
              this._map.fire(new xo(t2.type, this._map, t2));
            }
            touchend(t2) {
              this._map.fire(new xo(t2.type, this._map, t2));
            }
            touchcancel(t2) {
              this._map.fire(new xo(t2.type, this._map, t2));
            }
            _firePreventable(t2) {
              if (this._map.fire(t2), t2.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class bo {
            constructor(t2) {
              this._map = t2;
            }
            reset() {
              this._delayContextMenu = false, delete this._contextMenuEvent;
            }
            mousemove(t2) {
              this._map.fire(new go(t2.type, this._map, t2));
            }
            mousedown() {
              this._delayContextMenu = true;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new go("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(t2) {
              this._delayContextMenu ? this._contextMenuEvent = t2 : this._map.fire(new go(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class wo {
            constructor(t2, e2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(t2, e2) {
              this.isEnabled() && t2.shiftKey && t2.button === 0 && (s.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
            }
            mousemoveWindow(t2, e2) {
              if (!this._active)
                return;
              const i2 = e2;
              if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
                return;
              const o2 = this._startPos;
              this._lastPos = i2, this._box || (this._box = s.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
              const a2 = Math.min(o2.x, i2.x), r2 = Math.max(o2.x, i2.x), n2 = Math.min(o2.y, i2.y), l2 = Math.max(o2.y, i2.y);
              s.setTransform(this._box, `translate(${a2}px,${n2}px)`), this._box.style.width = r2 - a2 + "px", this._box.style.height = l2 - n2 + "px";
            }
            mouseupWindow(e2, i2) {
              if (!this._active)
                return;
              if (e2.button !== 0)
                return;
              const o2 = this._startPos, a2 = i2;
              if (this.reset(), s.suppressClick(), o2.x !== a2.x || o2.y !== a2.y)
                return this._map.fire(new t.Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (t2) => t2.fitScreenCoordinates(o2, a2, this._map.getBearing(), { linear: true }) };
              this._fireEvent("boxzoomcancel", e2);
            }
            keydown(t2) {
              this._active && t2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t2));
            }
            reset() {
              this._active = false, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (s.remove(this._box), this._box = null), s.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e2, i2) {
              return this._map.fire(new t.Event(e2, { originalEvent: i2 }));
            }
          }
          function To(t2, e2) {
            const i2 = {};
            for (let o2 = 0; o2 < t2.length; o2++)
              i2[t2[o2].identifier] = e2[o2];
            return i2;
          }
          class Eo {
            constructor(t2) {
              this.reset(), this.numTouches = t2.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e2, i2, o2) {
              (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e2.timeStamp), o2.length === this.numTouches && (this.centroid = function(e3) {
                const i3 = new t.pointGeometry(0, 0);
                for (const t2 of e3)
                  i3._add(t2);
                return i3.div(e3.length);
              }(i2), this.touches = To(o2, i2)));
            }
            touchmove(t2, e2, i2) {
              if (this.aborted || !this.centroid)
                return;
              const o2 = To(i2, e2);
              for (const t3 in this.touches) {
                const e3 = this.touches[t3], i3 = o2[t3];
                (!i3 || i3.dist(e3) > 30) && (this.aborted = true);
              }
            }
            touchend(t2, e2, i2) {
              if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
                const t3 = !this.aborted && this.centroid;
                if (this.reset(), t3)
                  return t3;
              }
            }
          }
          class Io {
            constructor(t2) {
              this.singleTap = new Eo(t2), this.numTaps = t2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(t2, e2, i2) {
              this.singleTap.touchstart(t2, e2, i2);
            }
            touchmove(t2, e2, i2) {
              this.singleTap.touchmove(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              const o2 = this.singleTap.touchend(t2, e2, i2);
              if (o2) {
                const e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
                if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                  return this.reset(), o2;
              }
            }
          }
          class So {
            constructor() {
              this._zoomIn = new Io({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Io({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(t2, e2, i2) {
              this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
            }
            touchmove(t2, e2, i2) {
              this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              const o2 = this._zoomIn.touchend(t2, e2, i2), a2 = this._zoomOut.touchend(t2, e2, i2);
              return o2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: e3.getZoom() + 1, around: e3.unproject(o2) }, { originalEvent: t2 }) }) : a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: e3.getZoom() - 1, around: e3.unproject(a2) }, { originalEvent: t2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          const Co = { 0: 1, 2: 2 };
          class Do {
            constructor(t2) {
              this.reset(), this._clickTolerance = t2.clickTolerance || 1;
            }
            reset() {
              this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
            }
            _correctButton(t2, e2) {
              return false;
            }
            _move(t2, e2) {
              return {};
            }
            mousedown(t2, e2) {
              if (this._lastPoint)
                return;
              const i2 = s.mouseButton(t2);
              this._correctButton(t2, i2) && (this._lastPoint = e2, this._eventButton = i2);
            }
            mousemoveWindow(t2, e2) {
              const i2 = this._lastPoint;
              if (i2) {
                if (t2.preventDefault(), function(t3, e3) {
                  const i3 = Co[e3];
                  return t3.buttons === void 0 || (t3.buttons & i3) !== i3;
                }(t2, this._eventButton))
                  this.reset();
                else if (this._moved || !(e2.dist(i2) < this._clickTolerance))
                  return this._moved = true, this._lastPoint = e2, this._move(i2, e2);
              }
            }
            mouseupWindow(t2) {
              this._lastPoint && s.mouseButton(t2) === this._eventButton && (this._moved && s.suppressClick(), this.reset());
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class zo extends Do {
            mousedown(t2, e2) {
              super.mousedown(t2, e2), this._lastPoint && (this._active = true);
            }
            _correctButton(t2, e2) {
              return e2 === 0 && !t2.ctrlKey;
            }
            _move(t2, e2) {
              return { around: e2, panDelta: e2.sub(t2) };
            }
          }
          class Po extends Do {
            _correctButton(t2, e2) {
              return e2 === 0 && t2.ctrlKey || e2 === 2;
            }
            _move(t2, e2) {
              const i2 = 0.8 * (e2.x - t2.x);
              if (i2)
                return this._active = true, { bearingDelta: i2 };
            }
            contextmenu(t2) {
              t2.preventDefault();
            }
          }
          class Ao extends Do {
            _correctButton(t2, e2) {
              return e2 === 0 && t2.ctrlKey || e2 === 2;
            }
            _move(t2, e2) {
              const i2 = -0.5 * (e2.y - t2.y);
              if (i2)
                return this._active = true, { pitchDelta: i2 };
            }
            contextmenu(t2) {
              t2.preventDefault();
            }
          }
          class Mo {
            constructor(t2) {
              this._minTouches = 1, this._clickTolerance = t2.clickTolerance || 1, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t.pointGeometry(0, 0);
            }
            touchstart(t2, e2, i2) {
              return this._calculateTransform(t2, e2, i2);
            }
            touchmove(t2, e2, i2) {
              if (this._active && !(i2.length < this._minTouches))
                return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              this._calculateTransform(t2, e2, i2), this._active && i2.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e2, i2, o2) {
              o2.length > 0 && (this._active = true);
              const a2 = To(o2, i2), s2 = new t.pointGeometry(0, 0), r2 = new t.pointGeometry(0, 0);
              let n2 = 0;
              for (const t2 in a2) {
                const e3 = a2[t2], i3 = this._touches[t2];
                i3 && (s2._add(e3), r2._add(e3.sub(i3)), n2++, a2[t2] = e3);
              }
              if (this._touches = a2, n2 < this._minTouches || !r2.mag())
                return;
              const l2 = r2.div(n2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: s2.div(n2), panDelta: l2 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ro {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            _start(t2) {
            }
            _move(t2, e2, i2) {
              return {};
            }
            touchstart(t2, e2, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
            }
            touchmove(t2, e2, i2) {
              if (!this._firstTwoTouches)
                return;
              t2.preventDefault();
              const [o2, a2] = this._firstTwoTouches, s2 = Lo(i2, e2, o2), r2 = Lo(i2, e2, a2);
              if (!s2 || !r2)
                return;
              const n2 = this._aroundCenter ? null : s2.add(r2).div(2);
              return this._move([s2, r2], n2, t2);
            }
            touchend(t2, e2, i2) {
              if (!this._firstTwoTouches)
                return;
              const [o2, a2] = this._firstTwoTouches, r2 = Lo(i2, e2, o2), n2 = Lo(i2, e2, a2);
              r2 && n2 || (this._active && s.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(t2) {
              this._enabled = true, this._aroundCenter = !!t2 && t2.around === "center";
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Lo(t2, e2, i2) {
            for (let o2 = 0; o2 < t2.length; o2++)
              if (t2[o2].identifier === i2)
                return e2[o2];
          }
          function ko(t2, e2) {
            return Math.log(t2 / e2) / Math.LN2;
          }
          class Bo extends Ro {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(t2) {
              this._startDistance = this._distance = t2[0].dist(t2[1]);
            }
            _move(t2, e2) {
              const i2 = this._distance;
              if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(ko(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: ko(this._distance, i2), pinchAround: e2 };
            }
          }
          function Fo(t2, e2) {
            return 180 * t2.angleWith(e2) / Math.PI;
          }
          class Oo extends Ro {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(t2) {
              this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
            }
            _move(t2, e2) {
              const i2 = this._vector;
              if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
                return this._active = true, { bearingDelta: Fo(this._vector, i2), pinchAround: e2 };
            }
            _isBelowThreshold(t2) {
              this._minDiameter = Math.min(this._minDiameter, t2.mag());
              const e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = Fo(t2, this._startVector);
              return Math.abs(i2) < e2;
            }
          }
          function Uo(t2) {
            return Math.abs(t2.y) > Math.abs(t2.x);
          }
          class No extends Ro {
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            _start(t2) {
              this._lastPoints = t2, Uo(t2[0].sub(t2[1])) && (this._valid = false);
            }
            _move(t2, e2, i2) {
              const o2 = t2[0].sub(this._lastPoints[0]), a2 = t2[1].sub(this._lastPoints[1]);
              if (this._valid = this.gestureBeginsVertically(o2, a2, i2.timeStamp), this._valid)
                return this._lastPoints = t2, this._active = true, { pitchDelta: (o2.y + a2.y) / 2 * -0.5 };
            }
            gestureBeginsVertically(t2, e2, i2) {
              if (this._valid !== void 0)
                return this._valid;
              const o2 = t2.mag() >= 2, a2 = e2.mag() >= 2;
              if (!o2 && !a2)
                return;
              if (!o2 || !a2)
                return this._firstMove === void 0 && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const s2 = t2.y > 0 == e2.y > 0;
              return Uo(t2) && Uo(e2) && s2;
            }
          }
          const Go = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class Zo {
            constructor() {
              const t2 = Go;
              this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(t2) {
              if (t2.altKey || t2.ctrlKey || t2.metaKey)
                return;
              let e2 = 0, i2 = 0, o2 = 0, a2 = 0, s2 = 0;
              switch (t2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  e2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  e2 = -1;
                  break;
                case 37:
                  t2.shiftKey ? i2 = -1 : (t2.preventDefault(), a2 = -1);
                  break;
                case 39:
                  t2.shiftKey ? i2 = 1 : (t2.preventDefault(), a2 = 1);
                  break;
                case 38:
                  t2.shiftKey ? o2 = 1 : (t2.preventDefault(), s2 = -1);
                  break;
                case 40:
                  t2.shiftKey ? o2 = -1 : (t2.preventDefault(), s2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (r2) => {
                const n2 = r2.getZoom();
                r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: qo, zoom: e2 ? Math.round(n2) + e2 * (t2.shiftKey ? 2 : 1) : n2, bearing: r2.getBearing() + i2 * this._bearingStep, pitch: r2.getPitch() + o2 * this._pitchStep, offset: [-a2 * this._panStep, -s2 * this._panStep], center: r2.getCenter() }, { originalEvent: t2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function qo(t2) {
            return t2 * (2 - t2);
          }
          const Vo = 4.000244140625;
          class jo {
            constructor(e2, i2) {
              this._map = e2, this._el = e2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, t.bindAll(["_onTimeout"], this);
            }
            setZoomRate(t2) {
              this._defaultZoomRate = t2;
            }
            setWheelZoomRate(t2) {
              this._wheelZoomRate = t2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || this._finishTimeout !== void 0;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(t2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && t2.around === "center");
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            wheel(e2) {
              if (!this.isEnabled())
                return;
              let i2 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
              const o2 = t.exported.now(), a2 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, i2 !== 0 && i2 % Vo == 0 ? this._type = "wheel" : i2 !== 0 && Math.abs(i2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i2, this._active || this._start(e2)), e2.preventDefault();
            }
            _onTimeout(t2) {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
            }
            _start(e2) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const i2 = s.mousePos(this._el, e2);
              this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(i2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const e2 = this._map.transform;
              if (this._delta !== 0) {
                const t2 = this._type === "wheel" && Math.abs(this._delta) > Vo ? this._wheelZoomRate : this._defaultZoomRate;
                let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * t2)));
                this._delta < 0 && i3 !== 0 && (i3 = 1 / i3);
                const o3 = typeof this._targetZoom == "number" ? e2.zoomScale(this._targetZoom) : e2.scale;
                this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(o3 * i3))), this._type === "wheel" && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const i2 = typeof this._targetZoom == "number" ? this._targetZoom : e2.zoom, o2 = this._startZoom, a2 = this._easing;
              let s2, r2 = false;
              if (this._type === "wheel" && o2 && a2) {
                const e3 = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1), n2 = a2(e3);
                s2 = t.number(o2, i2, n2), e3 < 1 ? this._frameId || (this._frameId = true) : r2 = true;
              } else
                s2 = i2, r2 = true;
              return this._active = true, r2 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !r2, zoomDelta: s2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e2) {
              let i2 = t.ease;
              if (this._prevEase) {
                const e3 = this._prevEase, o2 = (t.exported.now() - e3.start) / e3.duration, a2 = e3.easing(o2 + 0.01) - e3.easing(o2), s2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, r2 = Math.sqrt(0.0729 - s2 * s2);
                i2 = t.bezier(s2, r2, 0.25, 1);
              }
              return this._prevEase = { start: t.exported.now(), duration: e2, easing: i2 }, i2;
            }
            reset() {
              this._active = false;
            }
          }
          class Xo {
            constructor(t2, e2) {
              this._clickZoom = t2, this._tapZoom = e2;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class $o {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(t2, e2) {
              return t2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e2) }, { originalEvent: t2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Wo {
            constructor() {
              this._tap = new Io({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
            }
            touchstart(t2, e2, i2) {
              this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e2, i2));
            }
            touchmove(t2, e2, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch)
                    return;
                  const o2 = e2[0], a2 = o2.y - this._swipePoint.y;
                  return this._swipePoint = o2, t2.preventDefault(), this._active = true, { zoomDelta: a2 / 128 };
                }
              } else
                this._tap.touchmove(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              this._tapTime ? this._swipePoint && i2.length === 0 && this.reset() : this._tap.touchend(t2, e2, i2) && (this._tapTime = t2.timeStamp);
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ho {
            constructor(t2, e2, i2) {
              this._el = t2, this._mousePan = e2, this._touchPan = i2;
            }
            enable(t2) {
              this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class Ko {
            constructor(t2, e2, i2) {
              this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class Yo {
            constructor(t2, e2, i2, o2) {
              this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(t2) {
              this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const Jo = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
          class Qo extends t.Event {
          }
          function ta(t2) {
            return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
          }
          class ea {
            constructor(e2, i2) {
              this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new mo(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
              const o2 = this._el;
              this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [t2, e3, i3] of this._listeners)
                s.addEventListener(t2, e3, t2 === document ? this.handleWindowEvent : this.handleEvent, i3);
            }
            destroy() {
              for (const [t2, e2, i2] of this._listeners)
                s.removeEventListener(t2, e2, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
            }
            _addDefaultHandlers(t2) {
              const e2 = this._map, i2 = e2.getCanvasContainer();
              this._add("mapEvent", new yo(e2, t2));
              const o2 = e2.boxZoom = new wo(e2, t2);
              this._add("boxZoom", o2);
              const a2 = new So(), s2 = new $o();
              e2.doubleClickZoom = new Xo(s2, a2), this._add("tapZoom", a2), this._add("clickZoom", s2);
              const r2 = new Wo();
              this._add("tapDragZoom", r2);
              const n2 = e2.touchPitch = new No();
              this._add("touchPitch", n2);
              const l2 = new Po(t2), c2 = new Ao(t2);
              e2.dragRotate = new Ko(t2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
              const h2 = new zo(t2), u2 = new Mo(t2);
              e2.dragPan = new Ho(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
              const d2 = new Oo(), _2 = new Bo();
              e2.touchZoomRotate = new Yo(i2, _2, d2, r2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]);
              const m2 = e2.scrollZoom = new jo(e2, this);
              this._add("scrollZoom", m2, ["mousePan"]);
              const p2 = e2.keyboard = new Zo();
              this._add("keyboard", p2), this._add("blockableMapEvent", new bo(e2));
              for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                t2.interactive && t2[i3] && e2[i3].enable(t2[i3]);
            }
            _add(t2, e2, i2) {
              this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
            }
            stop(t2) {
              if (!this._updatingCamera) {
                for (const { handler: t3 } of this._handlers)
                  t3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: t2 } of this._handlers)
                if (t2.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(Jo(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(t2, e2, i2) {
              for (const o2 in t2)
                if (o2 !== i2 && (!e2 || e2.indexOf(o2) < 0))
                  return true;
              return false;
            }
            handleWindowEvent(t2) {
              this.handleEvent(t2, `${t2.type}Window`);
            }
            _getMapTouches(t2) {
              const e2 = [];
              for (const i2 of t2)
                this._el.contains(i2.target) && e2.push(i2);
              return e2;
            }
            handleEvent(t2, e2) {
              if (t2.type === "blur")
                return void this.stop(true);
              this._updatingCamera = true;
              const i2 = t2.type === "renderFrame" ? void 0 : t2, o2 = { needsRenderFrame: false }, a2 = {}, r2 = {}, n2 = t2.touches, l2 = n2 ? this._getMapTouches(n2) : void 0, c2 = l2 ? s.touchPos(this._el, l2) : s.mousePos(this._el, t2);
              for (const { handlerName: s2, handler: n3, allowed: h3 } of this._handlers) {
                if (!n3.isEnabled())
                  continue;
                let u3;
                this._blockedByActive(r2, h3, s2) ? n3.reset() : n3[e2 || t2.type] && (u3 = n3[e2 || t2.type](t2, c2, l2), this.mergeHandlerResult(o2, a2, u3, s2, i2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (r2[s2] = n3);
              }
              const h2 = {};
              for (const t3 in this._previousActiveHandlers)
                r2[t3] || (h2[t3] = i2);
              this._previousActiveHandlers = r2, (Object.keys(h2).length || ta(o2)) && (this._changes.push([o2, a2, h2]), this._triggerRenderFrame()), (Object.keys(r2).length || ta(o2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u2 } = o2;
              u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
            }
            mergeHandlerResult(e2, i2, o2, a2, s2) {
              if (!o2)
                return;
              t.extend(e2, o2);
              const r2 = { handlerName: a2, originalEvent: o2.originalEvent || s2 };
              o2.zoomDelta !== void 0 && (i2.zoom = r2), o2.panDelta !== void 0 && (i2.drag = r2), o2.pitchDelta !== void 0 && (i2.pitch = r2), o2.bearingDelta !== void 0 && (i2.rotate = r2);
            }
            _applyChanges() {
              const e2 = {}, i2 = {}, o2 = {};
              for (const [a2, s2, r2] of this._changes)
                a2.panDelta && (e2.panDelta = (e2.panDelta || new t.pointGeometry(0, 0))._add(a2.panDelta)), a2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + a2.zoomDelta), a2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + a2.bearingDelta), a2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + a2.pitchDelta), a2.around !== void 0 && (e2.around = a2.around), a2.pinchAround !== void 0 && (e2.pinchAround = a2.pinchAround), a2.noInertia && (e2.noInertia = a2.noInertia), t.extend(i2, s2), t.extend(o2, r2);
              this._updateMapTransform(e2, i2, o2), this._changes = [];
            }
            _updateMapTransform(e2, i2, o2) {
              const a2 = this._map, s2 = a2.transform, r2 = a2.style && a2.style.terrain;
              if (!(ta(e2) || r2 && this._drag))
                return this._fireEvents(i2, o2, true);
              let { panDelta: n2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, pinchAround: d2 } = e2;
              d2 !== void 0 && (u2 = d2), a2._stop(true), u2 = u2 || a2.transform.centerPoint;
              const _2 = s2.pointLocation(n2 ? u2.sub(n2) : u2);
              c2 && (s2.bearing += c2), h2 && (s2.pitch += h2), l2 && (s2.zoom += l2), r2 ? i2.drag && !this._drag ? (this._drag = { center: s2.centerPoint, lngLat: s2.pointLocation(u2), point: u2, handlerName: i2.drag.handlerName }, a2.fire(new t.Event("freezeElevation", { freeze: true }))) : this._drag && o2[this._drag.handlerName] ? (a2.fire(new t.Event("freezeElevation", { freeze: false })), this._drag = null) : i2.drag && this._drag && (s2.center = s2.pointLocation(s2.centerPoint.sub(n2))) : s2.setLocationAtPoint(_2, u2), this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(i2, o2, true);
            }
            _fireEvents(e2, i2, o2) {
              const a2 = Jo(this._eventsInProgress), s2 = Jo(e2), r2 = {};
              for (const t2 in e2) {
                const { originalEvent: i3 } = e2[t2];
                this._eventsInProgress[t2] || (r2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
              }
              !a2 && s2 && this._fireEvent("movestart", s2.originalEvent);
              for (const t2 in r2)
                this._fireEvent(t2, r2[t2]);
              s2 && this._fireEvent("move", s2.originalEvent);
              for (const t2 in e2) {
                const { originalEvent: i3 } = e2[t2];
                this._fireEvent(t2, i3);
              }
              const n2 = {};
              let l2;
              for (const t2 in this._eventsInProgress) {
                const { handlerName: e3, originalEvent: o3 } = this._eventsInProgress[t2];
                this._handlersById[e3].isActive() || (delete this._eventsInProgress[t2], l2 = i2[e3] || o3, n2[`${t2}end`] = l2);
              }
              for (const t2 in n2)
                this._fireEvent(t2, n2[t2]);
              const c2 = Jo(this._eventsInProgress);
              if (o2 && (a2 || s2) && !c2) {
                this._updatingCamera = true;
                const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t2) => t2 !== 0 && -this._bearingSnap < t2 && t2 < this._bearingSnap;
                e3 ? (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), this._map.easeTo(e3, { originalEvent: l2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(e2, i2) {
              this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
                delete this._frameId, this.handleEvent(new Qo("renderFrame", { timeStamp: t2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              this._frameId === void 0 && (this._frameId = this._requestFrame());
            }
          }
          const ia = { extend: (e2, ...i2) => t.extend(e2, ...i2), run(t2) {
            t2();
          }, logToElement(t2, e2 = false, i2 = "log") {
            const o2 = window.document.getElementById(i2);
            o2 && (e2 && (o2.innerHTML = ""), o2.innerHTML += `<br>${t2}`);
          } };
          class oa extends t.Evented {
            constructor(e2, i2) {
              super(), this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
            }
            getCenter() {
              return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(t2, e2) {
              return this.jumpTo({ center: t2 }, e2);
            }
            panBy(e2, i2, o2) {
              return e2 = t.pointGeometry.convert(e2).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e2 }, i2), o2);
            }
            panTo(e2, i2, o2) {
              return this.easeTo(t.extend({ center: e2 }, i2), o2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(t2, e2) {
              return this.jumpTo({ zoom: t2 }, e2), this;
            }
            zoomTo(e2, i2, o2) {
              return this.easeTo(t.extend({ zoom: e2 }, i2), o2);
            }
            zoomIn(t2, e2) {
              return this.zoomTo(this.getZoom() + 1, t2, e2), this;
            }
            zoomOut(t2, e2) {
              return this.zoomTo(this.getZoom() - 1, t2, e2), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(t2, e2) {
              return this.jumpTo({ bearing: t2 }, e2), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(t2, e2) {
              return this.jumpTo({ padding: t2 }, e2), this;
            }
            rotateTo(e2, i2, o2) {
              return this.easeTo(t.extend({ bearing: e2 }, i2), o2);
            }
            resetNorth(e2, i2) {
              return this.rotateTo(0, t.extend({ duration: 1e3 }, e2), i2), this;
            }
            resetNorthPitch(e2, i2) {
              return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e2), i2), this;
            }
            snapToNorth(t2, e2) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(t2, e2) {
              return this.jumpTo({ pitch: t2 }, e2), this;
            }
            cameraForBounds(e2, i2) {
              e2 = t.LngLatBounds.convert(e2);
              const o2 = i2 && i2.bearing || 0;
              return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), o2, i2);
            }
            _cameraForBoxAndBearing(e2, i2, o2, a2) {
              const s2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if (typeof (a2 = t.extend({ padding: s2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a2)).padding == "number") {
                const t2 = a2.padding;
                a2.padding = { top: t2, bottom: t2, right: t2, left: t2 };
              }
              a2.padding = t.extend(s2, a2.padding);
              const r2 = this.transform, n2 = r2.padding, l2 = r2.project(t.LngLat.convert(e2)), c2 = r2.project(t.LngLat.convert(i2)), h2 = l2.rotate(-o2 * Math.PI / 180), u2 = c2.rotate(-o2 * Math.PI / 180), d2 = new t.pointGeometry(Math.max(h2.x, u2.x), Math.max(h2.y, u2.y)), _2 = new t.pointGeometry(Math.min(h2.x, u2.x), Math.min(h2.y, u2.y)), m2 = d2.sub(_2), p2 = (r2.width - (n2.left + n2.right + a2.padding.left + a2.padding.right)) / m2.x, f2 = (r2.height - (n2.top + n2.bottom + a2.padding.top + a2.padding.bottom)) / m2.y;
              if (f2 < 0 || p2 < 0)
                return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              const g2 = Math.min(r2.scaleZoom(r2.scale * Math.min(p2, f2)), a2.maxZoom), x2 = t.pointGeometry.convert(a2.offset), v2 = new t.pointGeometry((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y2 = x2.add(v2).mult(r2.scale / r2.zoomScale(g2));
              return { center: r2.unproject(l2.add(c2).div(2).sub(y2)), zoom: g2, bearing: o2 };
            }
            fitBounds(t2, e2, i2) {
              return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
            }
            fitScreenCoordinates(e2, i2, o2, a2, s2) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e2)), this.transform.pointLocation(t.pointGeometry.convert(i2)), o2, a2), a2, s2);
            }
            _fitInternal(e2, i2, o2) {
              return e2 ? (delete (i2 = t.extend(e2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
            }
            jumpTo(e2, i2) {
              this.stop();
              const o2 = this.transform;
              let a2 = false, s2 = false, r2 = false;
              return "zoom" in e2 && o2.zoom !== +e2.zoom && (a2 = true, o2.zoom = +e2.zoom), e2.center !== void 0 && (o2.center = t.LngLat.convert(e2.center)), "bearing" in e2 && o2.bearing !== +e2.bearing && (s2 = true, o2.bearing = +e2.bearing), "pitch" in e2 && o2.pitch !== +e2.pitch && (r2 = true, o2.pitch = +e2.pitch), e2.padding == null || o2.isPaddingEqual(e2.padding) || (o2.padding = e2.padding), this.fire(new t.Event("movestart", i2)).fire(new t.Event("move", i2)), a2 && this.fire(new t.Event("zoomstart", i2)).fire(new t.Event("zoom", i2)).fire(new t.Event("zoomend", i2)), s2 && this.fire(new t.Event("rotatestart", i2)).fire(new t.Event("rotate", i2)).fire(new t.Event("rotateend", i2)), r2 && this.fire(new t.Event("pitchstart", i2)).fire(new t.Event("pitch", i2)).fire(new t.Event("pitchend", i2)), this.fire(new t.Event("moveend", i2));
            }
            easeTo(e2, i2) {
              this._stop(false, e2.easeId), ((e2 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e2)).animate === false || !e2.essential && t.exported.prefersReducedMotion) && (e2.duration = 0);
              const o2 = this.transform, a2 = this.getZoom(), s2 = this.getBearing(), r2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e2 ? +e2.zoom : a2, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, s2) : s2, h2 = "pitch" in e2 ? +e2.pitch : r2, u2 = "padding" in e2 ? e2.padding : o2.padding, d2 = t.pointGeometry.convert(e2.offset);
              let _2 = o2.centerPoint.add(d2);
              const m2 = o2.pointLocation(_2), p2 = t.LngLat.convert(e2.center || m2);
              this._normalizeCenter(p2);
              const f2 = o2.project(m2), g2 = o2.project(p2).sub(f2), x2 = o2.zoomScale(l2 - a2);
              let v2, y2;
              e2.around && (v2 = t.LngLat.convert(e2.around), y2 = o2.locationPoint(v2));
              const b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = this._zooming || l2 !== a2, this._rotating = this._rotating || s2 !== c2, this._pitching = this._pitching || h2 !== r2, this._padding = !o2.isPaddingEqual(u2), this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, b2), this._ease((e3) => {
                if (this._zooming && (o2.zoom = t.number(a2, l2, e3)), this._rotating && (o2.bearing = t.number(s2, c2, e3)), this._pitching && (o2.pitch = t.number(r2, h2, e3)), this._padding && (o2.interpolatePadding(n2, u2, e3), _2 = o2.centerPoint.add(d2)), v2)
                  o2.setLocationAtPoint(v2, y2);
                else {
                  const t2 = o2.zoomScale(o2.zoom - a2), i3 = l2 > a2 ? Math.min(2, x2) : Math.max(0.5, x2), s3 = Math.pow(i3, 1 - e3), r3 = o2.unproject(f2.add(g2.mult(e3 * s3)).mult(t2));
                  o2.setLocationAtPoint(o2.renderWorldCopies ? r3.wrap() : r3, _2);
                }
                this._fireMoveEvents(i2);
              }, (t2) => {
                this._afterEase(i2, t2);
              }, e2), this;
            }
            _prepareEase(e2, i2, o2 = {}) {
              this._moving = true, this.fire(new t.Event("freezeElevation", { freeze: true })), i2 || o2.moving || this.fire(new t.Event("movestart", e2)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e2)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e2)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e2));
            }
            _fireMoveEvents(e2) {
              this.fire(new t.Event("move", e2)), this._zooming && this.fire(new t.Event("zoom", e2)), this._rotating && this.fire(new t.Event("rotate", e2)), this._pitching && this.fire(new t.Event("pitch", e2));
            }
            _afterEase(e2, i2) {
              if (this._easeId && i2 && this._easeId === i2)
                return;
              delete this._easeId, this.fire(new t.Event("freezeElevation", { freeze: false }));
              const o2 = this._zooming, a2 = this._rotating, s2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e2)), a2 && this.fire(new t.Event("rotateend", e2)), s2 && this.fire(new t.Event("pitchend", e2)), this.fire(new t.Event("moveend", e2));
            }
            flyTo(e2, i2) {
              if (!e2.essential && t.exported.prefersReducedMotion) {
                const o3 = t.pick(e2, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(o3, i2);
              }
              this.stop(), e2 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e2);
              const o2 = this.transform, a2 = this.getZoom(), s2 = this.getBearing(), r2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e2 ? t.clamp(+e2.zoom, o2.minZoom, o2.maxZoom) : a2, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, s2) : s2, h2 = "pitch" in e2 ? +e2.pitch : r2, u2 = "padding" in e2 ? e2.padding : o2.padding, d2 = o2.zoomScale(l2 - a2), _2 = t.pointGeometry.convert(e2.offset);
              let m2 = o2.centerPoint.add(_2);
              const p2 = o2.pointLocation(m2), f2 = t.LngLat.convert(e2.center || p2);
              this._normalizeCenter(f2);
              const g2 = o2.project(p2), x2 = o2.project(f2).sub(g2);
              let v2 = e2.curve;
              const y2 = Math.max(o2.width, o2.height), b2 = y2 / d2, w2 = x2.mag();
              if ("minZoom" in e2) {
                const i3 = t.clamp(Math.min(e2.minZoom, a2, l2), o2.minZoom, o2.maxZoom), s3 = y2 / o2.zoomScale(i3 - a2);
                v2 = Math.sqrt(s3 / w2 * 2);
              }
              const T2 = v2 * v2;
              function E2(t2) {
                const e3 = (b2 * b2 - y2 * y2 + (t2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (t2 ? b2 : y2) * T2 * w2);
                return Math.log(Math.sqrt(e3 * e3 + 1) - e3);
              }
              function I2(t2) {
                return (Math.exp(t2) - Math.exp(-t2)) / 2;
              }
              function S2(t2) {
                return (Math.exp(t2) + Math.exp(-t2)) / 2;
              }
              const C2 = E2(0);
              let D2 = function(t2) {
                return S2(C2) / S2(C2 + v2 * t2);
              }, z2 = function(t2) {
                return y2 * ((S2(C2) * (I2(e3 = C2 + v2 * t2) / S2(e3)) - I2(C2)) / T2) / w2;
                var e3;
              }, P2 = (E2(1) - C2) / v2;
              if (Math.abs(w2) < 1e-6 || !isFinite(P2)) {
                if (Math.abs(y2 - b2) < 1e-6)
                  return this.easeTo(e2, i2);
                const t2 = b2 < y2 ? -1 : 1;
                P2 = Math.abs(Math.log(b2 / y2)) / v2, z2 = function() {
                  return 0;
                }, D2 = function(e3) {
                  return Math.exp(t2 * v2 * e3);
                };
              }
              return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * P2 / ("screenSpeed" in e2 ? +e2.screenSpeed / v2 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = s2 !== c2, this._pitching = h2 !== r2, this._padding = !o2.isPaddingEqual(u2), this._prepareEase(i2, false), this._ease((e3) => {
                const d3 = e3 * P2, p3 = 1 / D2(d3);
                o2.zoom = e3 === 1 ? l2 : a2 + o2.scaleZoom(p3), this._rotating && (o2.bearing = t.number(s2, c2, e3)), this._pitching && (o2.pitch = t.number(r2, h2, e3)), this._padding && (o2.interpolatePadding(n2, u2, e3), m2 = o2.centerPoint.add(_2));
                const v3 = e3 === 1 ? f2 : o2.unproject(g2.add(x2.mult(z2(d3))).mult(p3));
                o2.setLocationAtPoint(o2.renderWorldCopies ? v3.wrap() : v3, m2), this._fireMoveEvents(i2);
              }, () => this._afterEase(i2), e2), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(t2, e2) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const t3 = this._onEaseEnd;
                delete this._onEaseEnd, t3.call(this, e2);
              }
              if (!t2) {
                const t3 = this.handlers;
                t3 && t3.stop(false);
              }
              return this;
            }
            _ease(e2, i2, o2) {
              o2.animate === false || o2.duration === 0 ? (e2(1), i2()) : (this._easeStart = t.exported.now(), this._easeOptions = o2, this._onEaseFrame = e2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
              const e2 = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e2)), e2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(e2, i2) {
              e2 = t.wrap(e2, -180, 180);
              const o2 = Math.abs(e2 - i2);
              return Math.abs(e2 - 360 - i2) < o2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < o2 && (e2 += 360), e2;
            }
            _normalizeCenter(t2) {
              const e2 = this.transform;
              if (!e2.renderWorldCopies || e2.lngRange)
                return;
              const i2 = t2.lng - e2.center.lng;
              t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
            }
          }
          class aa {
            constructor(e2 = {}) {
              this.options = e2, t.bindAll(["_toggleAttribution", "_updateData", "_updateCompact", "_updateCompactMinimize"], this);
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(t2) {
              return this._map = t2, this._compact = this.options && this.options.compact, this._container = s.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = s.create("summary", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = s.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
              s.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(t2, e2) {
              const i2 = this._map._getUIString(`AttributionControl.${e2}`);
              t2.title = i2, t2.setAttribute("aria-label", i2);
            }
            _toggleAttribution() {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._container.removeAttribute("open")));
            }
            _updateData(t2) {
              !t2 || t2.sourceDataType !== "metadata" && t2.sourceDataType !== "visibility" && t2.dataType !== "style" || this._updateAttributions();
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let t2 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => typeof t3 != "string" ? "" : t3)) : typeof this.options.customAttribution == "string" && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const t3 = this._map.style.stylesheet;
                this.styleOwner = t3.owner, this.styleId = t3.id;
              }
              const e2 = this._map.style.sourceCaches;
              for (const i3 in e2) {
                const o2 = e2[i3];
                if (o2.used) {
                  const e3 = o2.getSource();
                  e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
                }
              }
              t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
                for (let o2 = i3 + 1; o2 < t2.length; o2++)
                  if (t2[o2].indexOf(e3) >= 0)
                    return false;
                return true;
              });
              const i2 = t2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
            _updateCompact() {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "mapboxgl-compact", "maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show"));
            }
            _updateCompactMinimize() {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show");
            }
          }
          class sa {
            constructor(e2 = {}) {
              this.options = e2, t.bindAll(["_updateCompact"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(t2) {
              this._map = t2, this._compact = this.options && this.options.compact, this._container = s.create("div", "maplibregl-ctrl mapboxgl-ctrl");
              const e2 = s.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");
              return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              s.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
            _updateCompact() {
              const t2 = this._container.children;
              if (t2.length) {
                const e2 = t2[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && e2.classList.add("maplibregl-compact", "mapboxgl-compact") : e2.classList.remove("maplibregl-compact", "mapboxgl-compact");
              }
            }
          }
          class ra {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(t2) {
              const e2 = ++this._id;
              return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
            }
            remove(t2) {
              const e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
              for (const e3 of i2)
                if (e3.id === t2)
                  return void (e3.cancelled = true);
            }
            run(t2 = 0) {
              const e2 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of e2)
                if (!i2.cancelled && (i2.callback(t2), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          const na = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" }, la = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, fadeDuration: 300, crossSourceCollisions: true }, ca = { showCompass: true, showZoom: true, visualizePitch: false };
          class ha {
            constructor(e2, i2, o2 = false) {
              this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Po({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, o2 && (this.mousePitch = new Ao({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), s.addEventListener(i2, "mousedown", this.mousedown), s.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), s.addEventListener(i2, "touchmove", this.touchmove), s.addEventListener(i2, "touchend", this.touchend), s.addEventListener(i2, "touchcancel", this.reset);
            }
            down(t2, e2) {
              this.mouseRotate.mousedown(t2, e2), this.mousePitch && this.mousePitch.mousedown(t2, e2), s.disableDrag();
            }
            move(t2, e2) {
              const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e2);
              if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
                const o3 = this.mousePitch.mousemoveWindow(t2, e2);
                o3 && o3.pitchDelta && i2.setPitch(i2.getPitch() + o3.pitchDelta);
              }
            }
            off() {
              const t2 = this.element;
              s.removeEventListener(t2, "mousedown", this.mousedown), s.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), s.removeEventListener(t2, "touchmove", this.touchmove), s.removeEventListener(t2, "touchend", this.touchend), s.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              s.enableDrag(), s.removeEventListener(window, "mousemove", this.mousemove), s.removeEventListener(window, "mouseup", this.mouseup);
            }
            mousedown(e2) {
              this.down(t.extend({}, e2, { ctrlKey: true, preventDefault: () => e2.preventDefault() }), s.mousePos(this.element, e2)), s.addEventListener(window, "mousemove", this.mousemove), s.addEventListener(window, "mouseup", this.mouseup);
            }
            mousemove(t2) {
              this.move(t2, s.mousePos(this.element, t2));
            }
            mouseup(t2) {
              this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
            }
            touchstart(t2) {
              t2.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = s.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => t2.preventDefault() }, this._startPos));
            }
            touchmove(t2) {
              t2.targetTouches.length !== 1 ? this.reset() : (this._lastPos = s.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: () => t2.preventDefault() }, this._lastPos));
            }
            touchend(t2) {
              t2.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
          }
          function ua(e2, i2, o2) {
            if (e2 = new t.LngLat(e2.lng, e2.lat), i2) {
              const a2 = new t.LngLat(e2.lng - 360, e2.lat), s2 = new t.LngLat(e2.lng + 360, e2.lat), r2 = o2.locationPoint(e2).distSqr(i2);
              o2.locationPoint(a2).distSqr(i2) < r2 ? e2 = a2 : o2.locationPoint(s2).distSqr(i2) < r2 && (e2 = s2);
            }
            for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
              const t2 = o2.locationPoint(e2);
              if (t2.x >= 0 && t2.y >= 0 && t2.x <= o2.width && t2.y <= o2.height)
                break;
              e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
            }
            return e2;
          }
          const da = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function _a(t2, e2, i2) {
            const o2 = t2.classList;
            for (const t3 in da)
              o2.remove(`maplibregl-${i2}-anchor-${t3}`, `mapboxgl-${i2}-anchor-${t3}`);
            o2.add(`maplibregl-${i2}-anchor-${e2}`, `mapboxgl-${i2}-anchor-${e2}`);
          }
          class ma extends t.Evented {
            constructor(e2, i2) {
              if (super(), (e2 instanceof HTMLElement || i2) && (e2 = t.extend({ element: e2 }, i2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && e2.pitchAlignment !== "auto" ? e2.pitchAlignment : this._rotationAlignment, e2 && e2.element)
                this._element = e2.element, this._offset = t.pointGeometry.convert(e2 && e2.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = s.create("div"), this._element.setAttribute("aria-label", "Map marker");
                const i3 = s.createNS("http://www.w3.org/2000/svg", "svg"), o2 = 41, a2 = 27;
                i3.setAttributeNS(null, "display", "block"), i3.setAttributeNS(null, "height", `${o2}px`), i3.setAttributeNS(null, "width", `${a2}px`), i3.setAttributeNS(null, "viewBox", `0 0 ${a2} ${o2}`);
                const r2 = s.createNS("http://www.w3.org/2000/svg", "g");
                r2.setAttributeNS(null, "stroke", "none"), r2.setAttributeNS(null, "stroke-width", "1"), r2.setAttributeNS(null, "fill", "none"), r2.setAttributeNS(null, "fill-rule", "evenodd");
                const n2 = s.createNS("http://www.w3.org/2000/svg", "g");
                n2.setAttributeNS(null, "fill-rule", "nonzero");
                const l2 = s.createNS("http://www.w3.org/2000/svg", "g");
                l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
                const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const t2 of c2) {
                  const e3 = s.createNS("http://www.w3.org/2000/svg", "ellipse");
                  e3.setAttributeNS(null, "opacity", "0.04"), e3.setAttributeNS(null, "cx", "10.5"), e3.setAttributeNS(null, "cy", "5.80029008"), e3.setAttributeNS(null, "rx", t2.rx), e3.setAttributeNS(null, "ry", t2.ry), l2.appendChild(e3);
                }
                const h2 = s.createNS("http://www.w3.org/2000/svg", "g");
                h2.setAttributeNS(null, "fill", this._color);
                const u2 = s.createNS("http://www.w3.org/2000/svg", "path");
                u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
                const d2 = s.createNS("http://www.w3.org/2000/svg", "g");
                d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
                const _2 = s.createNS("http://www.w3.org/2000/svg", "path");
                _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
                const m2 = s.createNS("http://www.w3.org/2000/svg", "g");
                m2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), m2.setAttributeNS(null, "fill", "#FFFFFF");
                const p2 = s.createNS("http://www.w3.org/2000/svg", "g");
                p2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f2 = s.createNS("http://www.w3.org/2000/svg", "circle");
                f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
                const g2 = s.createNS("http://www.w3.org/2000/svg", "circle");
                g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), p2.appendChild(f2), p2.appendChild(g2), n2.appendChild(l2), n2.appendChild(h2), n2.appendChild(d2), n2.appendChild(m2), n2.appendChild(p2), i3.appendChild(n2), i3.setAttributeNS(null, "height", o2 * this._scale + "px"), i3.setAttributeNS(null, "width", a2 * this._scale + "px"), this._element.appendChild(i3), this._offset = t.pointGeometry.convert(e2 && e2.offset || [0, -14]);
              }
              this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", (t2) => {
                t2.preventDefault();
              }), this._element.addEventListener("mousedown", (t2) => {
                t2.preventDefault();
              }), _a(this._element, this._anchor, "marker"), this._popup = null;
            }
            addTo(t2) {
              return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), s.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e2) {
              return this._lngLat = t.LngLat.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(t2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
                if (!("offset" in t2.options)) {
                  const e2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                  t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [o2, -1 * (e2 - i2 + o2)], "bottom-right": [-o2, -1 * (e2 - i2 + o2)], left: [i2, -1 * (e2 - i2)], right: [-i2, -1 * (e2 - i2)] } : this._offset;
                }
                this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            _onKeyPress(t2) {
              const e2 = t2.code, i2 = t2.charCode || t2.keyCode;
              e2 !== "Space" && e2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
            }
            _onMapClick(t2) {
              const e2 = t2.originalEvent.target, i2 = this._element;
              this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const t2 = this._popup;
              return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
            }
            _update(t2) {
              if (!this._map)
                return;
              this._map.transform.renderWorldCopies && (this._lngLat = ua(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              let e2 = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? e2 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (e2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let i2 = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? i2 = "rotateX(0deg)" : this._pitchAlignment === "map" && (i2 = `rotateX(${this._map.getPitch()}deg)`), t2 && t2.type !== "moveend" || (this._pos = this._pos.round()), s.setTransform(this._element, `${da[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i2} ${e2}`), this._map.style && this._map.style.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                const t3 = this._map.unproject(this._pos), e3 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                this._element.style.opacity = t3.distanceTo(this._lngLat) > 20 * e3 ? "0.2" : "1.0", this._opacityTimeout = null;
              }, 100));
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e2) {
              return this._offset = t.pointGeometry.convert(e2), this._update(), this;
            }
            _onMove(e2) {
              if (!this._isDragging) {
                const t2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e2.point.dist(this._pointerdownPos) >= t2;
              }
              this._isDragging && (this._pos = e2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
            }
            _onUp() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new t.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(t2) {
              this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }
            setDraggable(t2) {
              return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(t2) {
              return this._rotation = t2 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(t2) {
              return this._rotationAlignment = t2 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(t2) {
              return this._pitchAlignment = t2 && t2 !== "auto" ? t2 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
          }
          const pa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
          let fa, ga = 0, xa = false;
          const va = { maxWidth: 100, unit: "metric" };
          function ya(t2, e2, i2) {
            const o2 = i2 && i2.maxWidth || 100, a2 = t2._container.clientHeight / 2, s2 = t2.unproject([0, a2]), r2 = t2.unproject([o2, a2]), n2 = s2.distanceTo(r2);
            if (i2 && i2.unit === "imperial") {
              const i3 = 3.2808 * n2;
              i3 > 5280 ? ba(e2, o2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : ba(e2, o2, i3, t2._getUIString("ScaleControl.Feet"));
            } else
              i2 && i2.unit === "nautical" ? ba(e2, o2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? ba(e2, o2, n2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : ba(e2, o2, n2, t2._getUIString("ScaleControl.Meters"));
          }
          function ba(t2, e2, i2, o2) {
            const a2 = function(t3) {
              const e3 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
              let i3 = t3 / e3;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
                const e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
                return Math.round(t4 * e4) / e4;
              }(i3), e3 * i3;
            }(i2);
            t2.style.width = e2 * (a2 / i2) + "px", t2.innerHTML = `${a2}&nbsp;${o2}`;
          }
          const wa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Ta = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function Ea(e2) {
            if (e2) {
              if (typeof e2 == "number") {
                const i2 = Math.round(Math.sqrt(0.5 * Math.pow(e2, 2)));
                return { center: new t.pointGeometry(0, 0), top: new t.pointGeometry(0, e2), "top-left": new t.pointGeometry(i2, i2), "top-right": new t.pointGeometry(-i2, i2), bottom: new t.pointGeometry(0, -e2), "bottom-left": new t.pointGeometry(i2, -i2), "bottom-right": new t.pointGeometry(-i2, -i2), left: new t.pointGeometry(e2, 0), right: new t.pointGeometry(-e2, 0) };
              }
              if (e2 instanceof t.pointGeometry || Array.isArray(e2)) {
                const i2 = t.pointGeometry.convert(e2);
                return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
              }
              return { center: t.pointGeometry.convert(e2.center || [0, 0]), top: t.pointGeometry.convert(e2.top || [0, 0]), "top-left": t.pointGeometry.convert(e2["top-left"] || [0, 0]), "top-right": t.pointGeometry.convert(e2["top-right"] || [0, 0]), bottom: t.pointGeometry.convert(e2.bottom || [0, 0]), "bottom-left": t.pointGeometry.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.pointGeometry.convert(e2["bottom-right"] || [0, 0]), left: t.pointGeometry.convert(e2.left || [0, 0]), right: t.pointGeometry.convert(e2.right || [0, 0]) };
            }
            return Ea(new t.pointGeometry(0, 0));
          }
          const Ia = { supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: class extends oa {
            constructor(e2) {
              var i2;
              if (t.PerformanceUtils.mark(t.PerformanceMarkers.create), (e2 = t.extend({}, la, e2)).minZoom != null && e2.maxZoom != null && e2.minZoom > e2.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (e2.minPitch != null && e2.maxPitch != null && e2.minPitch > e2.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (e2.minPitch != null && e2.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (e2.maxPitch != null && e2.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (super(new ro(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies), { bearingSnap: e2.bearingSnap }), this._interactive = e2.interactive, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new ra(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, na, e2.locale), this._clickTolerance = e2.clickTolerance, this._pixelRatio = (i2 = e2.pixelRatio) !== null && i2 !== void 0 ? i2 : devicePixelRatio, this._requestManager = new r(e2.transformRequest), typeof e2.container == "string") {
                if (this._container = document.getElementById(e2.container), !this._container)
                  throw new Error(`Container '${e2.container}' not found.`);
              } else {
                if (!(e2.container instanceof HTMLElement))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e2.container;
              }
              if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
                throw new Error("Failed to initialize WebGL.");
              this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
                this.painter.terrainFacilitator.dirty = true, this._update(true);
              }), typeof window != "undefined" && (addEventListener("online", this._onWindowOnline, false), addEventListener("resize", this._onWindowResize, false), addEventListener("orientationchange", this._onWindowResize, false)), this.handlers = new ea(this, e2), this._hash = e2.hash && new no(typeof e2.hash == "string" && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new aa({ customAttribution: e2.customAttribution })), e2.maplibreLogo && this.addControl(new sa(), e2.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet);
              }), this.on("data", (e3) => {
                this._update(e3.dataType === "style"), this.fire(new t.Event(`${e3.dataType}data`, e3));
              }), this.on("dataloading", (e3) => {
                this.fire(new t.Event(`${e3.dataType}dataloading`, e3));
              }), this.on("dataabort", (e3) => {
                this.fire(new t.Event("sourcedataabort", e3));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e2, i2) {
              if (i2 === void 0 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const o2 = e2.onAdd(this);
              this._controls.push(e2);
              const a2 = this._controlPositions[i2];
              return i2.indexOf("bottom") !== -1 ? a2.insertBefore(o2, a2.firstChild) : a2.appendChild(o2), this;
            }
            removeControl(e2) {
              if (!e2 || !e2.onRemove)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(e2);
              return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
            }
            hasControl(t2) {
              return this._controls.indexOf(t2) > -1;
            }
            resize(e2) {
              const i2 = this._containerDimensions(), o2 = i2[0], a2 = i2[1];
              this._resizeCanvas(o2, a2, this.getPixelRatio()), this.transform.resize(o2, a2), this.painter.resize(o2, a2, this.getPixelRatio());
              const s2 = !this._moving;
              return s2 && (this.stop(), this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2))), this.fire(new t.Event("resize", e2)), s2 && this.fire(new t.Event("moveend", e2)), this;
            }
            getPixelRatio() {
              return this._pixelRatio;
            }
            setPixelRatio(t2) {
              const [e2, i2] = this._containerDimensions();
              this._pixelRatio = t2, this._resizeCanvas(e2, i2, t2), this.painter.resize(e2, i2, t2);
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(e2) {
              return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
            }
            setMinZoom(t2) {
              if ((t2 = t2 == null ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
                return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t2) {
              if ((t2 = t2 == null ? 22 : t2) >= this.transform.minZoom)
                return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t2) {
              if ((t2 = t2 == null ? 0 : t2) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch)
                return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t2) {
              if ((t2 = t2 == null ? 60 : t2) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2 >= this.transform.minPitch)
                return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(t2) {
              return this.transform.renderWorldCopies = t2, this._update();
            }
            project(e2) {
              return this.transform.locationPoint(t.LngLat.convert(e2), this.style && this.style.terrain);
            }
            unproject(e2) {
              return this.transform.pointLocation(t.pointGeometry.convert(e2), this.style && this.style.terrain);
            }
            isMoving() {
              return this._moving || this.handlers.isMoving();
            }
            isZooming() {
              return this._zooming || this.handlers.isZooming();
            }
            isRotating() {
              return this._rotating || this.handlers.isRotating();
            }
            _createDelegatedListener(t2, e2, i2) {
              if (t2 === "mouseenter" || t2 === "mouseover") {
                let o2 = false;
                const a2 = (a3) => {
                  const s2 = this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : [];
                  s2.length ? o2 || (o2 = true, i2.call(this, new go(t2, this, a3.originalEvent, { features: s2 }))) : o2 = false;
                };
                return { layer: e2, listener: i2, delegates: { mousemove: a2, mouseout: () => {
                  o2 = false;
                } } };
              }
              if (t2 === "mouseleave" || t2 === "mouseout") {
                let o2 = false;
                const a2 = (a3) => {
                  (this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new go(t2, this, a3.originalEvent)));
                }, s2 = (e3) => {
                  o2 && (o2 = false, i2.call(this, new go(t2, this, e3.originalEvent)));
                };
                return { layer: e2, listener: i2, delegates: { mousemove: a2, mouseout: s2 } };
              }
              {
                const o2 = (t3) => {
                  const o3 = this.getLayer(e2) ? this.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
                  o3.length && (t3.features = o3, i2.call(this, t3), delete t3.features);
                };
                return { layer: e2, listener: i2, delegates: { [t2]: o2 } };
              }
            }
            on(t2, e2, i2) {
              if (i2 === void 0)
                return super.on(t2, e2);
              const o2 = this._createDelegatedListener(t2, e2, i2);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(o2);
              for (const t3 in o2.delegates)
                this.on(t3, o2.delegates[t3]);
              return this;
            }
            once(t2, e2, i2) {
              if (i2 === void 0)
                return super.once(t2, e2);
              const o2 = this._createDelegatedListener(t2, e2, i2);
              for (const t3 in o2.delegates)
                this.once(t3, o2.delegates[t3]);
              return this;
            }
            off(t2, e2, i2) {
              return i2 === void 0 ? super.off(t2, e2) : (this._delegatedListeners && this._delegatedListeners[t2] && ((o2) => {
                const a2 = this._delegatedListeners[t2];
                for (let t3 = 0; t3 < a2.length; t3++) {
                  const o3 = a2[t3];
                  if (o3.layer === e2 && o3.listener === i2) {
                    for (const t4 in o3.delegates)
                      this.off(t4, o3.delegates[t4]);
                    return a2.splice(t3, 1), this;
                  }
                }
              })(), this);
            }
            queryRenderedFeatures(e2, i2) {
              if (!this.style)
                return [];
              let o2;
              if (i2 !== void 0 || e2 === void 0 || e2 instanceof t.pointGeometry || Array.isArray(e2) || (i2 = e2, e2 = void 0), i2 = i2 || {}, (e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.pointGeometry || typeof e2[0] == "number")
                o2 = [t.pointGeometry.convert(e2)];
              else {
                const i3 = t.pointGeometry.convert(e2[0]), a2 = t.pointGeometry.convert(e2[1]);
                o2 = [i3, new t.pointGeometry(a2.x, i3.y), a2, new t.pointGeometry(i3.x, a2.y), i3];
              }
              return this.style.queryRenderedFeatures(o2, i2, this.transform);
            }
            querySourceFeatures(t2, e2) {
              return this.style.querySourceFeatures(t2, e2);
            }
            setStyle(e2, i2) {
              return (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
            }
            setTransformRequest(t2) {
              return this._requestManager.setTransformRequest(t2), this;
            }
            _getUIString(t2) {
              const e2 = this._locale[t2];
              if (e2 == null)
                throw new Error(`Missing UI string '${t2}'`);
              return e2;
            }
            _updateStyle(t2, e2) {
              return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new se(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof t2 == "string" ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new se(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e2, i2) {
              if (typeof e2 == "string") {
                const o2 = this._requestManager.transformRequest(e2, t.ResourceType.Style);
                t.getJSON(o2, (e3, o3) => {
                  e3 ? this.fire(new t.ErrorEvent(e3)) : o3 && this._updateDiff(o3, i2);
                });
              } else
                typeof e2 == "object" && this._updateDiff(e2, i2);
            }
            _updateDiff(e2, i2) {
              try {
                this.style.setState(e2) && this._update(true);
              } catch (o2) {
                t.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
              }
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
            }
            addSource(t2, e2) {
              return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
            }
            isSourceLoaded(e2) {
              const i2 = this.style && this.style.sourceCaches[e2];
              if (i2 !== void 0)
                return i2.loaded();
              this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e2}'`)));
            }
            setTerrain(t2) {
              return this.style.setTerrain(t2), this;
            }
            getTerrain() {
              return this.style.terrain && this.style.terrain.options;
            }
            areTilesLoaded() {
              const t2 = this.style && this.style.sourceCaches;
              for (const e2 in t2) {
                const i2 = t2[e2]._tiles;
                for (const t3 in i2) {
                  const e3 = i2[t3];
                  if (e3.state !== "loaded" && e3.state !== "errored")
                    return false;
                }
              }
              return true;
            }
            addSourceType(t2, e2, i2) {
              return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e2, i2);
            }
            removeSource(t2) {
              return this.style.removeSource(t2), this._update(true);
            }
            getSource(t2) {
              return this.style.getSource(t2);
            }
            addImage(e2, i2, { pixelRatio: o2 = 1, sdf: a2 = false, stretchX: s2, stretchY: r2, content: n2 } = {}) {
              if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || t.isImageBitmap(i2)) {
                const { width: l2, height: c2, data: h2 } = t.exported.getImageData(i2);
                this.style.addImage(e2, { data: new t.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: s2, stretchY: r2, content: n2, sdf: a2, version: 0 });
              } else {
                if (i2.width === void 0 || i2.height === void 0)
                  return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: l2, height: c2, data: h2 } = i2, u2 = i2;
                  this.style.addImage(e2, { data: new t.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2)), pixelRatio: o2, stretchX: s2, stretchY: r2, content: n2, sdf: a2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e2);
                }
              }
            }
            updateImage(e2, i2) {
              const o2 = this.style.getImage(e2);
              if (!o2)
                return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const a2 = i2 instanceof HTMLImageElement || t.isImageBitmap(i2) ? t.exported.getImageData(i2) : i2, { width: s2, height: r2, data: n2 } = a2;
              if (s2 === void 0 || r2 === void 0)
                return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (s2 !== o2.data.width || r2 !== o2.data.height)
                return this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
              const l2 = !(i2 instanceof HTMLImageElement || t.isImageBitmap(i2));
              o2.data.replace(n2, l2), this.style.updateImage(e2, o2);
            }
            hasImage(e2) {
              return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
            }
            removeImage(t2) {
              this.style.removeImage(t2);
            }
            loadImage(e2, i2) {
              t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), i2);
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(t2, e2) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
            }
            moveLayer(t2, e2) {
              return this.style.moveLayer(t2, e2), this._update(true);
            }
            removeLayer(t2) {
              return this.style.removeLayer(t2), this._update(true);
            }
            getLayer(t2) {
              return this.style.getLayer(t2);
            }
            setLayerZoomRange(t2, e2, i2) {
              return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
            }
            setFilter(t2, e2, i2 = {}) {
              return this.style.setFilter(t2, e2, i2), this._update(true);
            }
            getFilter(t2) {
              return this.style.getFilter(t2);
            }
            setPaintProperty(t2, e2, i2, o2 = {}) {
              return this.style.setPaintProperty(t2, e2, i2, o2), this._update(true);
            }
            getPaintProperty(t2, e2) {
              return this.style.getPaintProperty(t2, e2);
            }
            setLayoutProperty(t2, e2, i2, o2 = {}) {
              return this.style.setLayoutProperty(t2, e2, i2, o2), this._update(true);
            }
            getLayoutProperty(t2, e2) {
              return this.style.getLayoutProperty(t2, e2);
            }
            setLight(t2, e2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setFeatureState(t2, e2) {
              return this.style.setFeatureState(t2, e2), this._update();
            }
            removeFeatureState(t2, e2) {
              return this.style.removeFeatureState(t2, e2), this._update();
            }
            getFeatureState(t2) {
              return this.style.getFeatureState(t2);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let t2 = 0, e2 = 0;
              return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
            }
            _setupContainer() {
              const t2 = this._container;
              t2.classList.add("maplibregl-map", "mapboxgl-map");
              const e2 = this._canvasContainer = s.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", t2);
              this._interactive && e2.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = s.create("canvas", "maplibregl-canvas mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
              const i2 = this._containerDimensions();
              this._resizeCanvas(i2[0], i2[1], this.getPixelRatio());
              const o2 = this._controlContainer = s.create("div", "maplibregl-control-container mapboxgl-control-container", t2), a2 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
                a2[t3] = s.create("div", `maplibregl-ctrl-${t3} mapboxgl-ctrl-${t3}`, o2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(t2, e2, i2) {
              this._canvas.width = i2 * t2, this._canvas.height = i2 * e2, this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e2}px`;
            }
            _setupPainter() {
              const i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
              o2 ? (this.painter = new io(o2, this.transform), t.exported$1.testSupport(o2)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
            }
            _contextLost(e2) {
              e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
            }
            _contextRestored(e2) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
            }
            _onMapScroll(t2) {
              if (t2.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(t2) {
              return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(t2) {
              return this._update(), this._renderTaskQueue.add(t2);
            }
            _cancelRenderFrame(t2) {
              this._renderTaskQueue.remove(t2);
            }
            _render(e2) {
              let i2, o2 = 0;
              const a2 = this.painter.context.extTimerQuery;
              if (this.listens("gpu-timing-frame") && (i2 = a2.createQueryEXT(), a2.beginQueryEXT(a2.TIME_ELAPSED_EXT, i2), o2 = t.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed)
                return;
              let s2 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e3 = this.transform.zoom, i3 = t.exported.now();
                this.style.zoomHistory.update(e3, i3);
                const o3 = new t.EvaluationParameters(e3, { now: i3, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), a3 = o3.crossFadingFactor();
                a3 === 1 && a3 === this._crossFadingFactor || (s2 = true, this._crossFadingFactor = a3), this.style.update(o3);
              }
              if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.style.terrain && this.style.terrain.sourceCache.update(this.transform, this.style.terrain), this.transform.updateElevation(this.style.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, t.PerformanceUtils.mark(t.PerformanceMarkers.load), this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || s2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                const e3 = t.exported.now() - o2;
                a2.endQueryEXT(a2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                  const o3 = a2.getQueryObjectEXT(i2, a2.QUERY_RESULT_EXT) / 1e6;
                  a2.deleteQueryEXT(i2), this.fire(new t.Event("gpu-timing-frame", { cpuTime: e3, gpuTime: o3 }));
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                const e3 = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const i3 = this.painter.queryGpuTimers(e3);
                  this.fire(new t.Event("gpu-timing-layer", { layerTimes: i3 }));
                }, 50);
              }
              const r2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return r2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || r2 || (this._fullyLoaded = true, t.PerformanceUtils.mark(t.PerformanceMarkers.fullLoad)), this;
            }
            redraw() {
              return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const t2 of this._controls)
                t2.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window != "undefined" && (removeEventListener("resize", this._onWindowResize, false), removeEventListener("orientationchange", this._onWindowResize, false), removeEventListener("online", this._onWindowOnline, false));
              const e2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              e2 && e2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), s.remove(this._canvasContainer), s.remove(this._controlContainer), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), t.PerformanceUtils.clearMetrics(), this._removed = true, this.fire(new t.Event("remove"));
            }
            triggerRepaint() {
              this.style && !this._frame && (this._frame = t.exported.frame((e2) => {
                t.PerformanceUtils.frame(e2), this._frame = null, this._render(e2);
              }));
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(t2) {
              this._trackResize && this.resize({ originalEvent: t2 })._update();
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(t2) {
              this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(t2) {
              this._showPadding !== t2 && (this._showPadding = t2, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(t2) {
              this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(t2) {
              this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(t2) {
              this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(t2) {
              this._vertices = t2, this._update();
            }
            _setCacheLimits(e2, i2) {
              t.setCacheLimits(e2, i2);
            }
          }, NavigationControl: class {
            constructor(e2) {
              this.options = t.extend({}, ca, e2), this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", (t2) => this._map.zoomIn({}, { originalEvent: t2 })), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", (t2) => this._map.zoomOut({}, { originalEvent: t2 })), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", (t2) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t2 }) : this._map.resetNorth({}, { originalEvent: t2 });
              }), this._compassIcon = s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            _updateZoomButtons() {
              const t2 = this._map.getZoom(), e2 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
              this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
            }
            _rotateCompassArrow() {
              const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = t2;
            }
            onAdd(t2) {
              return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ha(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              s.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(t2, e2) {
              const i2 = s.create("button", t2, this._container);
              return i2.type = "button", i2.addEventListener("click", e2), i2;
            }
            _setButtonTitle(t2, e2) {
              const i2 = this._map._getUIString(`NavigationControl.${e2}`);
              t2.title = i2, t2.setAttribute("aria-label", i2);
            }
          }, GeolocateControl: class extends t.Evented {
            constructor(e2) {
              super(), this.options = t.extend({}, pa, e2), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
            }
            onAdd(t2) {
              var e2;
              return this._map = t2, this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), e2 = this._setupUI, fa !== void 0 ? e2(fa) : window.navigator.permissions !== void 0 ? window.navigator.permissions.query({ name: "geolocation" }).then((t3) => {
                fa = t3.state !== "denied", e2(fa);
              }) : (fa = !!window.navigator.geolocation, e2(fa)), this._container;
            }
            onRemove() {
              this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), s.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ga = 0, xa = false;
            }
            _isOutOfMapMaxBounds(t2) {
              const e2 = this._map.getMaxBounds(), i2 = t2.coords;
              return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
              }
            }
            _onSuccess(e2) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e2))
                  return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e2)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = e2, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");
                  }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e2), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e2), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e2)), this._finish();
              }
            }
            _updateCamera(e2) {
              const i2 = new t.LngLat(e2.coords.longitude, e2.coords.latitude), o2 = e2.coords.accuracy, a2 = this._map.getBearing(), s2 = t.extend({ bearing: a2 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o2), s2, { geolocateSource: true });
            }
            _updateMarker(e2) {
              if (e2) {
                const i2 = new t.LngLat(e2.coords.longitude, e2.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const t2 = this._map._container.clientHeight / 2, e2 = this._map.unproject([0, t2]), i2 = this._map.unproject([1, t2]), o2 = e2.distanceTo(i2), a2 = Math.ceil(2 * this._accuracy / o2);
              this._circleElement.style.width = `${a2}px`, this._circleElement.style.height = `${a2}px`;
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _onError(e2) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (e2.code === 1) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const t2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2), this._geolocationWatchID !== void 0 && this._clearWatch();
                  } else {
                    if (e2.code === 3 && xa)
                      return;
                    this._setErrorState();
                  }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e2)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }
            _setupUI(e2) {
              if (this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this._geolocateButton = s.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", e2 === false) {
                t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                const e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = e3, this._geolocateButton.setAttribute("aria-label", e3);
              } else {
                const t2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = s.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new ma(this._dotElement), this._circleElement = s.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ma({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e3) => {
                e3.geolocateSource || this._watchState !== "ACTIVE_LOCK" || e3.originalEvent && e3.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this.fire(new t.Event("trackuserlocationend")));
              });
            }
            trigger() {
              if (!this._setup)
                return t.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    ga--, xa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                }
                if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                  this._clearWatch();
                else if (this._geolocationWatchID === void 0) {
                  let t2;
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ga++, ga > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, xa = true) : (t2 = this.options.positionOptions, xa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
                }
              } else
                window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, AttributionControl: aa, LogoControl: sa, ScaleControl: class {
            constructor(e2) {
              this.options = t.extend({}, va, e2), t.bindAll(["_onMove", "setUnit"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _onMove() {
              ya(this._map, this._container, this.options);
            }
            onAdd(t2) {
              return this._map = t2, this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              s.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
            setUnit(t2) {
              this.options.unit = t2, ya(this._map, this._container, this.options);
            }
          }, FullscreenControl: class {
            constructor(e2) {
              this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
            }
            onAdd(e2) {
              return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
            }
            onRemove() {
              s.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const t2 = this._fullscreenButton = s.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);
              s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const t2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          }, TerrainControl: class {
            constructor(e2) {
              this.options = e2, t.bindAll(["_toggleTerrain", "_updateTerrainIcon"], this);
            }
            onAdd(t2) {
              return this._map = t2, this._container = s.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._terrainButton = s.create("button", "maplibregl-ctrl-terrain mapboxgl-ctrl-terrain", this._container), s.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
            }
            onRemove() {
              s.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
            }
            _toggleTerrain() {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }
            _updateTerrainIcon() {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._map.style.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
            }
          }, Popup: class extends t.Evented {
            constructor(e2) {
              super(), this.options = t.extend(Object.create(wa), e2), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
            }
            addTo(e2) {
              return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              return this._content && s.remove(this._content), this._container && (s.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e2) {
              return this._lngLat = t.LngLat.convert(e2), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(t2) {
              return this.setDOMContent(document.createTextNode(t2));
            }
            setHTML(t2) {
              const e2 = document.createDocumentFragment(), i2 = document.createElement("body");
              let o2;
              for (i2.innerHTML = t2; o2 = i2.firstChild, o2; )
                e2.appendChild(o2);
              return this.setDOMContent(e2);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(t2) {
              return this.options.maxWidth = t2, this._update(), this;
            }
            setDOMContent(t2) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else
                this._content = s.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);
              return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(t2) {
              this._container && this._container.classList.add(t2);
            }
            removeClassName(t2) {
              this._container && this._container.classList.remove(t2);
            }
            setOffset(t2) {
              return this.options.offset = t2, this._update(), this;
            }
            toggleClassName(t2) {
              if (this._container)
                return this._container.classList.toggle(t2);
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = s.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _onMouseUp(t2) {
              this._update(t2.point);
            }
            _onMouseMove(t2) {
              this._update(t2.point);
            }
            _onDrag(t2) {
              this._update(t2.point);
            }
            _update(t2) {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                return;
              if (this._container || (this._container = s.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = s.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((t3) => this._container.classList.add(t3)), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ua(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t2)
                return;
              const e2 = this._pos = this._trackPointer && t2 ? t2 : this._map.project(this._lngLat);
              let i2 = this.options.anchor;
              const o2 = Ea(this.options.offset);
              if (!i2) {
                const t3 = this._container.offsetWidth, a3 = this._container.offsetHeight;
                let s2;
                s2 = e2.y + o2.bottom.y < a3 ? ["top"] : e2.y > this._map.transform.height - a3 ? ["bottom"] : [], e2.x < t3 / 2 ? s2.push("left") : e2.x > this._map.transform.width - t3 / 2 && s2.push("right"), i2 = s2.length === 0 ? "bottom" : s2.join("-");
              }
              const a2 = e2.add(o2[i2]).round();
              s.setTransform(this._container, `${da[i2]} translate(${a2.x}px,${a2.y}px)`), _a(this._container, i2, "popup");
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const t2 = this._container.querySelector(Ta);
              t2 && t2.focus();
            }
            _onClose() {
              this.remove();
            }
          }, Marker: ma, Style: se, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.pointGeometry, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, AJAXError: t.AJAXError, config: t.config, CanvasSource: L, GeoJSONSource: P, ImageSource: M, RasterDEMTileSource: z, RasterTileSource: C, VectorTileSource: S, VideoSource: R, prewarm: function() {
            H().acquire(j);
          }, clearPrewarmedResources: function() {
            const t2 = W;
            t2 && (t2.isPreloaded() && t2.numActive() === 1 ? (t2.release(j), W = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, get workerCount() {
            return X.workerCount;
          }, set workerCount(t2) {
            X.workerCount = t2;
          }, get maxParallelImageRequests() {
            return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(e2) {
            t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
          }, clearStorage(e2) {
            t.clearTileCache(e2);
          }, workerUrl: "", addProtocol(e2, i2) {
            t.config.REGISTERED_PROTOCOLS[e2] = i2;
          }, removeProtocol(e2) {
            delete t.config.REGISTERED_PROTOCOLS[e2];
          } };
          return ia.extend(Ia, { isSafari: t.isSafari, getPerformanceMetrics: t.PerformanceUtils.getPerformanceMetrics }), Ia;
        });
        var maplibregl$1 = maplibregl;
        return maplibregl$1;
      });
    }
  });

  // <stdin>
  var import_maplibre_gl = __toESM(require_maplibre_gl());

  // node_modules/@popperjs/core/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    afterMain: () => afterMain,
    afterRead: () => afterRead,
    afterWrite: () => afterWrite,
    applyStyles: () => applyStyles_default,
    arrow: () => arrow_default,
    auto: () => auto,
    basePlacements: () => basePlacements,
    beforeMain: () => beforeMain,
    beforeRead: () => beforeRead,
    beforeWrite: () => beforeWrite,
    bottom: () => bottom,
    clippingParents: () => clippingParents,
    computeStyles: () => computeStyles_default,
    createPopper: () => createPopper3,
    createPopperBase: () => createPopper,
    createPopperLite: () => createPopper2,
    detectOverflow: () => detectOverflow,
    end: () => end,
    eventListeners: () => eventListeners_default,
    flip: () => flip_default,
    hide: () => hide_default,
    left: () => left,
    main: () => main,
    modifierPhases: () => modifierPhases,
    offset: () => offset_default,
    placements: () => placements,
    popper: () => popper,
    popperGenerator: () => popperGenerator,
    popperOffsets: () => popperOffsets_default,
    preventOverflow: () => preventOverflow_default,
    read: () => read,
    reference: () => reference,
    right: () => right,
    start: () => start,
    top: () => top,
    variationPlacements: () => variationPlacements,
    viewport: () => viewport,
    write: () => write
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (isHTMLElement(element) && includeScale) {
      var offsetHeight = element.offsetHeight;
      var offsetWidth = element.offsetWidth;
      if (offsetWidth > 0) {
        scaleX = round(rect.width) / offsetWidth || 1;
      }
      if (offsetHeight > 0) {
        scaleY = round(rect.height) / offsetHeight || 1;
      }
    }
    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p, c) {
      return p.replace(/%s/, c);
    }, str);
  }

  // node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
        return self2.indexOf(value) === index;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
              return '"' + s + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper4(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var createPopper = /* @__PURE__ */ popperGenerator();

  // node_modules/@popperjs/core/lib/popper-lite.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper2 = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper3 = /* @__PURE__ */ popperGenerator({
    defaultModifiers: defaultModifiers2
  });

  // node_modules/bootstrap/dist/js/bootstrap.esm.js
  var MAX_UID = 1e6;
  var MILLISECONDS_MULTIPLIER = 1e3;
  var TRANSITION_END = "transitionend";
  var toType = (obj) => {
    if (obj === null || obj === void 0) {
      return `${obj}`;
    }
    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  var getUID = (prefix) => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  var getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttr = element.getAttribute("href");
      if (!hrefAttr || !hrefAttr.includes("#") && !hrefAttr.startsWith(".")) {
        return null;
      }
      if (hrefAttr.includes("#") && !hrefAttr.startsWith("#")) {
        hrefAttr = `#${hrefAttr.split("#")[1]}`;
      }
      selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : null;
    }
    return selector;
  };
  var getSelectorFromElement = (element) => {
    const selector = getSelector(element);
    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }
    return null;
  };
  var getElementFromSelector = (element) => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };
  var getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  var triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  var isElement2 = (obj) => {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (typeof obj.jquery !== "undefined") {
      obj = obj[0];
    }
    return typeof obj.nodeType !== "undefined";
  };
  var getElement = (obj) => {
    if (isElement2(obj)) {
      return obj.jquery ? obj[0] : obj;
    }
    if (typeof obj === "string" && obj.length > 0) {
      return document.querySelector(obj);
    }
    return null;
  };
  var typeCheckConfig = (componentName, config, configTypes) => {
    Object.keys(configTypes).forEach((property) => {
      const expectedTypes = configTypes[property];
      const value = config[property];
      const valueType = value && isElement2(value) ? "element" : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    });
  };
  var isVisible = (element) => {
    if (!isElement2(element) || element.getClientRects().length === 0) {
      return false;
    }
    return getComputedStyle(element).getPropertyValue("visibility") === "visible";
  };
  var isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
  };
  var findShadowRoot = (element) => {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  var noop = () => {
  };
  var reflow = (element) => {
    element.offsetHeight;
  };
  var getjQuery = () => {
    const {
      jQuery
    } = window;
    if (jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return jQuery;
    }
    return null;
  };
  var DOMContentLoadedCallbacks = [];
  var onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          DOMContentLoadedCallbacks.forEach((callback2) => callback2());
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  var isRTL = () => document.documentElement.dir === "rtl";
  var defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  var execute = (callback) => {
    if (typeof callback === "function") {
      callback();
    }
  };
  var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    let index = list.indexOf(activeElement);
    if (index === -1) {
      return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
    }
    const listLength = list.length;
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {};
  var uidEvent = 1;
  var customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var customEventsRegex = /^(mouseenter|mouseleave)/i;
  var nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function getUidEvent(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getEvent(element) {
    const uid = getUidEvent(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn2) {
    return function handler(event) {
      event.delegateTarget = element;
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn2);
      }
      return fn2.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn2) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (let i = domElements.length; i--; ) {
          if (domElements[i] === target) {
            event.delegateTarget = target;
            if (handler.oneOff) {
              EventHandler.off(element, event.type, selector, fn2);
            }
            return fn2.apply(target, [event]);
          }
        }
      }
      return null;
    };
  }
  function findHandler(events, handler, delegationSelector = null) {
    const uidEventList = Object.keys(events);
    for (let i = 0, len = uidEventList.length; i < len; i++) {
      const event = events[uidEventList[i]];
      if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
        return event;
      }
    }
    return null;
  }
  function normalizeParams(originalTypeEvent, handler, delegationFn) {
    const delegation = typeof handler === "string";
    const originalHandler = delegation ? delegationFn : handler;
    let typeEvent = getTypeEvent(originalTypeEvent);
    const isNative = nativeEvents.has(typeEvent);
    if (!isNative) {
      typeEvent = originalTypeEvent;
    }
    return [delegation, originalHandler, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    if (!handler) {
      handler = delegationFn;
      delegationFn = null;
    }
    if (customEventsRegex.test(originalTypeEvent)) {
      const wrapFn = (fn3) => {
        return function(event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn3.call(this, event);
          }
        };
      };
      if (delegationFn) {
        delegationFn = wrapFn(delegationFn);
      } else {
        handler = wrapFn(handler);
      }
    }
    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
    const events = getEvent(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);
    if (previousFn) {
      previousFn.oneOff = previousFn.oneOff && oneOff;
      return;
    }
    const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ""));
    const fn2 = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
    fn2.delegationSelector = delegation ? handler : null;
    fn2.originalHandler = originalHandler;
    fn2.oneOff = oneOff;
    fn2.uidEvent = uid;
    handlers[uid] = fn2;
    element.addEventListener(typeEvent, fn2, delegation);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn2) {
      return;
    }
    element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
    delete events[typeEvent][fn2.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach((handlerKey) => {
      if (handlerKey.includes(namespace)) {
        const event = storeElementEvent[handlerKey];
        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
      }
    });
  }
  function getTypeEvent(event) {
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  var EventHandler = {
    on(element, event, handler, delegationFn) {
      addHandler(element, event, handler, delegationFn, false);
    },
    one(element, event, handler, delegationFn) {
      addHandler(element, event, handler, delegationFn, true);
    },
    off(element, originalTypeEvent, handler, delegationFn) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getEvent(element);
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof originalHandler !== "undefined") {
        if (!events || !events[typeEvent]) {
          return;
        }
        removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
        return;
      }
      if (isNamespace) {
        Object.keys(events).forEach((elementEvent) => {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        });
      }
      const storeElementEvent = events[typeEvent] || {};
      Object.keys(storeElementEvent).forEach((keyHandlers) => {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          const event = storeElementEvent[keyHandlers];
          removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
        }
      });
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      const isNative = nativeEvents.has(typeEvent);
      let jQueryEvent;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      let evt = null;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      if (isNative) {
        evt = document.createEvent("HTMLEvents");
        evt.initEvent(typeEvent, bubbles, true);
      } else {
        evt = new CustomEvent(event, {
          bubbles,
          cancelable: true
        });
      }
      if (typeof args !== "undefined") {
        Object.keys(args).forEach((key) => {
          Object.defineProperty(evt, key, {
            get() {
              return args[key];
            }
          });
        });
      }
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && typeof jQueryEvent !== "undefined") {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  var elementMap = /* @__PURE__ */ new Map();
  var Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, /* @__PURE__ */ new Map());
      }
      const instanceMap = elementMap.get(element);
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };
  var VERSION = "5.1.3";
  var BaseComponent = class {
    constructor(element) {
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      Object.getOwnPropertyNames(this).forEach((propertyName) => {
        this[propertyName] = null;
      });
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
  };
  var enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    });
  };
  var NAME$d = "alert";
  var DATA_KEY$c = "bs.alert";
  var EVENT_KEY$c = `.${DATA_KEY$c}`;
  var EVENT_CLOSE = `close${EVENT_KEY$c}`;
  var EVENT_CLOSED = `closed${EVENT_KEY$c}`;
  var CLASS_NAME_FADE$5 = "fade";
  var CLASS_NAME_SHOW$8 = "show";
  var Alert = class extends BaseComponent {
    static get NAME() {
      return NAME$d;
    }
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Alert.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  };
  enableDismissTrigger(Alert, "close");
  defineJQueryPlugin(Alert);
  var NAME$c = "button";
  var DATA_KEY$b = "bs.button";
  var EVENT_KEY$b = `.${DATA_KEY$b}`;
  var DATA_API_KEY$7 = ".data-api";
  var CLASS_NAME_ACTIVE$3 = "active";
  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$b}${DATA_API_KEY$7}`;
  var Button = class extends BaseComponent {
    static get NAME() {
      return NAME$c;
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Button.getOrCreateInstance(this);
        if (config === "toggle") {
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  defineJQueryPlugin(Button);
  function normalizeData(val) {
    if (val === "true") {
      return true;
    }
    if (val === "false") {
      return false;
    }
    if (val === Number(val).toString()) {
      return Number(val);
    }
    if (val === "" || val === "null") {
      return null;
    }
    return val;
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  var Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      Object.keys(element.dataset).filter((key) => key.startsWith("bs")).forEach((key) => {
        let pureKey = key.replace(/^bs/, "");
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      });
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    },
    offset(element) {
      const rect = element.getBoundingClientRect();
      return {
        top: rect.top + window.pageYOffset,
        left: rect.left + window.pageXOffset
      };
    },
    position(element) {
      return {
        top: element.offsetTop,
        left: element.offsetLeft
      };
    }
  };
  var NODE_TEXT = 3;
  var SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode;
      while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
        if (ancestor.matches(selector)) {
          parents.push(ancestor);
        }
        ancestor = ancestor.parentNode;
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(", ");
      return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
    }
  };
  var NAME$b = "carousel";
  var DATA_KEY$a = "bs.carousel";
  var EVENT_KEY$a = `.${DATA_KEY$a}`;
  var DATA_API_KEY$6 = ".data-api";
  var ARROW_LEFT_KEY = "ArrowLeft";
  var ARROW_RIGHT_KEY = "ArrowRight";
  var TOUCHEVENT_COMPAT_WAIT = 500;
  var SWIPE_THRESHOLD = 40;
  var Default$a = {
    interval: 5e3,
    keyboard: true,
    slide: false,
    pause: "hover",
    wrap: true,
    touch: true
  };
  var DefaultType$a = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  };
  var ORDER_NEXT = "next";
  var ORDER_PREV = "prev";
  var DIRECTION_LEFT = "left";
  var DIRECTION_RIGHT = "right";
  var KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY]: DIRECTION_LEFT
  };
  var EVENT_SLIDE = `slide${EVENT_KEY$a}`;
  var EVENT_SLID = `slid${EVENT_KEY$a}`;
  var EVENT_KEYDOWN = `keydown${EVENT_KEY$a}`;
  var EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$a}`;
  var EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$a}`;
  var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$a}`;
  var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$a}`;
  var EVENT_TOUCHEND = `touchend${EVENT_KEY$a}`;
  var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$a}`;
  var EVENT_POINTERUP = `pointerup${EVENT_KEY$a}`;
  var EVENT_DRAG_START = `dragstart${EVENT_KEY$a}`;
  var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$a}${DATA_API_KEY$6}`;
  var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
  var CLASS_NAME_CAROUSEL = "carousel";
  var CLASS_NAME_ACTIVE$2 = "active";
  var CLASS_NAME_SLIDE = "slide";
  var CLASS_NAME_END = "carousel-item-end";
  var CLASS_NAME_START = "carousel-item-start";
  var CLASS_NAME_NEXT = "carousel-item-next";
  var CLASS_NAME_PREV = "carousel-item-prev";
  var CLASS_NAME_POINTER_EVENT = "pointer-event";
  var SELECTOR_ACTIVE$1 = ".active";
  var SELECTOR_ACTIVE_ITEM = ".active.carousel-item";
  var SELECTOR_ITEM = ".carousel-item";
  var SELECTOR_ITEM_IMG = ".carousel-item img";
  var SELECTOR_NEXT_PREV = ".carousel-item-next, .carousel-item-prev";
  var SELECTOR_INDICATORS = ".carousel-indicators";
  var SELECTOR_INDICATOR = "[data-bs-target]";
  var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var POINTER_TYPE_TOUCH = "touch";
  var POINTER_TYPE_PEN = "pen";
  var Carousel = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(config);
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent);
      this._addEventListeners();
    }
    static get Default() {
      return Default$a;
    }
    static get NAME() {
      return NAME$b;
    }
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause(event) {
      if (!event) {
        this._isPaused = true;
      }
      if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {
        triggerTransitionEnd(this._element);
        this.cycle(true);
      }
      clearInterval(this._interval);
      this._interval = null;
    }
    cycle(event) {
      if (!event) {
        this._isPaused = false;
      }
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
      if (this._config && this._config.interval && !this._isPaused) {
        this._updateInterval();
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    }
    to(index) {
      this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
      const activeIndex = this._getItemIndex(this._activeElement);
      if (index > this._items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }
      const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order2, this._items[index]);
    }
    _getConfig(config) {
      config = {
        ...Default$a,
        ...Manipulator.getDataAttributes(this._element),
        ...typeof config === "object" ? config : {}
      };
      typeCheckConfig(NAME$b, config, DefaultType$a);
      return config;
    }
    _handleSwipe() {
      const absDeltax = Math.abs(this.touchDeltaX);
      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltax / this.touchDeltaX;
      this.touchDeltaX = 0;
      if (!direction) {
        return;
      }
      this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
      }
      if (this._config.pause === "hover") {
        EventHandler.on(this._element, EVENT_MOUSEENTER, (event) => this.pause(event));
        EventHandler.on(this._element, EVENT_MOUSELEAVE, (event) => this.cycle(event));
      }
      if (this._config.touch && this._touchSupported) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      const hasPointerPenTouch = (event) => {
        return this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
      };
      const start2 = (event) => {
        if (hasPointerPenTouch(event)) {
          this.touchStartX = event.clientX;
        } else if (!this._pointerEvent) {
          this.touchStartX = event.touches[0].clientX;
        }
      };
      const move = (event) => {
        this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
      };
      const end2 = (event) => {
        if (hasPointerPenTouch(event)) {
          this.touchDeltaX = event.clientX - this.touchStartX;
        }
        this._handleSwipe();
        if (this._config.pause === "hover") {
          this.pause();
          if (this.touchTimeout) {
            clearTimeout(this.touchTimeout);
          }
          this.touchTimeout = setTimeout((event2) => this.cycle(event2), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
        }
      };
      SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach((itemImg) => {
        EventHandler.on(itemImg, EVENT_DRAG_START, (event) => event.preventDefault());
      });
      if (this._pointerEvent) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => start2(event));
        EventHandler.on(this._element, EVENT_POINTERUP, (event) => end2(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => start2(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, (event) => end2(event));
      }
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(direction);
      }
    }
    _getItemIndex(element) {
      this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];
      return this._items.indexOf(element);
    }
    _getItemByOrder(order2, activeElement) {
      const isNext = order2 === ORDER_NEXT;
      return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);
    }
    _triggerSlideEvent(relatedTarget, eventDirectionName) {
      const targetIndex = this._getItemIndex(relatedTarget);
      const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));
      return EventHandler.trigger(this._element, EVENT_SLIDE, {
        relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
    }
    _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);
        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
        activeIndicator.removeAttribute("aria-current");
        const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);
        for (let i = 0; i < indicators.length; i++) {
          if (Number.parseInt(indicators[i].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(element)) {
            indicators[i].classList.add(CLASS_NAME_ACTIVE$2);
            indicators[i].setAttribute("aria-current", "true");
            break;
          }
        }
      }
    }
    _updateInterval() {
      const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
      if (elementInterval) {
        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
        this._config.interval = elementInterval;
      } else {
        this._config.interval = this._config.defaultInterval || this._config.interval;
      }
    }
    _slide(directionOrOrder, element) {
      const order2 = this._directionToOrder(directionOrOrder);
      const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
      const activeElementIndex = this._getItemIndex(activeElement);
      const nextElement = element || this._getItemByOrder(order2, activeElement);
      const nextElementIndex = this._getItemIndex(nextElement);
      const isCycling = Boolean(this._interval);
      const isNext = order2 === ORDER_NEXT;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      const eventDirectionName = this._orderToDirection(order2);
      if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {
        this._isSliding = false;
        return;
      }
      if (this._isSliding) {
        return;
      }
      const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        return;
      }
      this._isSliding = true;
      if (isCycling) {
        this.pause();
      }
      this._setActiveIndicatorElement(nextElement);
      this._activeElement = nextElement;
      const triggerSlidEvent = () => {
        EventHandler.trigger(this._element, EVENT_SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });
      };
      if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
        nextElement.classList.add(orderClassName);
        reflow(nextElement);
        activeElement.classList.add(directionalClassName);
        nextElement.classList.add(directionalClassName);
        const completeCallBack = () => {
          nextElement.classList.remove(directionalClassName, orderClassName);
          nextElement.classList.add(CLASS_NAME_ACTIVE$2);
          activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
          this._isSliding = false;
          setTimeout(triggerSlidEvent, 0);
        };
        this._queueCallback(completeCallBack, activeElement, true);
      } else {
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        this._isSliding = false;
        triggerSlidEvent();
      }
      if (isCycling) {
        this.cycle();
      }
    }
    _directionToOrder(direction) {
      if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {
        return direction;
      }
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order2) {
      if (![ORDER_NEXT, ORDER_PREV].includes(order2)) {
        return order2;
      }
      if (isRTL()) {
        return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    static carouselInterface(element, config) {
      const data = Carousel.getOrCreateInstance(element, config);
      let {
        _config
      } = data;
      if (typeof config === "object") {
        _config = {
          ..._config,
          ...config
        };
      }
      const action = typeof config === "string" ? config : _config.slide;
      if (typeof config === "number") {
        data.to(config);
      } else if (typeof action === "string") {
        if (typeof data[action] === "undefined") {
          throw new TypeError(`No method named "${action}"`);
        }
        data[action]();
      } else if (_config.interval && _config.ride) {
        data.pause();
        data.cycle();
      }
    }
    static jQueryInterface(config) {
      return this.each(function() {
        Carousel.carouselInterface(this, config);
      });
    }
    static dataApiClickHandler(event) {
      const target = getElementFromSelector(this);
      if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
        return;
      }
      const config = {
        ...Manipulator.getDataAttributes(target),
        ...Manipulator.getDataAttributes(this)
      };
      const slideIndex = this.getAttribute("data-bs-slide-to");
      if (slideIndex) {
        config.interval = false;
      }
      Carousel.carouselInterface(target, config);
      if (slideIndex) {
        Carousel.getInstance(target).to(slideIndex);
      }
      event.preventDefault();
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (let i = 0, len = carousels.length; i < len; i++) {
      Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
    }
  });
  defineJQueryPlugin(Carousel);
  var NAME$a = "collapse";
  var DATA_KEY$9 = "bs.collapse";
  var EVENT_KEY$9 = `.${DATA_KEY$9}`;
  var DATA_API_KEY$5 = ".data-api";
  var Default$9 = {
    toggle: true,
    parent: null
  };
  var DefaultType$9 = {
    toggle: "boolean",
    parent: "(null|element)"
  };
  var EVENT_SHOW$5 = `show${EVENT_KEY$9}`;
  var EVENT_SHOWN$5 = `shown${EVENT_KEY$9}`;
  var EVENT_HIDE$5 = `hide${EVENT_KEY$9}`;
  var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$9}`;
  var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$9}${DATA_API_KEY$5}`;
  var CLASS_NAME_SHOW$7 = "show";
  var CLASS_NAME_COLLAPSE = "collapse";
  var CLASS_NAME_COLLAPSING = "collapsing";
  var CLASS_NAME_COLLAPSED = "collapsed";
  var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  var WIDTH = "width";
  var HEIGHT = "height";
  var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  var Collapse = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._isTransitioning = false;
      this._config = this._getConfig(config);
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (let i = 0, len = toggleList.length; i < len; i++) {
        const elem = toggleList[i];
        const selector = getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter((foundElem) => foundElem === this._element);
        if (selector !== null && filterElement.length) {
          this._selector = selector;
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    static get Default() {
      return Default$9;
    }
    static get NAME() {
      return NAME$a;
    }
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let actives = [];
      let activesData;
      if (this._config.parent) {
        const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
        actives = SelectorEngine.find(SELECTOR_ACTIVES, this._config.parent).filter((elem) => !children.includes(elem));
      }
      const container = SelectorEngine.findOne(this._selector);
      if (actives.length) {
        const tempActiveData = actives.find((elem) => container !== elem);
        activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;
        if (activesData && activesData._isTransitioning) {
          return;
        }
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);
      if (startEvent.defaultPrevented) {
        return;
      }
      actives.forEach((elemActive) => {
        if (container !== elemActive) {
          Collapse.getOrCreateInstance(elemActive, {
            toggle: false
          }).hide();
        }
        if (!activesData) {
          Data.set(elemActive, DATA_KEY$9, null);
        }
      });
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = "";
        EventHandler.trigger(this._element, EVENT_SHOWN$5);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      const triggerArrayLength = this._triggerArray.length;
      for (let i = 0; i < triggerArrayLength; i++) {
        const trigger = this._triggerArray[i];
        const elem = getElementFromSelector(trigger);
        if (elem && !this._isShown(elem)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$5);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    _getConfig(config) {
      config = {
        ...Default$9,
        ...Manipulator.getDataAttributes(this._element),
        ...config
      };
      config.toggle = Boolean(config.toggle);
      config.parent = getElement(config.parent);
      typeCheckConfig(NAME$a, config, DefaultType$9);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      SelectorEngine.find(SELECTOR_DATA_TOGGLE$4, this._config.parent).filter((elem) => !children.includes(elem)).forEach((element) => {
        const selected = getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      });
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      triggerArray.forEach((elem) => {
        if (isOpen) {
          elem.classList.remove(CLASS_NAME_COLLAPSED);
        } else {
          elem.classList.add(CLASS_NAME_COLLAPSED);
        }
        elem.setAttribute("aria-expanded", isOpen);
      });
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const _config = {};
        if (typeof config === "string" && /show|hide/.test(config)) {
          _config.toggle = false;
        }
        const data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    const selector = getSelectorFromElement(this);
    const selectorElements = SelectorEngine.find(selector);
    selectorElements.forEach((element) => {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    });
  });
  defineJQueryPlugin(Collapse);
  var NAME$9 = "dropdown";
  var DATA_KEY$8 = "bs.dropdown";
  var EVENT_KEY$8 = `.${DATA_KEY$8}`;
  var DATA_API_KEY$4 = ".data-api";
  var ESCAPE_KEY$2 = "Escape";
  var SPACE_KEY = "Space";
  var TAB_KEY$1 = "Tab";
  var ARROW_UP_KEY = "ArrowUp";
  var ARROW_DOWN_KEY = "ArrowDown";
  var RIGHT_MOUSE_BUTTON = 2;
  var REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);
  var EVENT_HIDE$4 = `hide${EVENT_KEY$8}`;
  var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$8}`;
  var EVENT_SHOW$4 = `show${EVENT_KEY$8}`;
  var EVENT_SHOWN$4 = `shown${EVENT_KEY$8}`;
  var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$8}${DATA_API_KEY$4}`;
  var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$8}${DATA_API_KEY$4}`;
  var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$8}${DATA_API_KEY$4}`;
  var CLASS_NAME_SHOW$6 = "show";
  var CLASS_NAME_DROPUP = "dropup";
  var CLASS_NAME_DROPEND = "dropend";
  var CLASS_NAME_DROPSTART = "dropstart";
  var CLASS_NAME_NAVBAR = "navbar";
  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]';
  var SELECTOR_MENU = ".dropdown-menu";
  var SELECTOR_NAVBAR_NAV = ".navbar-nav";
  var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  var Default$8 = {
    offset: [0, 2],
    boundary: "clippingParents",
    reference: "toggle",
    display: "dynamic",
    popperConfig: null,
    autoClose: true
  };
  var DefaultType$8 = {
    offset: "(array|string|function)",
    boundary: "(string|element)",
    reference: "(string|element|object)",
    display: "string",
    popperConfig: "(null|object|function)",
    autoClose: "(boolean|string)"
  };
  var Dropdown = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();
    }
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown(this._menu)) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      const parent = Dropdown.getParentFromElement(this._element);
      if (this._inNavbar) {
        Manipulator.setDataAttribute(this._menu, "popper", "none");
      } else {
        this._createPopper(parent);
      }
      if ("ontouchstart" in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
        [].concat(...document.body.children).forEach((elem) => EventHandler.on(elem, "mouseover", noop));
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown(this._menu)) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }
      if ("ontouchstart" in document.documentElement) {
        [].concat(...document.body.children).forEach((elem) => EventHandler.off(elem, "mouseover", noop));
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute("aria-expanded", "false");
      Manipulator.removeDataAttribute(this._menu, "popper");
      EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
    }
    _getConfig(config) {
      config = {
        ...this.constructor.Default,
        ...Manipulator.getDataAttributes(this._element),
        ...config
      };
      typeCheckConfig(NAME$9, config, this.constructor.DefaultType);
      if (typeof config.reference === "object" && !isElement2(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
        throw new TypeError(`${NAME$9.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config;
    }
    _createPopper(parent) {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = parent;
      } else if (isElement2(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      const isDisplayStatic = popperConfig.modifiers.find((modifier) => modifier.name === "applyStyles" && modifier.enabled === false);
      this._popper = createPopper3(referenceElement, this._menu, popperConfig);
      if (isDisplayStatic) {
        Manipulator.setDataAttribute(this._menu, "popper", "static");
      }
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getMenuElement() {
      return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
    }
    _getPlacement() {
      const parentDropdown = this._element.parentNode;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((val) => Number.parseInt(val, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      if (this._config.display === "static") {
        defaultBsPopperConfig.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
      };
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);
      if (!items.length) {
        return;
      }
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1)) {
        return;
      }
      const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);
      for (let i = 0, len = toggles.length; i < len; i++) {
        const context = Dropdown.getInstance(toggles[i]);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        if (!context._isShown()) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event) {
          const composedPath = event.composedPath();
          const isMenuTarget = composedPath.includes(context._menu);
          if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
            continue;
          }
          if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
            continue;
          }
          if (event.type === "click") {
            relatedTarget.clickEvent = event;
          }
        }
        context._completeHide(relatedTarget);
      }
    }
    static getParentFromElement(element) {
      return getElementFromSelector(element) || element.parentNode;
    }
    static dataApiKeydownHandler(event) {
      if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
        return;
      }
      const isActive = this.classList.contains(CLASS_NAME_SHOW$6);
      if (!isActive && event.key === ESCAPE_KEY$2) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if (isDisabled(this)) {
        return;
      }
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
      const instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (event.key === ESCAPE_KEY$2) {
        instance.hide();
        return;
      }
      if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
        if (!isActive) {
          instance.show();
        }
        instance._selectMenuItem(event);
        return;
      }
      if (!isActive || event.key === SPACE_KEY) {
        Dropdown.clearMenus();
      }
    }
  };
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  defineJQueryPlugin(Dropdown);
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var ScrollBarHelper = class {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, "paddingRight", (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight", (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight", (calculatedValue) => calculatedValue - width);
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProp, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProp);
        const calculatedValue = window.getComputedStyle(element)[styleProp];
        element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, "paddingRight");
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight");
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight");
    }
    _saveInitialAttribute(element, styleProp) {
      const actualValue = element.style[styleProp];
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProp, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProp) {
      const manipulationCallBack = (element) => {
        const value = Manipulator.getDataAttribute(element, styleProp);
        if (typeof value === "undefined") {
          element.style.removeProperty(styleProp);
        } else {
          Manipulator.removeDataAttribute(element, styleProp);
          element.style[styleProp] = value;
        }
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement2(selector)) {
        callBack(selector);
      } else {
        SelectorEngine.find(selector, this._element).forEach(callBack);
      }
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
  };
  var Default$7 = {
    className: "modal-backdrop",
    isVisible: true,
    isAnimated: false,
    rootElement: "body",
    clickCallback: null
  };
  var DefaultType$7 = {
    className: "string",
    isVisible: "boolean",
    isAnimated: "boolean",
    rootElement: "(element|string)",
    clickCallback: "(function|null)"
  };
  var NAME$8 = "backdrop";
  var CLASS_NAME_FADE$4 = "fade";
  var CLASS_NAME_SHOW$5 = "show";
  var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$8}`;
  var Backdrop = class {
    constructor(config) {
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      if (this._config.isAnimated) {
        reflow(this._getElement());
      }
      this._getElement().classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _getConfig(config) {
      config = {
        ...Default$7,
        ...typeof config === "object" ? config : {}
      };
      config.rootElement = getElement(config.rootElement);
      typeCheckConfig(NAME$8, config, DefaultType$7);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      this._config.rootElement.append(this._getElement());
      EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  };
  var Default$6 = {
    trapElement: null,
    autofocus: true
  };
  var DefaultType$6 = {
    trapElement: "element",
    autofocus: "boolean"
  };
  var NAME$7 = "focustrap";
  var DATA_KEY$7 = "bs.focustrap";
  var EVENT_KEY$7 = `.${DATA_KEY$7}`;
  var EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$7}`;
  var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$7}`;
  var TAB_KEY = "Tab";
  var TAB_NAV_FORWARD = "forward";
  var TAB_NAV_BACKWARD = "backward";
  var FocusTrap = class {
    constructor(config) {
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    activate() {
      const {
        trapElement,
        autofocus
      } = this._config;
      if (this._isActive) {
        return;
      }
      if (autofocus) {
        trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$7);
      EventHandler.on(document, EVENT_FOCUSIN$1, (event) => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$7);
    }
    _handleFocusin(event) {
      const {
        target
      } = event;
      const {
        trapElement
      } = this._config;
      if (target === document || target === trapElement || trapElement.contains(target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
    _getConfig(config) {
      config = {
        ...Default$6,
        ...typeof config === "object" ? config : {}
      };
      typeCheckConfig(NAME$7, config, DefaultType$6);
      return config;
    }
  };
  var NAME$6 = "modal";
  var DATA_KEY$6 = "bs.modal";
  var EVENT_KEY$6 = `.${DATA_KEY$6}`;
  var DATA_API_KEY$3 = ".data-api";
  var ESCAPE_KEY$1 = "Escape";
  var Default$5 = {
    backdrop: true,
    keyboard: true,
    focus: true
  };
  var DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    focus: "boolean"
  };
  var EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;
  var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;
  var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;
  var EVENT_SHOW$3 = `show${EVENT_KEY$6}`;
  var EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;
  var EVENT_RESIZE = `resize${EVENT_KEY$6}`;
  var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$6}`;
  var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;
  var EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;
  var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;
  var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var CLASS_NAME_OPEN = "modal-open";
  var CLASS_NAME_FADE$3 = "fade";
  var CLASS_NAME_SHOW$4 = "show";
  var CLASS_NAME_STATIC = "modal-static";
  var OPEN_SELECTOR$1 = ".modal.show";
  var SELECTOR_DIALOG = ".modal-dialog";
  var SELECTOR_MODAL_BODY = ".modal-body";
  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  var Modal = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._config = this._getConfig(config);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
    }
    static get Default() {
      return Default$5;
    }
    static get NAME() {
      return NAME$6;
    }
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      if (this._isAnimated()) {
        this._isTransitioning = true;
      }
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._setEscapeEvent();
      this._setResizeEvent();
      EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {
        EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, (event) => {
          if (event.target === this._element) {
            this._ignoreBackdropClick = true;
          }
        });
      });
      this._showBackdrop(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      const isAnimated = this._isAnimated();
      if (isAnimated) {
        this._isTransitioning = true;
      }
      this._setEscapeEvent();
      this._setResizeEvent();
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      EventHandler.off(this._element, EVENT_CLICK_DISMISS);
      EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);
      this._queueCallback(() => this._hideModal(), this._element, isAnimated);
    }
    dispose() {
      [window, this._dialog].forEach((htmlElement) => EventHandler.off(htmlElement, EVENT_KEY$6));
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _getConfig(config) {
      config = {
        ...Default$5,
        ...Manipulator.getDataAttributes(this._element),
        ...typeof config === "object" ? config : {}
      };
      typeCheckConfig(NAME$6, config, DefaultType$5);
      return config;
    }
    _showElement(relatedTarget) {
      const isAnimated = this._isAnimated();
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      if (isAnimated) {
        reflow(this._element);
      }
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, isAnimated);
    }
    _setEscapeEvent() {
      if (this._isShown) {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
          if (this._config.keyboard && event.key === ESCAPE_KEY$1) {
            event.preventDefault();
            this.hide();
          } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) {
            this._triggerBackdropTransition();
          }
        });
      } else {
        EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);
      }
    }
    _setResizeEvent() {
      if (this._isShown) {
        EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());
      } else {
        EventHandler.off(window, EVENT_RESIZE);
      }
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      });
    }
    _showBackdrop(callback) {
      EventHandler.on(this._element, EVENT_CLICK_DISMISS, (event) => {
        if (this._ignoreBackdropClick) {
          this._ignoreBackdropClick = false;
          return;
        }
        if (event.target !== event.currentTarget) {
          return;
        }
        if (this._config.backdrop === true) {
          this.hide();
        } else if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
        }
      });
      this._backdrop.show(callback);
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const {
        classList,
        scrollHeight,
        style
      } = this._element;
      const isModalOverflowing = scrollHeight > document.documentElement.clientHeight;
      if (!isModalOverflowing && style.overflowY === "hidden" || classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        style.overflowY = "hidden";
      }
      classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        classList.remove(CLASS_NAME_STATIC);
        if (!isModalOverflowing) {
          this._queueCallback(() => {
            style.overflowY = "";
          }, this._dialog);
        }
      }, this._dialog);
      this._element.focus();
    }
    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {
        this._element.style.paddingLeft = `${scrollbarWidth}px`;
      }
      if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {
        this._element.style.paddingRight = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    static jQueryInterface(config, relatedTarget) {
      return this.each(function() {
        const data = Modal.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$3, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$3, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (allReadyOpen) {
      Modal.getInstance(allReadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);
  var NAME$5 = "offcanvas";
  var DATA_KEY$5 = "bs.offcanvas";
  var EVENT_KEY$5 = `.${DATA_KEY$5}`;
  var DATA_API_KEY$2 = ".data-api";
  var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;
  var ESCAPE_KEY = "Escape";
  var Default$4 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType$4 = {
    backdrop: "boolean",
    keyboard: "boolean",
    scroll: "boolean"
  };
  var CLASS_NAME_SHOW$3 = "show";
  var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  var OPEN_SELECTOR = ".offcanvas.show";
  var EVENT_SHOW$2 = `show${EVENT_KEY$5}`;
  var EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;
  var EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;
  var EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;
  var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;
  var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;
  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  var Offcanvas = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._config = this._getConfig(config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }
    static get NAME() {
      return NAME$5;
    }
    static get Default() {
      return Default$4;
    }
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._element.style.visibility = "visible";
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.classList.add(CLASS_NAME_SHOW$3);
      const completeCallBack = () => {
        if (!this._config.scroll) {
          this._focustrap.activate();
        }
        EventHandler.trigger(this._element, EVENT_SHOWN$2, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.remove(CLASS_NAME_SHOW$3);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.setAttribute("aria-hidden", true);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        this._element.style.visibility = "hidden";
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$2);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    _getConfig(config) {
      config = {
        ...Default$4,
        ...Manipulator.getDataAttributes(this._element),
        ...typeof config === "object" ? config : {}
      };
      typeCheckConfig(NAME$5, config, DefaultType$4);
      return config;
    }
    _initializeBackDrop() {
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: this._config.backdrop,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: () => this.hide()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (this._config.keyboard && event.key === ESCAPE_KEY) {
          this.hide();
        }
      });
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$2, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
    const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (allReadyOpen && allReadyOpen !== target) {
      Offcanvas.getInstance(allReadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => SelectorEngine.find(OPEN_SELECTOR).forEach((el) => Offcanvas.getOrCreateInstance(el).show()));
  enableDismissTrigger(Offcanvas);
  defineJQueryPlugin(Offcanvas);
  var uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
  var allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }
    const regExp = allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp);
    for (let i = 0, len = regExp.length; i < len; i++) {
      if (regExp[i].test(attributeName)) {
        return true;
      }
    }
    return false;
  };
  var DefaultAllowlist = {
    "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFn && typeof sanitizeFn === "function") {
      return sanitizeFn(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (let i = 0, len = elements.length; i < len; i++) {
      const element = elements[i];
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
      attributeList.forEach((attribute) => {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      });
    }
    return createdDocument.body.innerHTML;
  }
  var NAME$4 = "tooltip";
  var DATA_KEY$4 = "bs.tooltip";
  var EVENT_KEY$4 = `.${DATA_KEY$4}`;
  var CLASS_PREFIX$1 = "bs-tooltip";
  var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var DefaultType$3 = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(array|string|function)",
    container: "(string|element|boolean)",
    fallbackPlacements: "array",
    boundary: "(string|element)",
    customClass: "(string|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    allowList: "object",
    popperConfig: "(null|object|function)"
  };
  var AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left"
  };
  var Default$3 = {
    animation: true,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: false,
    selector: false,
    placement: "top",
    offset: [0, 0],
    container: false,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    boundary: "clippingParents",
    customClass: "",
    sanitize: true,
    sanitizeFn: null,
    allowList: DefaultAllowlist,
    popperConfig: null
  };
  var Event$2 = {
    HIDE: `hide${EVENT_KEY$4}`,
    HIDDEN: `hidden${EVENT_KEY$4}`,
    SHOW: `show${EVENT_KEY$4}`,
    SHOWN: `shown${EVENT_KEY$4}`,
    INSERTED: `inserted${EVENT_KEY$4}`,
    CLICK: `click${EVENT_KEY$4}`,
    FOCUSIN: `focusin${EVENT_KEY$4}`,
    FOCUSOUT: `focusout${EVENT_KEY$4}`,
    MOUSEENTER: `mouseenter${EVENT_KEY$4}`,
    MOUSELEAVE: `mouseleave${EVENT_KEY$4}`
  };
  var CLASS_NAME_FADE$2 = "fade";
  var CLASS_NAME_MODAL = "modal";
  var CLASS_NAME_SHOW$2 = "show";
  var HOVER_STATE_SHOW = "show";
  var HOVER_STATE_OUT = "out";
  var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  var EVENT_MODAL_HIDE = "hide.bs.modal";
  var TRIGGER_HOVER = "hover";
  var TRIGGER_FOCUS = "focus";
  var TRIGGER_CLICK = "click";
  var TRIGGER_MANUAL = "manual";
  var Tooltip = class extends BaseComponent {
    constructor(element, config) {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      }
      super(element);
      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = "";
      this._activeTrigger = {};
      this._popper = null;
      this._config = this._getConfig(config);
      this.tip = null;
      this._setListeners();
    }
    static get Default() {
      return Default$3;
    }
    static get NAME() {
      return NAME$4;
    }
    static get Event() {
      return Event$2;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle(event) {
      if (!this._isEnabled) {
        return;
      }
      if (event) {
        const context = this._initializeOnDelegatedTarget(event);
        context._activeTrigger.click = !context._activeTrigger.click;
        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$2)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this.tip) {
        this.tip.remove();
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!(this.isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }
      if (this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
        this._disposePopper();
        this.tip.remove();
        this.tip = null;
      }
      const tip = this.getTipElement();
      const tipId = getUID(this.constructor.NAME);
      tip.setAttribute("id", tipId);
      this._element.setAttribute("aria-describedby", tipId);
      if (this._config.animation) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      const placement = typeof this._config.placement === "function" ? this._config.placement.call(this, tip, this._element) : this._config.placement;
      const attachment = this._getAttachment(placement);
      this._addAttachmentClass(attachment);
      const {
        container
      } = this._config;
      Data.set(tip, this.constructor.DATA_KEY, this);
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
      }
      if (this._popper) {
        this._popper.update();
      } else {
        this._popper = createPopper3(this._element, tip, this._getPopperConfig(attachment));
      }
      tip.classList.add(CLASS_NAME_SHOW$2);
      const customClass = this._resolvePossibleFunction(this._config.customClass);
      if (customClass) {
        tip.classList.add(...customClass.split(" "));
      }
      if ("ontouchstart" in document.documentElement) {
        [].concat(...document.body.children).forEach((element) => {
          EventHandler.on(element, "mouseover", noop);
        });
      }
      const complete = () => {
        const prevHoverState = this._hoverState;
        this._hoverState = null;
        EventHandler.trigger(this._element, this.constructor.Event.SHOWN);
        if (prevHoverState === HOVER_STATE_OUT) {
          this._leave(null, this);
        }
      };
      const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);
      this._queueCallback(complete, this.tip, isAnimated);
    }
    hide() {
      if (!this._popper) {
        return;
      }
      const tip = this.getTipElement();
      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (this._hoverState !== HOVER_STATE_SHOW) {
          tip.remove();
        }
        this._cleanTipClass();
        this._element.removeAttribute("aria-describedby");
        EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);
        this._disposePopper();
      };
      const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      tip.classList.remove(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        [].concat(...document.body.children).forEach((element) => EventHandler.off(element, "mouseover", noop));
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);
      this._queueCallback(complete, this.tip, isAnimated);
      this._hoverState = "";
    }
    update() {
      if (this._popper !== null) {
        this._popper.update();
      }
    }
    isWithContent() {
      return Boolean(this.getTitle());
    }
    getTipElement() {
      if (this.tip) {
        return this.tip;
      }
      const element = document.createElement("div");
      element.innerHTML = this._config.template;
      const tip = element.children[0];
      this.setContent(tip);
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      this.tip = tip;
      return this.tip;
    }
    setContent(tip) {
      this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
    }
    _sanitizeAndSetContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!content && templateElement) {
        templateElement.remove();
        return;
      }
      this.setElementContent(templateElement, content);
    }
    setElementContent(element, content) {
      if (element === null) {
        return;
      }
      if (isElement2(content)) {
        content = getElement(content);
        if (this._config.html) {
          if (content.parentNode !== element) {
            element.innerHTML = "";
            element.append(content);
          }
        } else {
          element.textContent = content.textContent;
        }
        return;
      }
      if (this._config.html) {
        if (this._config.sanitize) {
          content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);
        }
        element.innerHTML = content;
      } else {
        element.textContent = content;
      }
    }
    getTitle() {
      const title = this._element.getAttribute("data-bs-original-title") || this._config.title;
      return this._resolvePossibleFunction(title);
    }
    updateAttachment(attachment) {
      if (attachment === "right") {
        return "end";
      }
      if (attachment === "left") {
        return "start";
      }
      return attachment;
    }
    _initializeOnDelegatedTarget(event, context) {
      return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((val) => Number.parseInt(val, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _resolvePossibleFunction(content) {
      return typeof content === "function" ? content.call(this._element) : content;
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "onChange",
          enabled: true,
          phase: "afterWrite",
          fn: (data) => this._handlePopperPlacementChange(data)
        }],
        onFirstUpdate: (data) => {
          if (data.options.placement !== data.placement) {
            this._handlePopperPlacementChange(data);
          }
        }
      };
      return {
        ...defaultBsPopperConfig,
        ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
      };
    }
    _addAttachmentClass(attachment) {
      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}`);
    }
    _getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    }
    _setListeners() {
      const triggers = this._config.trigger.split(" ");
      triggers.forEach((trigger) => {
        if (trigger === "click") {
          EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, (event) => this.toggle(event));
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
          EventHandler.on(this._element, eventIn, this._config.selector, (event) => this._enter(event));
          EventHandler.on(this._element, eventOut, this._config.selector, (event) => this._leave(event));
        }
      });
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._config.selector) {
        this._config = {
          ...this._config,
          trigger: "manual",
          selector: ""
        };
      } else {
        this._fixTitle();
      }
    }
    _fixTitle() {
      const title = this._element.getAttribute("title");
      const originalTitleType = typeof this._element.getAttribute("data-bs-original-title");
      if (title || originalTitleType !== "string") {
        this._element.setAttribute("data-bs-original-title", title || "");
        if (title && !this._element.getAttribute("aria-label") && !this._element.textContent) {
          this._element.setAttribute("aria-label", title);
        }
        this._element.setAttribute("title", "");
      }
    }
    _enter(event, context) {
      context = this._initializeOnDelegatedTarget(event, context);
      if (event) {
        context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
      }
      if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$2) || context._hoverState === HOVER_STATE_SHOW) {
        context._hoverState = HOVER_STATE_SHOW;
        return;
      }
      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_SHOW;
      if (!context._config.delay || !context._config.delay.show) {
        context.show();
        return;
      }
      context._timeout = setTimeout(() => {
        if (context._hoverState === HOVER_STATE_SHOW) {
          context.show();
        }
      }, context._config.delay.show);
    }
    _leave(event, context) {
      context = this._initializeOnDelegatedTarget(event, context);
      if (event) {
        context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
      }
      if (context._isWithActiveTrigger()) {
        return;
      }
      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_OUT;
      if (!context._config.delay || !context._config.delay.hide) {
        context.hide();
        return;
      }
      context._timeout = setTimeout(() => {
        if (context._hoverState === HOVER_STATE_OUT) {
          context.hide();
        }
      }, context._config.delay.hide);
    }
    _isWithActiveTrigger() {
      for (const trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }
      return false;
    }
    _getConfig(config) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      Object.keys(dataAttributes).forEach((dataAttr) => {
        if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
          delete dataAttributes[dataAttr];
        }
      });
      config = {
        ...this.constructor.Default,
        ...dataAttributes,
        ...typeof config === "object" && config ? config : {}
      };
      config.container = config.container === false ? document.body : getElement(config.container);
      if (typeof config.delay === "number") {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }
      if (typeof config.title === "number") {
        config.title = config.title.toString();
      }
      if (typeof config.content === "number") {
        config.content = config.content.toString();
      }
      typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
      if (config.sanitize) {
        config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
      }
      return config;
    }
    _getDelegateConfig() {
      const config = {};
      for (const key in this._config) {
        if (this.constructor.Default[key] !== this._config[key]) {
          config[key] = this._config[key];
        }
      }
      return config;
    }
    _cleanTipClass() {
      const tip = this.getTipElement();
      const basicClassPrefixRegex = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g");
      const tabClass = tip.getAttribute("class").match(basicClassPrefixRegex);
      if (tabClass !== null && tabClass.length > 0) {
        tabClass.map((token) => token.trim()).forEach((tClass) => tip.classList.remove(tClass));
      }
    }
    _getBasicClassPrefix() {
      return CLASS_PREFIX$1;
    }
    _handlePopperPlacementChange(popperData) {
      const {
        state
      } = popperData;
      if (!state) {
        return;
      }
      this.tip = state.elements.popper;
      this._cleanTipClass();
      this._addAttachmentClass(this._getAttachment(state.placement));
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Tooltip.getOrCreateInstance(this, config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  defineJQueryPlugin(Tooltip);
  var NAME$3 = "popover";
  var DATA_KEY$3 = "bs.popover";
  var EVENT_KEY$3 = `.${DATA_KEY$3}`;
  var CLASS_PREFIX = "bs-popover";
  var Default$2 = {
    ...Tooltip.Default,
    placement: "right",
    offset: [0, 8],
    trigger: "click",
    content: "",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  };
  var DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: "(string|element|function)"
  };
  var Event$1 = {
    HIDE: `hide${EVENT_KEY$3}`,
    HIDDEN: `hidden${EVENT_KEY$3}`,
    SHOW: `show${EVENT_KEY$3}`,
    SHOWN: `shown${EVENT_KEY$3}`,
    INSERTED: `inserted${EVENT_KEY$3}`,
    CLICK: `click${EVENT_KEY$3}`,
    FOCUSIN: `focusin${EVENT_KEY$3}`,
    FOCUSOUT: `focusout${EVENT_KEY$3}`,
    MOUSEENTER: `mouseenter${EVENT_KEY$3}`,
    MOUSELEAVE: `mouseleave${EVENT_KEY$3}`
  };
  var SELECTOR_TITLE = ".popover-header";
  var SELECTOR_CONTENT = ".popover-body";
  var Popover = class extends Tooltip {
    static get Default() {
      return Default$2;
    }
    static get NAME() {
      return NAME$3;
    }
    static get Event() {
      return Event$1;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    isWithContent() {
      return this.getTitle() || this._getContent();
    }
    setContent(tip) {
      this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);
      this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    _getBasicClassPrefix() {
      return CLASS_PREFIX;
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Popover.getOrCreateInstance(this, config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  defineJQueryPlugin(Popover);
  var NAME$2 = "scrollspy";
  var DATA_KEY$2 = "bs.scrollspy";
  var EVENT_KEY$2 = `.${DATA_KEY$2}`;
  var DATA_API_KEY$1 = ".data-api";
  var Default$1 = {
    offset: 10,
    method: "auto",
    target: ""
  };
  var DefaultType$1 = {
    offset: "number",
    method: "string",
    target: "(string|element)"
  };
  var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  var EVENT_SCROLL = `scroll${EVENT_KEY$2}`;
  var EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;
  var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  var CLASS_NAME_ACTIVE$1 = "active";
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
  var SELECTOR_NAV_LINKS = ".nav-link";
  var SELECTOR_NAV_ITEMS = ".nav-item";
  var SELECTOR_LIST_ITEMS = ".list-group-item";
  var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, .${CLASS_NAME_DROPDOWN_ITEM}`;
  var SELECTOR_DROPDOWN$1 = ".dropdown";
  var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  var METHOD_OFFSET = "offset";
  var METHOD_POSITION = "position";
  var ScrollSpy = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._scrollElement = this._element.tagName === "BODY" ? window : this._element;
      this._config = this._getConfig(config);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());
      this.refresh();
      this._process();
    }
    static get Default() {
      return Default$1;
    }
    static get NAME() {
      return NAME$2;
    }
    refresh() {
      const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
      const offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
      const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      const targets = SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target);
      targets.map((element) => {
        const targetSelector = getSelectorFromElement(element);
        const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;
        if (target) {
          const targetBCR = target.getBoundingClientRect();
          if (targetBCR.width || targetBCR.height) {
            return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];
          }
        }
        return null;
      }).filter((item) => item).sort((a, b) => a[0] - b[0]).forEach((item) => {
        this._offsets.push(item[0]);
        this._targets.push(item[1]);
      });
    }
    dispose() {
      EventHandler.off(this._scrollElement, EVENT_KEY$2);
      super.dispose();
    }
    _getConfig(config) {
      config = {
        ...Default$1,
        ...Manipulator.getDataAttributes(this._element),
        ...typeof config === "object" && config ? config : {}
      };
      config.target = getElement(config.target) || document.documentElement;
      typeCheckConfig(NAME$2, config, DefaultType$1);
      return config;
    }
    _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }
    _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
    _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }
    _process() {
      const scrollTop = this._getScrollTop() + this._config.offset;
      const scrollHeight = this._getScrollHeight();
      const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }
      if (scrollTop >= maxScroll) {
        const target = this._targets[this._targets.length - 1];
        if (this._activeTarget !== target) {
          this._activate(target);
        }
        return;
      }
      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;
        this._clear();
        return;
      }
      for (let i = this._offsets.length; i--; ) {
        const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    }
    _activate(target) {
      this._activeTarget = target;
      this._clear();
      const queries = SELECTOR_LINK_ITEMS.split(",").map((selector) => `${selector}[data-bs-target="${target}"],${selector}[href="${target}"]`);
      const link = SelectorEngine.findOne(queries.join(","), this._config.target);
      link.classList.add(CLASS_NAME_ACTIVE$1);
      if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);
      } else {
        SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach((listGroup) => {
          SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach((item) => item.classList.add(CLASS_NAME_ACTIVE$1));
          SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach((navItem) => {
            SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach((item) => item.classList.add(CLASS_NAME_ACTIVE$1));
          });
        });
      }
      EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _clear() {
      SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).filter((node) => node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach((node) => node.classList.remove(CLASS_NAME_ACTIVE$1));
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    SelectorEngine.find(SELECTOR_DATA_SPY).forEach((spy) => new ScrollSpy(spy));
  });
  defineJQueryPlugin(ScrollSpy);
  var NAME$1 = "tab";
  var DATA_KEY$1 = "bs.tab";
  var EVENT_KEY$1 = `.${DATA_KEY$1}`;
  var DATA_API_KEY = ".data-api";
  var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;
  var CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
  var CLASS_NAME_ACTIVE = "active";
  var CLASS_NAME_FADE$1 = "fade";
  var CLASS_NAME_SHOW$1 = "show";
  var SELECTOR_DROPDOWN = ".dropdown";
  var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  var SELECTOR_ACTIVE = ".active";
  var SELECTOR_ACTIVE_UL = ":scope > li > .active";
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var SELECTOR_DROPDOWN_ACTIVE_CHILD = ":scope > .dropdown-menu .active";
  var Tab = class extends BaseComponent {
    static get NAME() {
      return NAME$1;
    }
    show() {
      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
        return;
      }
      let previous;
      const target = getElementFromSelector(this._element);
      const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);
      if (listElement) {
        const itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
        previous = SelectorEngine.find(itemSelector, listElement);
        previous = previous[previous.length - 1];
      }
      const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
        relatedTarget: this._element
      }) : null;
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
        relatedTarget: previous
      });
      if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
        return;
      }
      this._activate(this._element, listElement);
      const complete = () => {
        EventHandler.trigger(previous, EVENT_HIDDEN$1, {
          relatedTarget: this._element
        });
        EventHandler.trigger(this._element, EVENT_SHOWN$1, {
          relatedTarget: previous
        });
      };
      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    }
    _activate(element, container, callback) {
      const activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
      const active = activeElements[0];
      const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);
      const complete = () => this._transitionComplete(element, active, callback);
      if (active && isTransitioning) {
        active.classList.remove(CLASS_NAME_SHOW$1);
        this._queueCallback(complete, element, true);
      } else {
        complete();
      }
    }
    _transitionComplete(element, active, callback) {
      if (active) {
        active.classList.remove(CLASS_NAME_ACTIVE);
        const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);
        if (dropdownChild) {
          dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
        }
        if (active.getAttribute("role") === "tab") {
          active.setAttribute("aria-selected", false);
        }
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      if (element.getAttribute("role") === "tab") {
        element.setAttribute("aria-selected", true);
      }
      reflow(element);
      if (element.classList.contains(CLASS_NAME_FADE$1)) {
        element.classList.add(CLASS_NAME_SHOW$1);
      }
      let parent = element.parentNode;
      if (parent && parent.nodeName === "LI") {
        parent = parent.parentNode;
      }
      if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
        const dropdownElement = element.closest(SELECTOR_DROPDOWN);
        if (dropdownElement) {
          SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach((dropdown) => dropdown.classList.add(CLASS_NAME_ACTIVE));
        }
        element.setAttribute("aria-expanded", true);
      }
      if (callback) {
        callback();
      }
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Tab.getOrCreateInstance(this);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const data = Tab.getOrCreateInstance(this);
    data.show();
  });
  defineJQueryPlugin(Tab);
  var NAME = "toast";
  var DATA_KEY = "bs.toast";
  var EVENT_KEY = `.${DATA_KEY}`;
  var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  var EVENT_HIDE = `hide${EVENT_KEY}`;
  var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  var EVENT_SHOW = `show${EVENT_KEY}`;
  var EVENT_SHOWN = `shown${EVENT_KEY}`;
  var CLASS_NAME_FADE = "fade";
  var CLASS_NAME_HIDE = "hide";
  var CLASS_NAME_SHOW = "show";
  var CLASS_NAME_SHOWING = "showing";
  var DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5e3
  };
  var Toast = class extends BaseComponent {
    constructor(element, config) {
      super(element);
      this._config = this._getConfig(config);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get Default() {
      return Default;
    }
    static get NAME() {
      return NAME;
    }
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE);
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW);
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE);
        this._element.classList.remove(CLASS_NAME_SHOWING);
        this._element.classList.remove(CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this._element.classList.contains(CLASS_NAME_SHOW)) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    _getConfig(config) {
      config = {
        ...Default,
        ...Manipulator.getDataAttributes(this._element),
        ...typeof config === "object" && config ? config : {}
      };
      typeCheckConfig(NAME, config, this.constructor.DefaultType);
      return config;
    }
    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = isInteracting;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = isInteracting;
          break;
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    static jQueryInterface(config) {
      return this.each(function() {
        const data = Toast.getOrCreateInstance(this, config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config](this);
        }
      });
    }
  };
  enableDismissTrigger(Toast);
  defineJQueryPlugin(Toast);

  // <stdin>
  function communityMap(community) {
    var map = new import_maplibre_gl.Map({
      container: "map",
      style: "https://demotiles.maplibre.org/style.json",
      center: [0, 0],
      zoom: 1,
      hash: true,
      attributionControl: false
    }).addControl(new import_maplibre_gl.AttributionControl({
      compact: false,
      customAttribution: 'OpenStreetMap contributors. | <a href="https://github.com/maplibre/community">Edit on GitHub.</a>'
    }));
    map.addControl(new import_maplibre_gl.NavigationControl());
    const lngs = community.map((person) => person.latlon[1]);
    const lats = community.map((person) => person.latlon[0]);
    map.fitBounds([
      [Math.min(...lngs), Math.min(...lats)],
      [Math.max(...lngs), Math.max(...lats)]
    ], { padding: 50 });
    community.map((person) => {
      var el = document.createElement("a");
      el.className = "marker";
      el.style.backgroundImage = `url(${person.url})`;
      el.style.width = "50px";
      el.style.height = "50px";
      el.href = person.href;
      el.title = person.name;
      new import_maplibre_gl.Marker(el).setLngLat([person.latlon[1], person.latlon[0]]).addTo(map);
    });
  }
  function mapPreview() {
    var map = new import_maplibre_gl.Map({
      container: "map",
      style: "https://demotiles.maplibre.org/style.json",
      center: [0, 0],
      zoom: 1
    });
    var mapAnimation = [
      {
        lng: -0.08411085041984734,
        lat: 7.115464377381386,
        Zoom: 1.3295073440521066,
        Duration: 0,
        Pause: 0,
        Rotation: 0,
        Pitch: 0
      },
      {
        lng: 15.44385629163537,
        lat: 41.56277698075792,
        Zoom: 3.4916772106200415,
        Duration: 5e3,
        Pause: 3e3,
        Rotation: 0,
        Pitch: 0
      },
      {
        lng: 5.388541216098361,
        lat: 45.57339756361293,
        Zoom: 6.15010124013107,
        Duration: 1e4,
        Pause: 8e3,
        Rotation: 0,
        Pitch: 0
      },
      {
        lng: -0.08411085041984734,
        lat: 7.115464377381386,
        Zoom: 1.3295073440521066,
        Duration: 1e5,
        Pause: 18e3,
        Rotation: 0,
        Pitch: 0
      }
    ];
    var lastPoint = mapAnimation[mapAnimation.length - 1];
    function playAnimation() {
      mapAnimation.forEach(function(item, index) {
        setTimeout(function() {
          map.flyTo({
            duration: item.Duration,
            center: [item.lng, item.lat],
            zoom: item.Zoom,
            bearing: item.Rotation,
            pitch: item.Pitch,
            essential: true
          });
        }, item.Pause);
      });
    }
    window.onload = playAnimation, setInterval(playAnimation, lastPoint.Pause + lastPoint.Duration);
  }
  function terrain3dMap() {
    var map = window.map = new import_maplibre_gl.Map({
      container: "map",
      zoom: 12,
      center: [11.39085, 47.27574],
      pitch: 52,
      hash: true,
      style: {
        version: 8,
        sources: {
          osm: {
            type: "raster",
            tiles: ["https://a.tile.openstreetmap.org/{z}/{x}/{y}.png"],
            tileSize: 256,
            attribution: "&copy; OpenStreetMap Contributors",
            maxzoom: 19
          },
          terrainSource: {
            type: "raster-dem",
            url: "https://demotiles.maplibre.org/terrain-tiles/tiles.json",
            tileSize: 256
          },
          hillshadeSource: {
            type: "raster-dem",
            url: "https://demotiles.maplibre.org/terrain-tiles/tiles.json",
            tileSize: 256
          }
        },
        layers: [
          {
            id: "osm",
            type: "raster",
            source: "osm"
          },
          {
            id: "hills",
            type: "hillshade",
            source: "hillshadeSource",
            layout: { visibility: "visible" },
            paint: { "hillshade-shadow-color": "#473B24" }
          }
        ],
        terrain: {
          source: "terrainSource",
          exaggeration: 1
        }
      },
      maxZoom: 18,
      maxPitch: 85
    });
    map.addControl(new import_maplibre_gl.NavigationControl({
      visualizePitch: true,
      showZoom: true,
      showCompass: true
    }));
    map.addControl(new import_maplibre_gl.TerrainControl({
      source: "terrainSource",
      exaggeration: 1
    }));
  }
  window.communityMap = communityMap;
  window.mapPreview = mapPreview;
  window.terrain3dMap = terrain3dMap;
})();
/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
